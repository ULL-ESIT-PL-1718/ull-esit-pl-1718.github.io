\documentclass[spanish,a4paper,11pt]{letter}

\usepackage{latexsym,amsfonts,amssymb,amstext,amsthm,float,amsmath}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{epsfig}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%123456789012345678901234567890123456789012345678901234567890123456789
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Format
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\topmargin -21 mm
\headheight 10 mm
\headsep 10 mm
\textheight 256 mm
\oddsidemargin -5.4 mm
\evensidemargin -5.4 mm
\textwidth 17 cm
\columnsep 10 mm
\pagestyle{empty}
\input{amssym.def}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{tabular}{lccr}
%%%%
  \begin{tabular}{c}
   \epsfig{file=../ullesc.eps,width=3.5cm} \\
   \tiny{E.T.S. Ingeniería Informática} \\
   \tiny{Dpto. Estadística, I.O. y Computación}
  \end{tabular}                      & & &
%%%%
  \begin{tabular}{c}
  \large{\textbf{Lenguajes y Paradigmas de Programación}} \\
  Tema 3 - Segunda parte \hspace{3cm} \textbf{Hoja de problemas} 
  \end{tabular}        
%%%%
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}

\bigskip
\item ¿Cómo se denomina la clase a la que pertenecen las clases de \texttt{Ruby}? 
      Dibuje la jerarquía de clases a la que pertenece.

\bigskip
\item ¿Qué se obtiene como salida?
\begin{footnotesize}
\begin{verbatim}
> class MyClass
> end
=> nil
> MyClass.class
=> ?
> String.class
=> ?
> Object.class
=> ?
> Class.class
=> ?
\end{verbatim}
\end{footnotesize}

%irb(main):001:0> class MyClass
%irb(main):002:1> end
%=> nil
%irb(main):003:0> MyClass.class
%=> Class
%irb(main):004:0> String.class
%=> Class
%irb(main):005:0> Object.class
%=> Class
%irb(main):006:0> Class.class
%=> Class

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa. 
\begin{footnotesize}
\begin{verbatim}
def show (a_class)
  if (a_class != nil) then
          puts "#{a_class}:: es hija de = #{a_class.superclass}"
                show(a_class.superclass)
  end
end
show(Fixnum)
\end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es un método singleton?
%es un método que pertenece a un único objeto en lugar de a una clase entera

\bigskip
\item ¿Cuál es la sintaxis \texttt{Ruby} para crear un método singleton?
% def my_object.object_method
%
% end

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa. 
\begin{footnotesize}
\begin{verbatim}
class AClass
  def m
    'method m'
  end
end

obj = AClass.new

def obj.s1
  'method s1'
end

class << obj
  def s2
    'method s2'
  end
end

puts obj.m
puts obj.s1
puts obj.s2
\end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es la \texttt{eigenclass}?


\bigskip
\item Describa el algoritmo de búsqueda de \texttt{Ruby} para el método \verb|my_method()|:
\begin{footnotesize}
\begin{verbatim}
class MyClass 
  def my_method; 'my_method()'; end
end
class MysubClass < MyClass
end
obj = MySubclass.new
obj.my_method() \end{verbatim}
\end{footnotesize}

\bigskip
\item Describa el algoritmo de búsqueda de \texttt{Ruby} para el método \verb|my_method()|:
\begin{footnotesize}
\begin{verbatim}
module M
  def my_method; 'M#my_method()'; end
end
class C 
  include M
end
class D < C ; end
D.new.my_method() \end{verbatim}
\end{footnotesize}

\bigskip
\item Considere el siguiente código \texttt{Ruby}: 
\begin{footnotesize}
\begin{verbatim}
1  def Integer.a_method(x)
2    x.to_i
3  end
4  n = Fixnum.a_method("5") \end{verbatim}
\end{footnotesize}
Describa el algoritmo de búsqueda de la invocación de la línea 4.

\bigskip
\item ¿Qué es un método singleton de una clase?

\bigskip
\item ¿Qué se está declarando? 
\begin{footnotesize}
\begin{verbatim}
  class << AClass
    def a_method
      'a_method'
    end
  end \end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué tipo de ámbito se utiliza para la búsqueda de constantes en Ruby?

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa.¿Qué contiene la variable \texttt{search}? 
\begin{footnotesize}
\begin{verbatim}
module Kernel
  A=B=C=D=E=F="defined in Kernel"
end
#Top level or global constant defined in Object
  A=B=C=D=E="defined at top-level"
class Super
  A=B=C=D="defined in superclass"
end
module Included
  A=B=C="defined in included module"
end
module Enclosing 
  A=B="defined in enclosing module"
  class Local < Super
    include Included
    A = "defined locally"
    search = (Module.nesting + self.ancestors + Object.ancestors).uniq
    puts A
    puts B
    puts C
    puts D
    puts E
    puts F
  end
end \end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es la invalidación de métodos?
%cuando se quiere redefinir un método que ya existe en alguna clase.
%Cuando un método en una clase reemplaza a un método con el mismo nombre en
%en una clase antecesora se dice que se ha invalidado el método.

\bigskip
\item Considere el siguiente programa \texttt{Ruby}. 
\begin{footnotesize}
\begin{verbatim}
  1 class AClass
  2   def s
  3     'a_s'
  4   end
  5
  6   def g
  7     'a_g'
  8   end
  9 end
 10
 11 class OtherClass < AClass
 12   def s
 13     'o_s'
 14   end
 15
 16   def g
 17     super << " and o_g"
 18   end
 19 end
\end{verbatim}
\end{footnotesize}
  \begin{enumerate}
     \item ¿Qué se hace en la línea 12?
     \item ¿Qué se hace en la línea 16?
  \end{enumerate}

\bigskip
\item ¿Qué devuelve? ¿Por qué? 
\begin{footnotesize}
\begin{verbatim}
def a_method
end \end{verbatim}
\end{footnotesize}
%nil

\bigskip
\item ¿Qué devuelve? ¿Por qué? 
\begin{footnotesize}
\begin{verbatim}
def a_method
  s = "message"
  a = 1
  b = 2.0
  return a, b, 3, 'four', s, 6*10
end \end{verbatim}
\end{footnotesize}
%un array

\bigskip
\item ¿Qué devuelve? ¿Por qué? 
\begin{footnotesize}
\begin{verbatim}
def a_method
  {'a' => '1', 'b' => '2', 'c' => '3'} 
end \end{verbatim}
\end{footnotesize}
%un hash

\bigskip
\item ¿Cuál es la salida? ¿Por qué? 
\begin{footnotesize}
\begin{verbatim}
> def a_method(a = 10, b = 20, c = 100, *d)
>   return a,b,c,d
> end
=> nil
> a_method(1,2,3,4,5,6)
=> ? 
> \end{verbatim}
\end{footnotesize}
% irb(main):008:0> a_method(1,2,3,4,5,6)
%=> [1, 2, 3, [4, 5, 6]]
% un array para el último argumento.

\bigskip
\item Señale el error de concepto en la codificación de la siguiente clase \texttt{Ruby}:
\begin{footnotesize}
\begin{verbatim}
class MyClass 
  def initialize(x,y)
    @x, @y = x, y 
  end
  def polar(x,y)
    Math.hypot(y,x), Math.atan2(y,x) 
  end
end
\end{verbatim}
\end{footnotesize}

\bigskip
\item Considere el siguiente programa \texttt{Ruby}. 
\begin{footnotesize}
\begin{verbatim}
  1 s = 'message 1'
  2 r = 'message 2'
  3
  4 def s
  5   'message from s'
  6 end
  7
  8 def r
  9   'message from r'
 10 end
 11
 12 def t(x)
 13   "#{x}"
 14 end
 15
 16 puts (r)
 17 puts r
 18 puts r()
 19 puts (t(s))
 20 puts (t(s()))
\end{verbatim}
\end{footnotesize}
  \begin{enumerate}
     \item ¿Qué permite diferenciar las líneas 16, 17 y 18?
     \item ¿Qué diferencia hay entre las líneas 19 y 20?
  \end{enumerate}

\bigskip
\item ¿Qué es un bloque en \texttt{Ruby}?
% Un trozo de código que puede ir entre {} o entre las palabras reservadas do end

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa.
\begin{footnotesize}
\begin{verbatim}
class MyArray < Array
  def initialize (a_array)
    super (a_array)
  end

  def times_repeat (a_num)
    a_num.times do |num|
      self.each do |i|
        yield "[#{num}] :: '#{i}'"
      end
    end
  end
end

a_array = MyArray.new([1,2,3])
a_array.times_repeat(2) do |x|
  puts x
end \end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es un \texttt{Proc}?
%es un bloque que se convierte en un objeto

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa.
\begin{footnotesize}
\begin{verbatim}
def a_method( a_block_argument)
  x = "Bye"
  a_block_argument.call
end

x = "Hello"
a_block = Proc.new {puts x}

a_method(a_block) \end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es un \texttt{lambda}?

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa. 
\begin{footnotesize}
\begin{verbatim}
def a_lambda( arg )
  return lambda {|i| i * arg}
end

a = a_lambda(0.10)
b = a_lambda(0.175)

puts a.call(10)
puts b.call(10)
\end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Cómo se define una \texttt{closure}?
%es una función que tiene la habilidad de almacenar (adjuntar) los valores de las variables locales
%dentro del ámbito en el que el bloque fue creado (el ambiente nativo del bloque).
%los bloques Ruby son closures.

\bigskip
\item Considere el siguiente código \texttt{Ruby}: 
\begin{footnotesize}
\begin{verbatim}
array = [1,2,3,4]

array.collect! do |n|
  n ** 2
end

puts array \end{verbatim}
\end{footnotesize}
  \begin{enumerate}
    \item Escriba el código de un método denomidado \texttt{iterador!} que se comporte de la 
          misma forma utilizando \texttt{yield}.
    \item Repita el ejercicio anterior utilizando un objeto \texttt{Proc}.
  \end{enumerate}

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa. 
\begin{footnotesize}
\begin{verbatim}
class AClass
  def a_method(a_block)
    @hello = "I say"
    puts "[ In AClass.a_method ] "
    puts "in #{self} object of class #{self.class}, @hello = #{@hello}"
    puts "[ In AClass.a_method ] when block is called... "
    a_block.call
  end
end

a_closure = lambda {
  @hello << " append!"
  puts "in #{self} object of class #{self.class}, @hello = #{@hello}"
}

def a_method(a_closure)
  @hello = "hello"
        a_closure.call
end

a_method(a_closure)
data = AClass.new
data.a_method(a_closure)
\end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es la reflexión o instrospección?

\bigskip
\item ¿Qué se entiende por metaprogramación?

\bigskip
\item ¿Qué es un Lenguaje de Dominio específico (DSL- \textit{Domain Specific Language})?

\bigskip
\item ¿Qué es un contexto (\texttt{binding})?


\bigskip
\item ¿Qué es ?

\bigskip
\item ¿Qué se obtiene como salida? Describa el comportamiento del programa. 
\begin{footnotesize}
\begin{verbatim}
\end{verbatim}
\end{footnotesize}

\bigskip
\item ¿Qué es una \texttt{Gema} (\textit{Gem})?

\bigskip
\item ¿Qué es RDOC, ...?

\bigskip
\item ¿Qué es una gema (\textit{Gem})?

\bigskip
\item ¿Qué es \textit{bundler}?

\bigskip
\item ¿Qué estructura de directorios genera la orden \verb|bundle gem ejemplo|?

\bigskip
\item ¿Qué contiene el directorio VERSION?

\bigskip
\item ¿Qué contiene el fichero Gemfile? 

\bigskip
\item ¿Cuáles son las órdenes por defecto del fichero rakefile generado por bundle? 



\item ¿En qué consiste la creación de una Gema (\textit{Gem})?

\bigskip
\item ¿En qué directorio hay que implementar el fichero de configuración de la Gema?

\bigskip
\item ¿cómo se publica una gema?

\bigskip
\item ¿Cómo se pone en funcionamiento \texttt{rdoc}? 


\end{enumerate}


\end{document}
