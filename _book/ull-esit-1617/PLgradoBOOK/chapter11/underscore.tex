\parrafo{Underscore}

\htmladdnormallink{Underscore}{http://underscorejs.org/}:
is a utility-belt library for JavaScript that provides a
lot of the functional programming support that you would expect in
Ruby.

\begin{itemize}
\item
Underscore provides functions that support 
methods like: 

\verb|map|, \verb|select|, \verb|invoke|  

\item
as well as more specialized helpers:

En ECMAScript 5/JavaScript 1.6.  existen los métodos 
\verb|map|, \verb|filter|, \verb|forEach| y  \verb|reduce| similares
a los de Underscore.

\begin{itemize}
\item
function binding
\item
 javascript templating
\item
 deep equality testing
\item
 and so on. 
\end{itemize}

\begin{itemize}
\item
Cargando la librería:
\begin{verbatim}
[~/javascript/jquery(master)]$ node
> 2+3
5
> _
5
> uu = require('underscore')
{ [Function]
  _: [Circular],
  VERSION: '1.5.2',
  forEach: [Function],
  each: [Function],
  collect: [Function],
  map: [Function],
  inject: [Function],
  reduce: [Function],
  .................
  chain: [Function] }
\end{verbatim}

\item \verb|each|:

\begin{verbatim}
> uu.each([1, 2, 3], function(x) { console.log(x*x); })
1
4
9
\end{verbatim}

\item
\verb|map|:
\begin{verbatim}
> uu.map([1, 2, 3], function(num){ return num * 3; })
[ 3, 6, 9 ]
\end{verbatim}
\item \verb|invoke|
\begin{verbatim}
> z = [[6,9,1],[7,3,9]]
[ [ 6, 9, 1 ], [ 7, 3, 9 ] ]
> uu.invoke(z, 'sort')
[ [ 1, 6, 9 ], [ 3, 7, 9 ] ]
> uu.invoke(z, 'sort', function(a, b) { return b-a; })
[ [ 9, 6, 1 ], [ 9, 7, 3 ] ]
\end{verbatim}
\item
\verb|reduce|:
\begin{verbatim}
> uu.reduce([1, 2, 3, 4], function(s, num){ return s + num; }, 0)
10
> uu.reduce([1, 2, 3, 4], function(s, num){ return s * num; }, 1)
24
> uu.reduce([1, 2, 3, 4], function(s, num){ return Math.max(s, num); }, -1)
4
> uu.reduce([1, 2, 3, 4], function(s, num){ return Math.min(s, num); }, 99)
1
\end{verbatim}

\item \verb|filter|: (\verb|select| is an alias for \verb|filter|)
\begin{verbatim}
> uu.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; })
[ 2, 4, 6 ]
\end{verbatim}
\item \verb|isEqual|
\begin{verbatim}
> a = {a:[1,2,3], b: { c: 1, d: [5,6]}}
{ a: [ 1, 2, 3 ],
  b: { c: 1, d: [ 5, 6 ] } }
> b = {a:[1,2,3], b: { c: 1, d: [5,6]}}
{ a: [ 1, 2, 3 ],
  b: { c: 1, d: [ 5, 6 ] } }
> a == b
false
> uu.isEqual(a,b)
true
\end{verbatim}
\item \verb|bind|
\begin{verbatim}
> func = function(greeting){ return greeting + ': ' + this.name }
[Function]
> func = uu.bind(func, {name: 'moe'})
[Function]
> func('hello')
'hello: moe'
> func = uu.bind(func, {name: 'moe'}, 'hi')
[Function]
> func()
'hi: moe'
> 
\end{verbatim}
Los objetos \verb|Function| disponen de un método \verb|bind|
nativo en las últimas versiones de JS:
\begin{verbatim}
> func = function(){ return 'hola ' + this.name }
[Function]
> g = func.bind({name: 'Juan'})
[Function]
> g()
'hola Juan'
> g = func.bind({name: 'Pedro'})
[Function]
> g()
'hola Pedro'
\end{verbatim}
\end{itemize}
\end{itemize}

\parrafo{Templates en Underscore}

\begin{itemize}
\item 
\htmladdnormallink{Underscore: template}{http://underscorejs.org/\#template}

\verb|_.template(templateString, [data], [settings])|

Compiles JavaScript templates into functions that can be evaluated for
rendering. Useful for rendering complicated bits of HTML from a JavaScript 
object or from \cei{JSON} data
sources.

JSON, or \cei{JavaScript Object Notation}, is an open standard format
that uses human-readable text to transmit data objects consisting of
attribute–value pairs. It is used primarily to transmit data between
a server and web application, as an alternative to XML.
Although originally derived from the JavaScript scripting language,
JSON is a language-independent data format, and code for parsing
and generating JSON data is readily available in a large variety of
programming languages.

\begin{itemize}
\item
Template functions can both interpolate variables, using 
\verb|<%= … %>|, 

\begin{verbatim}
> compiled = uu.template("hello: <%= name %>")
{ [Function]
  source: 'function(obj){
    var __t,__p=\'\', __j=Array.prototype.join, i
        print=function(){__p+=__j.call(arguments,\'\');};
    with(obj||{}){
      __p+=\'hello: \'+ ((__t=( name ))==null?\'\':__t)+ \'\';
    }
    return __p;
  }' 
}
> compiled({name: 'moe'})
'hello: moe'
\end{verbatim}
\item
as well as execute arbitrary JavaScript code, with 
\verb|<% … %>|. 

\begin{verbatim}
> uu = require('underscore')
> list = "\
... <% _.each(people, function(name) { %>\
..... <li><%= name %></li>\
... <% }); %>"
'<% _.each(people, function(name) { %> <li><%= name %></li> <% }); %>'
> uu.template(list, {people: ['moe', 'curly', 'larry']})
' <li>moe</li>  <li>curly</li>  <li>larry</li> '
\end{verbatim}

\item
When you evaluate a template function, pass in a data object
that has properties corresponding to the template's free variables. 

\item
If
you're writing a one-off, like in the example above, 
you can pass the data object as the second
parameter to template in order to render immediately instead of returning
a template function 
\begin{verbatim}
> uu.template("hello: <%= name %>", { name: 'Mary'})
'hello: Mary'
\end{verbatim}
\item
If
you wish to interpolate a value, and have it be HTML-escaped, use 
\verb|<%- … %>| 

\begin{verbatim}
> template = uu.template("<b><%- value %></b>")
{ [Function]
  source: 'function(obj){
    var __t,__p=\'\',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,\'\');};
    with(obj||{}){
      __p+=\'<b>\'+
      ((__t=( value ))==null?\'\':_.escape(__t))+
      \'</b>\';
    }
    return __p;
  }' 
}
> template({value: '<script>'})
'<b>&lt;script&gt;</b>'
\end{verbatim}

\item
The \verb|settings| argument should be a hash containing
any \verb|_.templateSettings| that should be overridden.
\begin{verbatim}
_.template("Using 'with': <%= data.answer %>", {answer: 'no'}, {variable: 'data'});
=> "Using 'with': no"
\end{verbatim}
Another example:
\begin{verbatim}
template = uu.template("<b>{{ value }}</b>",{value: 4 },
                      { interpolate: /\{\{(.+?)\}\}/g })
'<b>4</b>'
\end{verbatim}
\end{itemize}

You can also use \verb|print| from within JavaScript code. This is sometimes
more convenient than using \verb|<%= ... %>|.

\begin{verbatim}
> compiled = uu.template("<% print('Hello ' + epithet); %>")
{ [Function]
  source: 'function(obj){\n
    var __t,__p=\'\',
        __j=Array.prototype.join,print=function(){
            __p+=__j.call(arguments,\'\');};\n
            with(obj||{}){\n
              __p+=\'\';\n print(\'Hello \' + epithet); \n
              __p+=\'\';\n}\n
              return __p;\n
  }' 
}
> compiled({ epithet : 'stooge' })
'Hello stooge'
> 
\end{verbatim}

If ERB-style delimiters aren't your cup of tea, you can change
Underscore's template settings to use different symbols to set off
interpolated code: 

\begin{itemize}
\item
Define an \verb|interpolate| regex to match expressions that
should be interpolated verbatim, 
\item
an \verb|escape| regex to match expressions
that should be inserted after being HTML escaped, and 
\item
an \verb|evaluate| regex
to match expressions that should be evaluated without insertion into
the resulting string. 
\item
You may define or omit any combination of the
three. 
\item
For example, to perform \verb|Mustache.js| style templating:

\begin{verbatim}
_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};

var template = _.template("Hello {{ name }}!");
template({name: "Mustache"});
=> "Hello Mustache!"
\end{verbatim}
\item \verb|escape|:
\begin{verbatim}
> uu.templateSettings.escape = /\{\{-(.*?)\}\}/g
/\{\{-(.*?)\}\}/g
> compiled = uu.template("Escaped: {{- value }}\nNot escaped: {{ value }}")
{ [Function]
  source: 'function(obj){\nvar __t,__p=\'\',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,\'\');};\nwith(obj||{}){\n__p+=\'Escaped: \'+\n((__t=( value ))==null?\'\':_.escape(__t))+\n\'\\nNot escaped: {{ value }}\';\n}\nreturn __p;\n}' }
> compiled({value: 'Hello, <b>world!</b>'})
'Escaped: Hello, &lt;b&gt;world!&lt;/b&gt;\nNot escaped: {{ value }}'
\end{verbatim}
\item Another example:
\begin{verbatim}
> uu.templateSettings = {
.....       interpolate: /\<\@\=(.+?)\@\>/gim,
.....       evaluate: /\<\@(.+?)\@\>/gim
.....   }
{ interpolate: /\<\@\=(.+?)\@\>/gim,
  evaluate: /\<\@(.+?)\@\>/gim }
> s = " <@ _.each([0,1,2,3,4], function(i) { @>  <p><@= i @></p> <@ }); @>"
' <@ _.each([0,1,2,3,4], function(i) { @>  <p><@= i @></p> <@ }); @>'
> uu.template(s,{})
'   <p>0</p>   <p>1</p>   <p>2</p>   <p>3</p>   <p>4</p> '
\end{verbatim}
\end{itemize}
By default, template places the values from your data in the local scope
via the \verb|with| statement. The \verb'with' statement adds the given
object to the head of this scope chain during the evaluation of its
statement body:
\begin{verbatim}
> with (Math) {
... s = PI*2;
... }
6.283185307179586
> z = { x : 1, y : 2 }
{ x: 1, y: 2 }
> with (z) {
... console.log(y);
... }
2
undefined
\end{verbatim}

However, you can specify a single variable name
with the variable \verb|setting|. This improves the speed at
which a template is able to render.

\begin{verbatim}
_.template("Using 'with': <%= data.answer %>", {answer: 'no'}, {variable: 'data'});
=> "Using 'with': no"
\end{verbatim}


\item
\htmladdnormallink{JSFIDDLE: underscore templates}{http://jsfiddle.net/casiano/LS384/}
\item 
\htmladdnormallink{Stackoverflow::how to use Underscore template}{http://stackoverflow.com/questions/4778881/how-to-use-underscore-js-as-a-template-engine}

\end{itemize}


