
<H1><A NAME="SECTION041180000000000000000">
Modulos</A>
</H1>
<tex2html_file>#./chapter1/modulos.tex#

<H2><A NAME="SECTION041181000000000000000">
Introducción</A>
</H2>

<P>
<PRE><tex2html_verbatim_mark>verbatim75#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim76#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim77#</PRE>

<P>
El módulo <tex2html_verb_mark>14<tex2html_verb_mark> exporta las funciones <tex2html_verb_mark>15<tex2html_verb_mark> 
y <tex2html_verb_mark>16<tex2html_verb_mark>. Para exportar un objeto lo añadimos 
al objeto expecial <tex2html_verb_mark>17<tex2html_verb_mark>.

<P>
Las variables locales al módulo serán privadas.
En este ejemplo la variable <tex2html_verb_mark>18<tex2html_verb_mark> es privada a <tex2html_verb_mark>19<tex2html_verb_mark>.

<P>
<PRE><tex2html_verbatim_mark>verbatim78#</PRE>

<P>

<H2><A NAME="SECTION041182000000000000000">
Ciclos</A>
</H2>

<P>
<PRE><tex2html_verbatim_mark>verbatim79#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim80#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim81#</PRE>
When <tex2html_verb_mark>20<tex2html_verb_mark> loads <tex2html_verb_mark>21<tex2html_verb_mark>, then <tex2html_verb_mark>22<tex2html_verb_mark> in turn loads
<tex2html_verb_mark>23<tex2html_verb_mark>. At that point, <tex2html_verb_mark>24<tex2html_verb_mark> tries to load <tex2html_verb_mark>25<tex2html_verb_mark>. In
order to prevent an infinite loop an unfinished copy of the <tex2html_verb_mark>26<tex2html_verb_mark>
exports object is returned to the <tex2html_verb_mark>27<tex2html_verb_mark> module. <tex2html_verb_mark>28<tex2html_verb_mark> then
finishes loading, and its exports object is provided to the <tex2html_verb_mark>29<tex2html_verb_mark>
module.

<P>
By the time <tex2html_verb_mark>30<tex2html_verb_mark> has loaded both modules, they're both finished. The
output of this program would thus be:

<P>
<PRE><tex2html_verbatim_mark>verbatim82#</PRE>

<P>

<H2><A NAME="SECTION041183000000000000000">
Especificación de Ficheros Conteniendo Módulos</A>
</H2>

<P>

<OL>
<LI>If the exact filename is not found, then node will attempt to
load the required filename with the added extension of <tex2html_verb_mark>31<tex2html_verb_mark>,
<tex2html_verb_mark>32<tex2html_verb_mark>, and then <tex2html_verb_mark>33<tex2html_verb_mark>.

<P>
</LI>
<LI><tex2html_verb_mark>34<tex2html_verb_mark> files are interpreted as JavaScript text files, and <tex2html_verb_mark>35<tex2html_verb_mark> files are parsed as JSON text files. <tex2html_verb_mark>36<tex2html_verb_mark> files are interpreted as compiled addon modules 

<P>
</LI>
<LI>A module prefixed with <tex2html_verb_mark>37<tex2html_verb_mark> is an absolute path to the file. For example,
<tex2html_verb_mark>38<tex2html_verb_mark> will load the file at <tex2html_verb_mark>39<tex2html_verb_mark>.

<P>
</LI>
<LI>A module prefixed with <tex2html_verb_mark>40<tex2html_verb_mark> is relative to the file calling require(). 

<P>
</LI>
<LI>Without a leading verb|'/'| or <tex2html_verb_mark>41<tex2html_verb_mark> to indicate a file, the module is either a 
<A NAME="1511"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textit">core module</SPAN> or is loaded from a <tex2html_verb_mark>42<tex2html_verb_mark> folder.

<P>
</LI>
<LI>If the given path does not exist, <tex2html_verb_mark>43<tex2html_verb_mark> 
will throw an Error with its code property set to <tex2html_verb_mark>44<tex2html_verb_mark>.
</LI>
</OL>

<P>

<H2><A NAME="SECTION041184000000000000000">
Carga desde Carpetas <TT>node_modules</TT></A>
</H2>

<P>

<OL>
<LI>If the module identifier passed to <tex2html_verb_mark>45<tex2html_verb_mark> is not a native module,
and does not begin with <tex2html_verb_mark>46<tex2html_verb_mark>, <tex2html_verb_mark>47<tex2html_verb_mark>, or <tex2html_verb_mark>48<tex2html_verb_mark>, then node starts at the
parent directory of the current module, and adds <tex2html_verb_mark>49<tex2html_verb_mark>, and
attempts to load the module from that location.

<P>
</LI>
<LI>If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.
</LI>
</OL>

<P>
For example, if the file at <tex2html_verb_mark>50<tex2html_verb_mark> called
require(<tex2html_verb_mark>51<tex2html_verb_mark>), then node would look in the following locations,
in this order:

<P>
<PRE><tex2html_verbatim_mark>verbatim83#</PRE>

<P>
This allows programs to localize their dependencies, so that they do not clash.

<P>

<H2><A NAME="SECTION041185000000000000000">
Las Carpetas Usadas Como Módulos</A>
</H2>
It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library. 

<P>
There
are a few ways in which a folder may be passed to <tex2html_verb_mark>52<tex2html_verb_mark> as an
argument.

<P>

<OL>
<LI>The first is to create a <tex2html_verb_mark>53<tex2html_verb_mark> file in the root of the
folder, which specifies a <tex2html_verb_mark>54<tex2html_verb_mark> module. 
An example <tex2html_verb_mark>55<tex2html_verb_mark> file
might look like this:

<P>
<PRE><tex2html_verbatim_mark>verbatim84#</PRE>

<P>
If this was in a folder at 
<tex2html_verb_mark>56<tex2html_verb_mark>, then <tex2html_verb_mark>57<tex2html_verb_mark> would attempt
to load <tex2html_verb_mark>58<tex2html_verb_mark>.

<P>
This is the extent of Node's awareness of <tex2html_verb_mark>59<tex2html_verb_mark> files.

<P>
</LI>
<LI>If there is no <tex2html_verb_mark>60<tex2html_verb_mark> 
file present in the directory, then node will
attempt to load an 
<tex2html_verb_mark>61<tex2html_verb_mark> or
<tex2html_verb_mark>62<tex2html_verb_mark> 
file out of that directory. 

<P>
For
example, if there was no 
<tex2html_verb_mark>63<tex2html_verb_mark> file in the above example, then
<tex2html_verb_mark>64<tex2html_verb_mark> would attempt to load:

<P>
<PRE><tex2html_verbatim_mark>verbatim85#</PRE>

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION041186000000000000000">
Caching</A>
</H2>

<P>

<OL>
<LI>Modules are cached after the first time they are loaded. This means
(among other things) that every call to <tex2html_verb_mark>65<tex2html_verb_mark> will get exactly
the same object returned, if it would resolve to the same file.

<P>
</LI>
<LI>Multiple calls to <tex2html_verb_mark>66<tex2html_verb_mark> may not cause the module code
to be executed multiple times. This is an important feature. With it,
<A NAME="1513"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textit">partially done</SPAN> objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

<P>
</LI>
<LI>If you want to have a module execute code multiple times, then export
a function, and call that function.

<P>
</LI>
<LI>Modules are cached based on their <#1473#><B>resolved filename</B><#1473#>. Since modules may
resolve to a different filename based on the location of the calling
module (loading from <tex2html_verb_mark>67<tex2html_verb_mark>), it is not a guarantee that
<tex2html_verb_mark>68<tex2html_verb_mark> will always return the exact same object, if it would
resolve to different files.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION041187000000000000000">
El Objeto <TT>module</TT> y <TT>module.exports</TT></A>
</H2>

<P>

<OL>
<LI>In each module, the <tex2html_verb_mark>69<tex2html_verb_mark> free variable is a reference to the object
representing the current module. 

<P>
</LI>
<LI>In particular <tex2html_verb_mark>70<tex2html_verb_mark> is the
same as the exports object. 

<P>
</LI>
<LI><tex2html_verb_mark>71<tex2html_verb_mark> isn't actually a global but rather
local to each module.

<P>
</LI>
<LI>The exports object is created by the <tex2html_verb_mark>72<tex2html_verb_mark> system. 
Sometimes this is not acceptable, 
many want their module to be an instance of some class. 
To do this assign the desired export object to <tex2html_verb_mark>73<tex2html_verb_mark>. 

<P>

<UL>
<LI><PRE><tex2html_verbatim_mark>verbatim86#</PRE>

<P>
</LI>
<LI><PRE><tex2html_verbatim_mark>verbatim87#</PRE>
</LI>
<LI><PRE><tex2html_verbatim_mark>verbatim88#</PRE>
</LI>
</UL>
La asignación a <tex2html_verb_mark>74<tex2html_verb_mark> debe hacerse inmediatamente. 
No puede hacerse en un callback.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION041188000000000000000">
Algoritmo de Búsqueda Ejecutado por <TT>require</TT></A>
</H2>

<P>

<H4><A NAME="SECTION041188010000000000000">
require(X) from module at path Y</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<OL>
<LI>If X is a core module,

<OL>
<LI>return the core module
</LI>
<LI>STOP
</LI>
</OL>
</LI>
<LI>If X begins with './' or '/' or '../'

<OL>
<LI><tex2html_verb_mark>75<tex2html_verb_mark>
</LI>
<LI><tex2html_verb_mark>76<tex2html_verb_mark>
</LI>
</OL>
</LI>
<LI><tex2html_verb_mark>77<tex2html_verb_mark>
</LI>
<LI>THROW ;SPMquot;not found;SPMquot;
</LI>
</OL>

<P>

<H4><A NAME="SECTION041188020000000000000">
LOAD_AS_FILE(X)</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<OL>
<LI>If X is a file, load X as JavaScript text.  STOP
</LI>
<LI>If X.js is a file, load X.js as JavaScript text.  STOP
</LI>
<LI>If X.node is a file, load X.node as binary addon.  STOP
</LI>
</OL>

<P>

<H4><A NAME="SECTION041188030000000000000">
LOAD_AS_DIRECTORY(X)</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<OL>
<LI>If X/package.json is a file,
   a. Parse X/package.json, and look for ;SPMquot;main;SPMquot; field.
   b. let M = X + (json main field)
   c. <tex2html_verb_mark>78<tex2html_verb_mark>
</LI>
<LI>If X/index.js is a file, load X/index.js as JavaScript text.  STOP
</LI>
<LI>If X/index.node is a file, load X/index.node as binary addon.  STOP
</LI>
</OL>

<P>

<H4><A NAME="SECTION041188040000000000000">
LOAD_NODE_MODULES(X, START)</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<OL>
<LI>let <tex2html_verb_mark>79<tex2html_verb_mark>
</LI>
<LI>for each DIR in DIRS:
   a. <tex2html_verb_mark>80<tex2html_verb_mark>
   b. <tex2html_verb_mark>81<tex2html_verb_mark>
</LI>
</OL>

<P>

<H4><A NAME="SECTION041188050000000000000">
NODE_MODULES_PATHS(START)</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<OL>
<LI>let PARTS = path split(START)
</LI>
<LI>let ROOT = index of first instance of ;SPMquot;node_modules;SPMquot; in PARTS, or 0
</LI>
<LI>let I = count of PARTS - 1
</LI>
<LI>let DIRS = []
</LI>
<LI>while I ;SPMgt; ROOT,
   a. if PARTS[I] = ;SPMquot;node_modules;SPMquot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + ;SPMquot;node_modules;SPMquot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
</LI>
<LI>return DIRS
</LI>
</OL>
<tex2html_endfile>#./chapter1/modulos.tex#

<P>
