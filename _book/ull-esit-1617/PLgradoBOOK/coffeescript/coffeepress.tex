Literally taken from
James carr blog and updated 2015:

\htmladdnormallink{http://blog.james-carr.org/2012/01/16/blog-rolling-with-mongodb-node-js-and-coffeescript/}{http://blog.james-carr.org/2012/01/16/blog-rolling-with-mongodb-node-js-and-coffeescript/}

\section{Getting Started}
This is a tutorial on using 
\begin{itemize}
\item
node.js, 
\item
coffeescript and 
\item
mongodb 
\end{itemize}
to build a simple blog. 

Quite obviously, you’re going to need node.js and mongodb installed. I
recommend downloading and installing from the node.js website and
following the instructions. 

I will note that this tutorial covers 
\begin{verbatim}
[~/local/src/coffee]$ express --version
4.11.2
\end{verbatim}
so
if you come across this post a year from now (2015) the API might have changed
significantly since then. 

You will also need mongodb installed.

\begin{itemize}
\item
If you use Ubuntu (or some other Debian derivative)
you should consider installing from their apt repository. 

\item
OSX? No problem,
you can also install it via homebrew.
\end{itemize}


Finally, since we’ll be using coffeescript for this tutorial,
run 
\begin{verbatim}
[~/local/src/coffee]$ npm install -g coffee-script
npm http GET https://registry.npmjs.org/coffee-script
npm http 200 https://registry.npmjs.org/coffee-script
/usr/local/bin/coffee -> /usr/local/lib/node_modules/coffee-script/bin/coffee
/usr/local/bin/cake -> /usr/local/lib/node_modules/coffee-script/bin/cake
coffee-script@1.9.1 /usr/local/lib/node_modules/coffee-script
[~/local/src/coffee]$ coffee --version
CoffeeScript version 1.9.1
\end{verbatim}
(you might need to sudo) to install
coffeescript. 

Run coffee from the commandline to access the coffeescript
REPL. If all works well, install these additional packages listed below
via npm that we’ll be using throughout the tutorial.

\begin{itemize}
\item
express
\item
mocha. 
Véase la sección {\it Pruebas: Mocha y Chai}
\ref{parrafo:mochaychai}
\end{itemize}

\parrafo{Express generator}

Now let’s bootstrap our project structure. Type 
\begin{verbatim}
express coffeepress 
\end{verbatim}
to generate a skeleton express project structure. 
\begin{verbatim}
[~/local/src/coffee]$ express coffeepress

   create : coffeepress
   create : coffeepress/package.json
   create : coffeepress/app.js
   create : coffeepress/public
   create : coffeepress/public/images
   create : coffeepress/public/javascripts
   create : coffeepress/public/stylesheets
   create : coffeepress/public/stylesheets/style.css
   create : coffeepress/routes
   create : coffeepress/routes/index.js
   create : coffeepress/routes/users.js
   create : coffeepress/views
   create : coffeepress/views/index.jade
   create : coffeepress/views/layout.jade
   create : coffeepress/views/error.jade
   create : coffeepress/bin
   create : coffeepress/bin/www

   install dependencies:
     $ cd coffeepress && npm install

   run the app:
     $ DEBUG=coffeepress:* ./bin/www
\end{verbatim}

You should see output similar to the following:
\begin{verbatim}
[~/local/src/coffee]$ cd coffeepress
[~/local/src/coffee/coffeepress]$ tree
.
|--- app.js
|--- bin
|   `-- www
|--- package.json
|--- public
|   |--- images
|   |--- javascripts
|   `-- stylesheets
|       `-- style.css
|--- routes
|   |--- index.js
|   `-- users.js
`-- views
    |--- error.jade
    |--- index.jade
    `-- layout.jade

7 directories, 9 files

\end{verbatim}

This is called \cei{Scaffolding}.

The idea is simple: most projects
require a certain amount of so-called \red{boilerplate} code, and who
wants to recreate that code every time you begin a new project? A simple
way is to create a rough skeleton of a project, and every time you need
a new project, you just copy this skeleton, or template.

Express has taken a page from Ruby on Rails and provided the \verb|express|
utility  to
generate scaffolding to start your Express project.

\begin{verbatim}
[~/src/coffee]$ express --help

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
    -V, --version       output the version number
    -e, --ejs           add ejs engine support (defaults to jade)
        --hbs           add handlebars engine support
    -H, --hogan         add hogan.js engine support
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory
\end{verbatim}

Boilerplate is also useful for the actual HTML that will be delivered to the client. See 
for example  
\htmladdnormallink{https://html5boilerplate.com/}{https://html5boilerplate.com/}.

\parrafo{The Structure}

There are three folders in the root:
\begin{itemize}
\item public: This folder contains the static assets.
Express relies on a middleware to handle static files.
\begin{verbatim}
app.use(express.static(path.join(__dirname, 'public')));
\end{verbatim}
The static middleware allows you to designate one or more directories
as containing static resources that are simply to be delivered to the
client without any special handling. This is where you would put things
like images, CSS files, and client-side JavaScript files.
\begin{verbatim}
|--- public
|   |--- images
|   |--- javascripts
|   `-- stylesheets
|       `-- style.css
\end{verbatim}
\item views: This folder is populated with Jade templates by default
\begin{verbatim}
| 
`-- views
    |--- error.jade
    |--- index.jade
    `-- layout.jade
\end{verbatim}
Where a view differs from a static resource (like an image or CSS file)
is that a view doesn’t necessarily have to be static: the HTML can be
constructed on the fly to provide a customized page for each request.

Express supports many different view engines that provide different levels of abstraction. 
Express gives some preference to a view engine called Jade 
\item routes: This folder includes the routes (these are the equivalent controllers)
\begin{verbatim}
|
|--- routes
|   |--- index.js
|   `-- users.js
\end{verbatim}
\end{itemize}
Apart from these existing folders and the models folder, which we need to create ourselves, we might also create folders for 
\begin{itemize}
\item
tests, 
\item
logs, or 
\item
configuration. 
\end{itemize}

The best thing about this structure is that
it's easy to get started with and is known to most developers.


\parrafo{package.json}

The \verb|package.json| file is automatically populated with 
\begin{itemize}
\item the name of the application, 
\item the dependencies, 
\item the private attribute: If you set \verb|"private": true| in your 
\verb|package.json|, then \verb|npm| will refuse to publish it.  
This is a way to prevent accidental publication of private repositories.
\item the starting script. 
\end{itemize}
\begin{verbatim}
[/tmp/coffeepress]$ cat package.json 
{
  "name": "coffeepress",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "body-parser": "~1.10.2",
    "cookie-parser": "~1.3.3",
    "debug": "~2.1.1",
    "express": "~4.11.1",
    "jade": "~1.9.1",
    "morgan": "~1.5.1",
    "serve-favicon": "~2.2.0"
  }
\end{verbatim}
\begin{itemize}
\item
The module
\htmladdnormallink{body-parser}{https://github.com/expressjs/body-parser}
 is a piece of express middleware that·
reads a form's input and stores it as a javascript
object accessible through \verb|req.body|·

\item
The module
\htmladdnormallink{cookie-parser}{https://github.com/expressjs/cookie-parser}
parses the Cookie header and populate \verb|req.cookies| 
with an object keyed by the cookie names. 

%Optionally you may enable signed cookie support by passing a secret string, which assigns req.secret so it may be used by other middleware.
\item
The 
\htmladdnormallink{morgan}{https://github.com/expressjs/morgan}
module provides a HTTP request logger middleware.
\item
The
\htmladdnormallink{serve-favicon}{https://github.com/expressjs/serve-favicon}
module provides a middleware for serving a favicon
\end{itemize}

The starting script is \verb|bin/www| which  loads \verb|app.js| 
\begin{verbatim}
[/tmp/coffeepress]$ cat bin/www 
#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('coffeepress:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
\end{verbatim}

\parrafo{app.js}

\verb|app.js| loads the middleware, assigns the route handlers, and starts the server. 

\begin{verbatim}
[/tmp/coffeepress]$ cat app.js
var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var routes = require('./routes/index');
var users = require('./routes/users');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');

// uncomment after placing your favicon in /public
//app.use(favicon(__dirname + '/public/favicon.ico'));
app.use(logger('dev'));
app.use(bodyParser.json()); // Returns middleware that only parses json
/* 
URLs can only be sent over the Internet using the ASCII character-set.
Since URLs often contain characters outside the ASCII set, 
the URL has to be converted into a valid ASCII format.
*/
app.use(bodyParser.urlencoded({ extended: false }));
   //The "extended" syntax allows for rich objects and arrays to be encoded 

app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', routes);
app.use('/users', users);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
    app.use(function(err, req, res, next) {
        res.status(err.status || 500);
        res.render('error', {
            message: err.message,
            error: err
        });
    });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
        message: err.message,
        error: {}
    });
});


module.exports = app;
\end{verbatim}

\parrafo{El método {\tt app.use}}
\begin{itemize}
\item
El método
\htmladdnormallink{app.use}{http://expressjs.com/4x/api.html\#app.use}
\verb|app.use([path,] function [, function...])|
mounts the middleware function(s) at the path. 
If path is not specified, it defaults to \verb|"/"|.

Asi pues 
\begin{verbatim}
var routes = require('./routes/index');
var users = require('./routes/users');

....

app.use('/', routes);
app.use('/users', users);
\end{verbatim}
las rutas especificadas en \verb|routes| quedan montadas en la raiz 
y las rutas especificadas en \verb|users| quedan montadas en \verb|users/...|
\end{itemize}
mientras que este middleware queda asociado con la raiz:
\begin{verbatim}
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    next(err);
});
\end{verbatim}

\parrafo{Middleware}

Middleware is a way to encapsulate functionality: 
specifically, functionality that operates on an HTTP request to your application. 

Practically, a middleware is simply a function that
takes three arguments: 
\begin{itemize}
\item
a request object, 
\item
a response object, and 
\item
a \red{next} function
\end{itemize}

\begin{itemize}
\item
If you don’t call \verb|next()|, the pipeline will be terminated, and
no more route handlers or middleware will be processed. 
\item
If you don’t
call \verb|next()|, you should send a response to the client 
(\verb|res.send|, \verb|res.json|, \verb|res.render|, etc.); 
if you don’t, the client will hang and eventually time out.
\end{itemize}

\parrafo{Las Rutas / Routing}

\red{Routing is the mechanism by which requests 
(as specified by a URL and HTTP method) are 
routed to the code that handles them}. 


\parrafo{Running}

Instalamos las dependencias:
\begin{verbatim}
[~/src/coffee/coffeepress]$ npm install
npm http GET https://registry.npmjs.org/jade
....
\end{verbatim}
y ejecutamos:
\begin{verbatim}
~/src/coffee/coffeepress]$ DEBUG=coffeepress:* ./bin/www
  coffeepress:server Listening on port 3000 +0ms
\end{verbatim}
Then load \verb|http://localhost:3000/| in your browser to access the app.

\parrafo{El módulo debug}

El generador de Express nos produjo el fichero \verb|bin/www|.
Este programa hace uso del módulo 
\htmladdnormallink{debug}{https://github.com/visionmedia/debug}
que es el que nos permite emitir el mensaje de \verb|Listening on|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ grep debug bin/www.coffee 
debug = require('debug')('coffeepress:server')
  debug 'Listening on ' + bind
\end{verbatim}
La primera línea \verb|debug = require('debug')('coffeepress:server')| carga la librería
y establece el nombre de \verb|www.coffee| a efectos de depuración como
\verb'coffeepress:server'.

The \verb|DEBUG| environment variable must be set to a list of file names
separated by commas or spaces. It is then used to enable these 
\verb|debug('...')| messages. 

Por ejemplo:
\begin{verbatim}
DEBUG=coffeepress:* bin/www
\end{verbatim}
dice que se activan los mensajes de debug en cualquier fichero con 
prefijo de nombre \verb|coffeepress|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Porting to Coffeescript}
At this point, let’s port our backend to coffeescript. 

You can install \verb|js2coffee| via npm. So run the following:

\begin{verbatim}
npm -g install js2coffee
\end{verbatim}
\begin{verbatim}
[~/src/coffee/coffeepress]$ js2coffee --version
2.0.3
[~/src/coffee/coffeepress]$ js2coffee --help
Usage:
    js2coffee FILES [options]

Options:
        --ast          prints the AST (for debugging)
    -V, --verbose      prints more AST stuff (used with --ast)
    -i, --indent N     indent by N spaces (default: 2)
    -i, --indent tab   indent by tabs

Modes:
        --compat       compatibility mode *
                       (implement workarounds to keep full compatibility)

Other options:
    -h, --help         print usage information
    -v, --version      show version info and exit
\end{verbatim}

Vamos a convertir nuestros ficheros \verb|*.js| a coffee:
\begin{verbatim}
~/src/coffee/coffeepress]$ ls *js **/*js bin/*
app.js          bin/www         routes/index.js routes/users.js
[~/src/coffee/coffeepress]$ js2coffee app.js > app.coffee
[~/src/coffee/coffeepress]$ js2coffee routes/index.js > routes/index.coffee
[~/src/coffee/coffeepress]$ js2coffee routes/users.js > routes/users.coffee
\end{verbatim}
Cuando probamos con el main obtenemos un error:
\begin{verbatim}
[~/src/coffee/coffeepress]$ js2coffee bin/www > bin/www.coffee
bin/www:1:0: [error] Unexpected token ILLEGAL
\end{verbatim}
El error es debido a la primera línea para la bash con la 
definición del intérprete:
\begin{verbatim}
[/tmp/coffeepress]$ cat -n bin/www 
 1  #!/usr/bin/env node
 2  
 3  /**
 4   * Module dependencies.
 5   */
 6  
 7  var app = require('../app');
 8  var debug = require('debug')('coffeepress:server');
 9  var http = require('http');
10  
11  /**
12   * Get port from environment and store in Express.
13   */
14  
15  var port = normalizePort(process.env.PORT || '3000');
16  app.set('port', port);
17  
18  /**
19   * Create HTTP server.
20   */
21  
22  var server = http.createServer(app);
23  
24  /**
25   * Listen on provided port, on all network interfaces.
26   */
27  
28  server.listen(port);
29  server.on('error', onError);
30  server.on('listening', onListening);
31  
32  /**
33   * Normalize a port into a number, string, or false.
34   */
35  
36  function normalizePort(val) {
37    var port = parseInt(val, 10);
38  
39    if (isNaN(port)) {
40      // named pipe
41      return val;
42    }
43  
44    if (port >= 0) {
45      // port number
46      return port;
47    }
48  
49    return false;
50  }
51  
52  /**
53   * Event listener for HTTP server "error" event.
54   */
55  
56  function onError(error) {
57    if (error.syscall !== 'listen') {
58      throw error;
59    }
60  
61    var bind = typeof port === 'string'
62      ? 'Pipe ' + port
63      : 'Port ' + port
64  
65    // handle specific listen errors with friendly messages
66    switch (error.code) {
67      case 'EACCES':
68        console.error(bind + ' requires elevated privileges');
69        process.exit(1);
70        break;
71      case 'EADDRINUSE':
72        console.error(bind + ' is already in use');
73        process.exit(1);
74        break;
75      default:
76        throw error;
77    }
78  }
79  
80  /**
81   * Event listener for HTTP server "listening" event.
82   */
83  
84  function onListening() {
85    var addr = server.address();
86    var bind = typeof addr === 'string'
87      ? 'pipe ' + addr
88      : 'port ' + addr.port;
89    debug('Listening on ' + bind);
90  }
\end{verbatim}

Obsérvense las líneas:
\begin{verbatim}
29  server.on('error', onError);
30  server.on('listening', onListening);
\end{verbatim}

Many objects in Node emit events: 
\begin{itemize}
\item
a \verb|net.Server| emits an event each time a peer connects to it, 
\item
a \verb|fs.readStream| emits an event when the file is opened. 
\end{itemize}
All objects which emit events are instances of 
\htmladdnormallink{events.EventEmitter }{https://nodejs.org/api/events.html}.

Functions can then be attached to objects, to be executed when an event is
emitted. These functions are called \cei{listeners}. 


Volviendo a nuestra traducción de \verb|bin/www|, 
si comentamos la primera línea no se producen errores pero si 
que nos sale un warning:
\begin{verbatim}
~/src/coffee/coffeepress]$ js2coffee bin/www > bin/www.coffee
bin/www:37:6: [warning] Variable shadowing ('port') is not fully supported in CoffeeScript
\end{verbatim}
Si cambiamos todas las apariciones de la variable 
\verb|port|  por p. ej. \verb|lport|
en la definición de la función \verb|normalizePort| el warning desaparece:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ js2coffee bin/www > bin/www.coffee 
[~/src/coffee/coffeepress(master)]$ 
\end{verbatim}
pero cuando ejecutamos el servidor obtenemos un nuevo error:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ coffee bin/www.coffee 
TypeError: undefined is not a function
  at Object.<anonymous> (/Users/casiano/local/src/coffee/coffeepress/bin/www.coffee:15:8)
  at Object.<anonymous> (/Users/casiano/local/src/coffee/coffeepress/bin/www.coffee:3:1)
  at Module._compile (module.js:456:26)
\end{verbatim}

Movemos la función \verb|normalizePort| antes de la definición de \verb|port| y se arregla el asunto.

\parrafo{Ejecución del Servidor}

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ coffee bin/www.coffee 
GET / 304 298.379 ms - -
GET /stylesheets/style.css 304 6.048 ms - -
\end{verbatim}
Otra forma de ejecutar el servidor es instalar \verb|nodemon|
\begin{verbatim}
npm install -g nodemon
\end{verbatim}
y ejecutarlo así:
\begin{verbatim}
~/src/coffee/coffeepress(master)]$ nodemon bin/www.coffee
6 Apr 14:12:01 - [nodemon] v1.3.7
6 Apr 14:12:01 - [nodemon] to restart at any time, enter `rs`
6 Apr 14:12:01 - [nodemon] watching: *.*
6 Apr 14:12:01 - [nodemon] starting `coffee bin/www.coffee`
\end{verbatim}
\verb|Nodemon| (see
\htmladdnormallink{http://nodemon.io/}{http://nodemon.io/}
)
is for use during development of a node.js based application.

\verb|nodemon| will watch the files in the directory in which \verb|nodemon| was started, and if any files change, \verb|nodemon| will automatically restart your node application.

\verb|nodemon| does not require any changes to your code or method of
development. \verb|nodemon| simply wraps your node application and keeps an eye
on any files that have changed. Remember that \verb|nodemon| is a replacement
wrapper for node, think of it as replacing the word "node" on the command
line when you run your script.

Otra forma de ejecutar programas escritos en coffee 
consiste en usar la posibilidad que existe de cargar
el coffee desde un programa JavaScript usando 
\verb|coffee-script/register|. Modificamos \verb|bin/www|
como sigue:
\begin{verbatim}
[~/src/coffee/coffeepress.bak(master)]$ cat bin/www
#!/usr/bin/env node
// Note the new way of requesting CoffeeScript since 1.7.x
require('coffee-script/register');
// This bootstraps your server main file
require('./www.coffee');
\end{verbatim}
y ahora ejecutamos:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ node bin/www
GET / 304 334.240 ms - -
GET /stylesheets/style.css 304 7.269 ms - -
\end{verbatim}


\section{Pruebas}

\parrafo{Mocha, Chai y Expect: instalando las dependencias}
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ npm install --save-dev mocha expect chai
\end{verbatim}

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat package.json 
{
  "name": "coffeepress",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "body-parser": "~1.10.2",
    "cookie-parser": "~1.3.3",
    "debug": "~2.1.1",
    "express": "~4.11.1",
    "jade": "~1.9.1",
    "morgan": "~1.5.1",
    "serve-favicon": "~2.2.0"
  },
  "devDependencies": {
    "expect": "~1.6.0",
    "chai": "~2.2.0",
    "mocha": "~2.2.1"
  }
}
\end{verbatim}

\parrafo{Una Prueba Sencilla}
Empecemos con una prueba sencilla.
Creamos el directorio \verb|test| para las pruebas:

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mkdir test
\end{verbatim}
y creamos una primera prueba:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat test/example.coffee
chai     = require 'chai'
expect   = chai.expect

describe "feature", ->
  it "should add two numbers", ->
    expect(2+2).to.equal(4)
\end{verbatim}
para ejecutarla debemos hacer:
\begin{verbatim}
$ mocha --compilers coffee:coffee-script/register -R spec


  feature
    ok: should add two numbers 


  1 passing (7ms)
\end{verbatim}

\begin{itemize}
\item
\verb|mocha| tiene una opción:
\begin{verbatim}
--compilers <ext>:<module>,...  
\end{verbatim}
Que indica que debemos usar el \verb|module|(s) para compilar los ficheros
con extensión \verb|ext|.
\item
\htmladdnormallink{How to pass compiler options to mocha?}{http://stackoverflow.com/questions/20049790/how-to-pass-compiler-options-to-mocha}:

\begin{itemize}
\item
Write a script which activates the compiler with your options, 
then use mocha's \verb|--require| option to activate your registration script.
\end{itemize}
\item
La opción \verb|-R| o bien \verb|--reporter| va seguida de un \verb|<name>|
y especifica el \red{reporter} a utilizar.
\item
This flag \verb|-R| may also be used to utilize third-party reporters. For example if you 
\verb|npm install mocha-lcov-reporter| 
you may then do \verb|--reporter mocha-lcov-reporter|.
\item
La  opción \verb|--reporters| nos da la lista de \verb|reporters| que 
podemos utilizar:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee]$ mocha --reporters

    dot - dot matrix
    doc - html documentation
    spec - hierarchical spec list
    json - single json object
    progress - progress bar
    list - spec-style listing
    tap - test-anything-protocol
    landing - unicode landing strip
    xunit - xunit reporter
    html-cov - HTML test coverage
    json-cov - JSON test coverage
    min - minimal reporter (great with --watch)
    json-stream - newline delimited json events
    markdown - markdown documentation (github flavour)
    nyan - nyan cat!
\end{verbatim}
\item
\end{itemize}

Vamos ahora a hacer una prueba sobre nuestro código. 
Nuestro objetivo es hacer que nuestra aplicación funcione como un pequeño blog.

\parrafo{¿Cómo lo vamos a hacer?}

Reescribiremos \verb|routes/index.coffee| de manera que por cada ruta URL de la 
aplicación el objeto \verb|routes| exportado por \verb|routes/index.coffee| disponga
de un método que procesa esa ruta. Así:
\begin{itemize}
\item Así un \verb|get| a la ruta \verb|/| será procesada por el método \verb|index|
\item Un \verb|get| a la ruta \verb|/post/new| será procesada por un método \verb|newPost|, 
\item Un \verb|post| a la ruta \verb|/post/new| será procesada por un método \verb|addPost|, 
\item etc.
\end{itemize}
Esta correspondencia entre métodos HHTP+rutas y métodos del objeto \verb|routes| 
se establece en 
el cuerpo principal de la aplicación:
\begin{verbatim}
[~/javascript/expressjs/coffee-mongo(master)]$ sed -ne '3p' app.coffee 
routes   = require "./routes"
[~/javascript/expressjs/coffee-mongo(master)]$ sed -ne '24,27p' app.coffee 
app.get "/", routes.index
app.get "/post/new", routes.newPost
app.post "/post/new", routes.addPost
app.get "/post/:id", routes.viewPost
\end{verbatim}

\parrafo{Should display index with posts: red}
Empezaremos describiendo como debe ser la ruta \verb|index| del objeto
\verb|routes|.

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat test/routes-test.coffee 
chai     = require 'chai'
expect   = chai.expect
routes = require "../routes/index"

describe "routes", ->
  req = {}
  res = {}
  describe "index", ->
    it "should display index with posts", ->
      res.render = (view, vars) ->
          expect(view).equal "index"
          expect(vars.title).equal "My Coffeepress Blog"
      routes.index(req, res)
\end{verbatim}

\begin{itemize}
\item
Here we fake our requests and response in order to capture what is
passed into the response. 
\item
We fake the render method and verify that our
rendered view is \verb|index| and that the variable \verb|title| 
is equal to what we expect to be passed in. 
\item
\htmladdnormallink{Response objects}{http://expressjs.com/api.html\#res}
have a method \verb|res.render(view [, locals] [, callback])|
which renders the file whose name is given by \verb|view| and sends the rendered HTML string to the client. 

Optional parameters of \verb|res.render|:
  \begin{itemize}

  \item \verb|locals|, an object whose properties define local variables for the view.
  \item \verb|callback|, a callback function. 

  If provided, the method returns both the possible error and rendered string, but does not perform an automated response. 

  When an error occurs, the method invokes \verb|next(err)| 
  internally.
\begin{verbatim}
// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function(err, html) {
  res.send(html);
});
\end{verbatim}
  \end{itemize}
\end{itemize}
La ruta \verb|index| que fué generada por Express contiene el siguiente código:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')
router = express.Router()

### GET home page. ###

router.get '/', (req, res, next) ->
  res.render 'index', title: 'Express'
  return
module.exports = router
\end{verbatim}
como se ve, lo que estamos haciendo en la prueba es sobreescribir el método \verb|render| 
del objeto \verb|res| por 
un falso \verb|render| que hace las dos pruebas:
\begin{verbatim}
routes = require "../routes/index"
...
      res.render = (view, vars) ->
          expect(view).equal "index"
          expect(vars.title).equal "My Coffeepress Blog"
      routes.index(req, res)
\end{verbatim}

Run the tests:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec


  routes
    index
      1) should display index with posts


  0 passing (7ms)
  1 failing

  1) routes index should display index with posts:
     TypeError: Object function router(req, res, next) {
    router.handle(req, res, next);
  } has no method 'index'
    at Context.<anonymous> (/Users/casiano/local/src/coffee/coffeepress/test/routes-test.coffee:13:14)
    ...
\end{verbatim}

\parrafo{Should display index with posts: green}
Se queja de que \verb|routes = require "../routes/index"| no tiene un método \verb|index|.
Se lo añadimos:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')

module.exports = 
  index: (req, res) ->
    res.render 'index', { title: 'My Coffeepress Blog' }
\end{verbatim}

Y ahora las pruebas pasan:

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec

  routes
    index
      ok: should display index with posts 

  1 passing (6ms)
\end{verbatim}

\parrafo{Expect vars posts equal empty array: red}
Now let’s add a post variable that will be an array of posts we’ll display on the front page. Add the following assertion 
\begin{verbatim}
          expect(vars.posts).eql []
\end{verbatim}

right after the title assertion:

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat test/routes-test.coffee 
chai     = require 'chai'
expect   = chai.expect
routes = require "../routes/index"

describe "routes", ->
  req = {}
  res = {}
  describe "index", ->
    it "should display index with posts", ->
      res.render = (view, vars) ->
          expect(view).equal "index"
          expect(vars.title).equal "My Coffeepress Blog"
          expect(vars.posts).deep.equal []
      routes.index(req, res)
\end{verbatim}
Obsérvese  que hemos usado el método \verb|deep|. También podríamos haber usado \verb|eql| en vez
de \verb|.deep.equal|.

Now the tests fail:

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec

  routes
    index
      1) should display index with posts


  0 passing (12ms)
  1 failing

  1) routes index should display index with posts:
     AssertionError: expected undefined to deeply equal []
\end{verbatim}

\parrafo{Expect vars posts equal empty array: green}
Let us change the route to have a \verb|posts| 
array variable available in the template.
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')

module.exports = 
  index: (req, res) ->
    res.render 'index', 
      title: 'My Coffeepress Blog' 
      posts: []
\end{verbatim}
and now the tests pass:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec

  routes
    index
      ok: should display index with posts 

  1 passing (12ms)
\end{verbatim}

\parrafo{views/index.jade}

Completemos la vista \verb|index|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat views/index.jade 
extends layout
block content
  - each post in posts
    .page-header
      li
        a(href="/post/#{post.id}")= post.title
        .content!=post.body
\end{verbatim}


\parrafo{views/layout.jade}

Necesitamos un \verb|layout|:
\begin{verbatim}
~/src/coffee/coffeepress(master)]$ cat views/layout.jade 
doctype html
html
  head
    title= title
    //link(rel="stylesheet", href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css")
    //script(src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js")
    //script(src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js")
    style(type="text/css")
      #content { padding-top: 60px;}
  body
    .topbar-wrapper
      .topbar
        .topbar-inner
          .container
            h3: a(href="/") My Coffeepress Blog
            ul.nav
              li: a(href="/post/new") New Post
              #content.container
                block content
\end{verbatim}
\begin{itemize}
\item
Jade supports template inheritance via the \verb|block| and \verb|extends| keywords. 
\begin{verbatim}
              ...
              #content.container
                block content
\end{verbatim}
\item A \verb|block| is simply a \blue{block of Jade} 
that may be replaced within a child
template, this process is recursive.
\item
\htmladdnormallink{Jade: Testing Inheritance}{http://jade-lang.com/reference/inheritance/}
\end{itemize}

\begin{itemize}
\item
The \verb|extends| keyword allows a template to extend a layout or parent template. 
\red{It can then override certain pre-defined blocks of content}.
\item
Now to extend the \verb|layout|, we simply create 
the \verb|index.jade|
file and use the \verb|extends| directive, giving the path 
(with or without the \verb|.jade| extension). 
\item
We then define  the block \red{content} using the 
\verb|block| declaration:
\begin{verbatim}
block content
\end{verbatim}
\item
In general, we can define
one or more blocks that will
override the parent block content
\item
Véase
\htmladdnormallink{Jade: Testing Inheritance}{http://jade-lang.com/reference/inheritance/}
\end{itemize}

\parrafo{Should display the add post page: red}
Next let’s write tests for the \red{new post} route.

\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat -n test/routes-test.coffee 
 1  chai     = require 'chai'
 2  expect   = chai.expect
 3  routes = require "../routes/index"
 4  
 5  describe "routes", ->
 6    req = {}
 7    res = {}
 8    describe "index", ->
 9      it "should display index with posts", ->
..        ...
15  
16    describe "new post", ->
17      it "should display the add post page", ->
18        res.render = (view, vars) ->
19            expect(view).equal "add_post"
20            expect(vars.title).equal "Write New Post"
21      
22        routes.newPost(req, res)
\end{verbatim}
El test falla porque \verb|routes| carece de un método \verb'newPost':
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec test/routes-test.coffee 


  routes
    index
      ok: should display index with posts 
    new post
      1) should display the add post page


  1 passing (17ms)
  1 failing

  1) routes new post should display the add post page:
     TypeError: Object #<Object> has no method 'newPost'
\end{verbatim}

\parrafo{Should display the add post page: (false) green}
Añadamos un método \verb'newPost' al código de la ruta:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat -n routes/index.coffee 
     1  express = require('express')
     2  
     3  module.exports = 
     4    index: (req, res) ->
     5      res.render 'index', 
     6        title: 'My Coffeepress Blog' 
     7        posts: []
     8  
     9    newPost: (req, res) ->
    10      # do nothing
\end{verbatim}
¡Cuando ejecutamos las pruebas pasan!:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec test/routes-test.coffee 


  routes
    index
      ok: should display index with posts 
    new post
      ok: should display the add post page 

  2 passing (8ms)
\end{verbatim}

\parrafo{Mocha: done}

\red{That’s not good}. 

Esto es así porque \verb|res.render| nunca es llamado ya que 
el cuerpo de \verb|newPost| es vacío.

\begin{verbatim}
18        res.render = (view, vars) ->
19            expect(view).equal "add_post"
20            expect(vars.title).equal "Write New Post"
21      
22        routes.newPost(req, res)
\end{verbatim}

How can we make absolutely sure the test gets called during our test run? 
\begin{itemize}
\item
Mocha has a feature that allows for easy testing in these situations. 
\item
In
the method declaration of our test specify a parameter named \verb|done|. 
\item
By adding \verb|done| to the callback of \verb|it()| 
\red{Mocha will know that it should wait for completion}.
\item
Mocha will wait until \verb|done| is called or until some time limit is exceeded
\item
\verb|done|
is a callback that we can call anywhere to indicate the test is
done. 
\item
Basically the test will wait up to a default of 2000ms for it to
be called. 
\end{itemize}
With this in mind, let’s modify our tests with the following:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat test/routes-test.coffee 
chai     = require 'chai'
expect   = chai.expect
routes = require "../routes/index"

describe "routes", ->
  req = {}
  res = {}
  describe "index", ->
    it "should display index with posts", ->
      ...

  describe "new post", ->
    it "should display the add post page", (done)->
      res.render = (view, vars) ->
          expect(view).equal "add_post"
          expect(vars.title).equal "Write New Post"
          done()
    
      routes.newPost(req, res)
\end{verbatim}
Now it fails since the \verb|done()| callback is never called:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec test/routes-test.coffee 


  routes
    index
      ok: should display index with posts 
    new post
      1) should display the add post page


  1 passing (2s)
  1 failing

  1) routes new post should display the add post page:
     Error: timeout of 2000ms exceeded
    at [object Object].<anonymous> (/usr/loc
\end{verbatim}

\parrafo{Escribiendo newPost}

Let’s go ahead and implement the route and connect it into our router.
\begin{verbatim}
~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')

module.exports = 
  index: (req, res) ->
    ...

  newPost: (req, res) ->
    res.render 'add_post', title:"Write New Post"

\end{verbatim}
And connecting it up in the \verb|app.coffee|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ sed -ne '20,21p' app.coffee 
app.get '/', routes.index
app.get '/post/new', routes.newPost
\end{verbatim}

\parrafo{views/add\_post.jade}

Ademas tenemos que añadir la vista  \verb|add_post|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat views/add_post.jade 
extends layout
block content
  form(method="post", action="/post/new")
    fieldset
      legend=title
      .clearfix
        label(for="title") Title
        .input
          input.xlarge#title(type="text", name="title")
      .clearfix
        label(for="post") Post
        .input
          textarea#post.xxlarge(name="body",rows="3")
      .actions
        input.btn.primary(type="submit", value="Publish!")
        |   
        a.btn(href="/") Cancel
\end{verbatim}

\begin{itemize}
\item
The \verb|<fieldset>| tag is used to group related elements in a form.
\item
The 
\htmladdnormallink{fieldset }{http://www.w3schools.com/tags/tag\_fieldset.asp}
tag draws a box around the related elements.
\item
The 
\htmladdnormallink{legend}{http://www.w3schools.com/tags/tag\_legend.asp}
tag defines a caption for the 
\htmladdnormallink{fieldset }{http://www.w3schools.com/tags/tag\_fieldset.asp}
element.
\end{itemize}

\begin{itemize}
\item
On the server side We can access to the data filled in the form 
(both the input and textarea)
\begin{verbatim}
input.xlarge#title(type="text", name="title")
...
textarea#post.xxlarge(name="body",rows="3")
\end{verbatim}
using \verb|req.body|. It
Contains key-value pairs (with keys \verb|title|, \verb|body|)
of data submitted in the request body. 

By default, \verb|req.body| is \verb|undefined|, 
and is populated when you use body-parsing middleware such as 
\verb|body-parser|.
\end{itemize}

\begin{rawhtml}
<img src="formcoffeepress.png" width="50%" />
\end{rawhtml}

\parrafo{Should display the add post page: (true) green}
Ahora podemos ejecutar las pruebas:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ mocha --compilers coffee:coffee-script/register -R spec test/routes-test.coffee 


  routes
    index
      ok: should display index with posts 
    new post
      ok: should display the add post page 


  2 passing (9ms)
\end{verbatim}

\parrafo{Gulpfile}

Vamos a crear un \verb|gulpfile| para ejecutar las tareas mas comunes
(véase  el post
\htmladdnormallink{A gulp of coffee: your gulpfile in coffeescript}{http://pem-musing.blogspot.com.es/2014/02/a-gulp-of-coffee-your-gulpfile-in.html}):
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat gulpfile.coffee 
gulp = require('gulp')
shell = require('gulp-shell')

# run coffee server via nodemon https://github.com/remy/nodemon
gulp.task 'default', ->
  gulp.src('').pipe shell([ 'DEBUG=coffeepress:* nodemon bin/www.coffee' ])

# run coffee server
gulp.task 'cofserver', ->
  gulp.src('').pipe shell([ 'coffee app.coffee' ])

gulp.task 'test', [ 'mocha' ]
gulp.task 'mocha', ->
  gulp.src('').pipe shell(['mocha --compilers coffee:coffee-script/register -R spec'])

# run mongod server
gulp.task 'mongod', ->
  gulp.src('').pipe shell([ 'mongod' ])
\end{verbatim}

Este es el correspondiente código de la version javascript:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat gulpfile.js
// Note the new way of requesting CoffeeScript since 1.7.x
require('coffee-script/register');
// This bootstraps your Gulp's main file
require('./gulpfile.coffee');
\end{verbatim}
Es necesario instalar \verb|gulp-shell|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ npm install --save-dev gulp-shell 
\end{verbatim}
ahora podemos ejecutar las pruebas con \verb|gulp test|.

\parrafo{Guardando el Post}
Now let’s add another route to handle the post. 
For now, we’re just going to store each post in an array. 
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')
debug = require('debug')('coffeepress:server')

posts = [ {id:0, title: "hi", body: "Hola todo el mundo"}, {id:1, title: "world", body: "I like <b>coffee</b>"}] 

module.exports = 
  index: (req, res) ->
    debug "en index"
    res.render 'index', 
          title: 'My Coffee Blog' 
          posts: posts

  newPost: (req, res) ->
    debug "en newPost"
    res.render 'add_post', title:"Write New Post"

  addPost: (req, res) ->
    debug "en addPost"
    debug req.body
    post = req.body
    # [post.title, post.body ] = [req.body.title, req.body.body]
    post.id = posts.length
    posts.push post
    res.redirect "/"
\end{verbatim}
\begin{itemize}
\item
The module
\htmladdnormallink{body-parser}{https://github.com/expressjs/body-parser}
 is a piece of express middleware that·
reads a form's input and stores it as a javascript
object accessible through \verb|req.body|·
\item
By default, \verb|req.body| is \verb|undefined|, 
and is populated when you use body-parsing middleware such as 
\verb|body-parser|.
\item
On the server side We can access to the data filled in the form 
(both the input and textarea)
\begin{verbatim}
input.xlarge#title(type="text", name="title")
...
textarea#post.xxlarge(name="body",rows="3")
\end{verbatim}
using \verb|req.body|. It
Contains key-value pairs (with keys \verb|title|, \verb|body|)
of data submitted in the request body. 
\begin{verbatim}
post = req.body
\end{verbatim}
or
\begin{verbatim}
[post.title, post.body] = [req.body.title, req.body.body]
\end{verbatim}
\end{itemize}

We also add a new route to \verb|app.coffee|
\begin{verbatim}
~/src/coffee/coffeepress(master)]$ sed -ne '20,22p' app.coffee 
app.get  "/"        , routes.index
app.get  "/post/new", routes.newPost
app.post "/post/new", routes.addPost
\end{verbatim}

\parrafo{Viewing a Single Post}

Añadimos un método \verb|newPost| y lo montamos en \verb|/post/:id|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ sed -ne '20,23p' app.coffee 
app.get  "/"        , routes.index
app.get  "/post/new", routes.newPost
app.post "/post/new", routes.addPost
app.get  "/post/:id", routes.viewPost
\end{verbatim}
Este es el código del manejador de la ruta \verb|/post/:id|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat routes/index.coffee 
express = require('express')
debug = require('debug')('coffeepress:server')

#posts = []

module.exports = 
  index: (req, res) ->
    ...

  newPost: (req, res) ->
    res.render 'add_post', title:"Write New Post"

  addPost: (req, res) ->
    ...

   viewPost: (req, res) ->
     post = posts[req.params.id]
     res.render 'post', post: post, title: post.title, id: req.params.id
\end{verbatim}
\begin{itemize}
\item
\verb|req.params| is an object containing properties mapped to the 
\cei{named route parameters}. 
\item
For example, if you have the route \verb|/user/:name|, then the \verb|name| property is available as 
\verb|req.params.name| 
\item
The \verb|req.params| object defaults to \verb|{}|
\item
Example:
\begin{verbatim}
// GET /user/tj
req.params.name
// => "tj"
\end{verbatim}
\item
When you use a regular expression for the route definition, capture groups are provided in the array using 
\verb|req.params[n]|, where \verb|n| is the nth capture group. 

For example, the following:
\begin{verbatim}
router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
\end{verbatim}
would match \verb|GET /commits/71dbb9c| as well as \verb|GET /commits/71dbb9c..4c084f9|
\item
This rule is applied to unnamed wild card
matches with string routes such as \verb|/file/*|:
\begin{verbatim}
// GET /file/javascripts/jquery.js
req.params[0]
// => "javascripts/jquery.js"
\end{verbatim}
\end{itemize}
Y esta es la vista \verb|views/post.jade|:
\begin{verbatim}
[~/src/coffee/coffeepress(master)]$ cat views/post.jade 
extends layout
block content
  h1 Post #{ id }
    .page-header
      h1= post.title
    .content!=post.body
\end{verbatim}
Ahora cuando visitamos una ruta como \verb|/post/2| nos mostrará el correspondiente post.

\section{MongoDB}

\subsection{Introducción}
\begin{itemize}
\item
MongoDB (from humongous: huge; enormous) is one of many cross-platform 
\htmladdnormallink{document-oriented databases}{http://en.wikipedia.org/wiki/Document-oriented\_database}
\item
Is classified as a 
\htmladdnormallink{NoSQL database}{http://en.wikipedia.org/wiki/NoSQL},
\item
MongoDB eschews the traditional table-based relational database structure in favor of JSON-like documents with dynamic schemas (MongoDB calls the format BSON)
\end{itemize}

\parrafo{NoSQL}

\begin{itemize}
\item
A NoSQL (often interpreted as Not only SQL) database \blue{provides a mechanism for storage and retrieval of data that is modeled in means other than the tabular relations used in relational
databases}
\item  
Motivations for this approach include 
\begin{itemize}
\item simplicity of design
\item horizontal scaling
\item and finer control over availability
\end{itemize}
\item  
The data structures used by NoSQL databases (e.g. key-value, graph, or
document) differ from those used in relational databases, making some operations faster in NoSQL and others faster in relational databases
\item  
The particular suitability of a given NoSQL database depends
on the problem it must solve
\item  
NoSQL databases are increasingly used in \red{big data} and \red{real-time web applications}
\item
NoSQL systems are also called "Not only SQL" to emphasize that they may also support SQL-like query languages
\item
Many
NoSQL stores compromise consistency (in the sense of the CAP\footnote{the CAP theorem, also known as Brewer's theorem, states that it is impossible for a distributed computer system to simultaneously
provide all three of the following guarantees:
\begin{itemize}
\item
Consistency (all nodes see the same data at the same time)
\item
Availability (a guarantee that every request receives a response about whether it succeeded or failed)
\item
Partition tolerance (the system continues to operate despite arbitrary message loss or failure of part of the system)
\end{itemize}
} theorem) in favor of availability and partition tolerance.
\end{itemize}

\parrafo{Relational  Database}

\begin{itemize}
\item
In a relational database, \red{data is first categorized into a number of
predefined types, and tables are created to hold individual entries, or
records, of each type}. 

\item
The tables define the data within each record's
fields, meaning that every record in the table has the same overall
form. 

\item
The administrator also defines the relations between the tables,
and selects certain fields that they believe will be most commonly used
for searching and defines indexes on them. 

\item
A key concept in the relational
design is that any data that may be repeated is placed in its own table,
and if these instances are related to each other, a field is selected
to group them together, the \cei{foreign key}.

\item
For example, an address book application will generally need to
store the contact name, an optional image, one or more phone numbers,
one or more mailing addresses, and one or more email addresses. 

\item
In a
canonical relational database solution, tables would be created for
each of these records with predefined fields for each bit of data; the
\verb|CONTACT| table might include \verb|FIRST_NAME|, \verb|LAST_NAME| and \verb|IMAGE| fields,
while the \verb|PHONE_NUMBER| table might include \verb|COUNTRY_CODE|, \verb|AREA_CODE|,
\verb|PHONE_NUMBER| and \verb|TYPE| (home, work, etc). 

\item
The \verb|PHONE_NUMBER| table also
contains a \cei{foreign key} field, "\verb|CONTACT_ID|", which holds the unique \verb|ID|
number assigned to the contact when it was created. 

\item
In order to recreate
the original contact, the system has to search through all of the tables
and collect the information back together using \cei{joins}\footnote{
A SQL join clause combines records from two or more tables in a relational database. It creates a set that can be saved as a table or used as it is}
\end{itemize}

\parrafo{Document Oriented DataBase}
\begin{itemize}
\item
In contrast, in a \red{document-oriented database} there may be no internal
structure that maps directly onto the concept of a table, and the fields
and relations generally don't exist as predefined concepts.

\item
Instead, \blue{all
of the data for an object is placed in a single document, and stored in
the database as a single entry}
\item
In the address book example, the document
would contain the contact's name, image and any contact info, \blue{all in a
single record}

\item
That entry is accessed through a key, some unique bit of
data, which allows the database to retrieve and return the document to
the application. No additional work is needed to retrieve the related
data, all of this is returned in a single object.

\item
A key difference between the document-oriented and relational models is
that \blue{the data formats are not predefined in the document case}
\item
In most
cases, any sort of document can be stored in any database, and those
documents can change in type and form at any time
\item If one wishes to
add a \verb|COUNTRY_FLAG| to a \verb|CONTACT|, simply add this field to new documents
as they are inserted, this will have no effect on the database or the
existing documents already stored, they simply won't have this field
\item This
indicates an advantage of the document-based model; optional fields are
truly optional, a contact that does not include a mailing address simply
does not have a mailing address, there is no need to check another table
to see if there are entries
\item 
To aid retrieval of information from the database, document-oriented
systems generally allow the administrator to provide hints to the database
to look for certain types of information
\item In the address book example,
the design might add hints for the first and last name fields
\item When the
document is inserted into the database (or later modified), the database
engine looks for these bits of information and indexes them, in the same
fashion as the relational model
\item Additionally, most document-oriented
databases allow documents to have a type associated with them, like
\verb"address book entry", which allows the programmer to retrieve related
types of information, like \verb"all the address book entries"
\item This provides
functionality similar to a table, but separates the concept (categories
of data) from its physical implementation (tables)
\item 
All of this is predicated on the ability of the database engine
to examine the data in the document and extract fields from the
formatting, its metadata
\item This is easy in the case of, for example, an
XML document or HTML page, where markup tags clearly identify various
bits of data
\item Document-oriented databases may include functionally
to automatically extract this sort of information from a variety of
document types, even those that were not originally designed for easy
access in this manner
\item In other cases the programmer has to provide this
information using their own code
\item In contrast, a relational database
relies on the programmer to handle all of these tasks, breaking down
the document into fields and providing those to the database engine,
which may require separate instructions if the data spans tables
\item 
Document-oriented databases normally map more cleanly onto existing
programming concepts, like object-oriented programming (OOP)
\end{itemize}


\subsection{Getting Started with MongoDB}

\begin{itemize}
\item
Véase
\htmladdnormallink{Getting Started with MongoDB}{http://docs.mongodb.org/manual/tutorial/getting-started/}
\end{itemize}
\begin{verbatim}
$ mongod
all output going to: /usr/local/var/log/mongodb/mongo.log
\end{verbatim}

By default, mongo looks for a database server listening on port 27017
on the localhost interface. 

To connect to a server on a different port
or interface, use the \verb|--port| and
\verb|--host| options.

Podemos también usar un fichero de configuración:
\begin{verbatim}
[~/javascript/expressjs/coffee-mongo(master)]$ cat /usr/local/etc/mongod.conf
# Store data in /usr/local/var/mongodb instead of the default /data/db
dbpath = /usr/local/var/mongodb

# Append logs to /usr/local/var/log/mongodb/mongo.log
logpath = /usr/local/var/log/mongodb/mongo.log
logappend = true

verbose = v 
# Only accept local connections
bind_ip = 127.0.0.1
\end{verbatim}

y ejecutarlo con la opción \verb|--config|:
\begin{verbatim}
$ mongod --config /usr/local/etc/mongod.conf
\end{verbatim}

\begin{verbatim}
[~/src/coffee/coffeepress.bak(master)]$ mongo
MongoDB shell version: 2.4.8
connecting to: test
Server has startup warnings: 
Mon Apr 13 21:53:16.204 [initandlisten] 
Mon Apr 13 21:53:16.204 [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000
\end{verbatim}

After starting the mongo shell, your session will use the test database by default. At any time, issue the following operation at the mongo shell to report the name of the current database:
\begin{verbatim}
> db
test
\end{verbatim}

From the mongo shell, display the list of databases, with the following operation:

\begin{verbatim}
> show dbs
coffeepress     0.203125GB
coffeepress-dev 0.203125GB
dict_dev        0.203125GB
example 0.203125GB
local   0.078125GB
mean    0.203125GB
my_perpetuity_database  0.203125GB
mydb    0.203125GB
sinatra-example-dev     0.203125GB
test    0.203125GB
\end{verbatim}

Switch to a new database named \verb|example|, 
with the following operation:
\begin{verbatim}
> use example
switched to db example
\end{verbatim}
At any point, you can access help for the mongo shell using
\begin{verbatim}
> help
        db.help()                    help on db methods
        db.mycoll.help()             help on collection methods
        sh.help()                    sharding helpers
        rs.help()                    replica set helpers
        help admin                   administrative help
        help connect                 connecting to a db help
        help keys                    key shortcuts
        help misc                    misc things to know
        help mr                      mapreduce

        show dbs                     show database names
        show collections             show collections in current database
        show users                   show users in current database
        show profile                 show most recent system.profile entries with time >= 1ms
        show logs                    show the accessible logger names
        show log [name]              prints out the last segment of log in memory, 'global' is default
        use <db_name>                set current database
        db.foo.find()                list objects in collection foo
        db.foo.find( { a : 1 } )     list objects in foo where a == 1
        it                           result of the last line evaluated; use to further iterate
        DBQuery.shellBatchSize = x   set default number of items to display on shell
        exit                         quit the mongo shell
\end{verbatim}

Furthermore, you can append the \verb|.help()| 
method to some JavaScript methods, any cursor object,
as well as the \verb|db| and \verb|db.collection| objects to return additional help information.
\begin{verbatim}
> db.help()
DB methods:
        db.addUser(userDocument)
        db.auth(username, password)
        ...
\end{verbatim}

\subsection{Create a Collection and Insert Documents}
In this section, you insert documents into a new collection named \verb|testData|
within the new database named \verb|mydb|.

Create two documents named \verb|j| and 
\verb|k| by using the following sequence of JavaScript operations:
\begin{verbatim}
> j = { name : "mongo" }
{ "name" : "mongo" }
> k = { x : 3 }
{ "x" : 3 }
\end{verbatim}
Insert the \verb|j| and \verb|k| documents into the 
\verb|testData| collection with the following sequence of operations:
\begin{verbatim}
> db.testData.insert( j )
> db.testData.insert( k )
\end{verbatim}
When you insert the first document, the \verb|mongod| 
will create both the \verb|mydb| 
database and the \verb|testData| collection.
\begin{verbatim}
> show collections
system.indexes
testData
\end{verbatim}
The mongo shell will return the list of the collections in the current (i.e. mydb) database. At this point, the only collection with user data is testData.

Confirm that the documents exist in the testData collection by issuing a query on the collection using the find() method:

\begin{verbatim}
> db.testData.find()
{ "_id" : ObjectId("552d751969c6f61bfbe4e6ed"), "name" : "mongo" }
{ "_id" : ObjectId("552d751a69c6f61bfbe4e6ee"), "x" : 3 }
\end{verbatim}
All MongoDB documents must have an \verb|_id| field with a unique value. These operations do not explicitly specify a value for the \verb|_id| field, so mongo creates a unique \verb|ObjectId| value for the field before inserting it into the collection.

\subsection{Insert Documents using a For Loop or a JavaScript Function}
To perform the remaining procedures in this tutorial, first add more documents to your database using one or both of the procedures described in Generate Test Data.


\parrafo{Insert Multiple Documents Using a For Loop}

From the mongo shell, use the for loop. If the testData collection does not exist, MongoDB will implicitly create the collection.
\begin{verbatim}
> for (var i = 1; i <= 25; i++) {
...    db.testData.insert( { x : i } )
... }
\end{verbatim}
Use find() to query the collection:
\begin{verbatim}
> db.testData.find()
{ "_id" : ObjectId("552d751969c6f61bfbe4e6ed"), "name" : "mongo" }
{ "_id" : ObjectId("552d751a69c6f61bfbe4e6ee"), "x" : 3 }
{ "_id" : ObjectId("552d791269c6f61bfbe4e6f0"), "x" : 1 }
{ "_id" : ObjectId("552d791269c6f61bfbe4e6f1"), "x" : 2 }
{ "_id" : ObjectId("552d791269c6f61bfbe4e6f2"), "x" : 3 }
....
{ "_id" : ObjectId("552d791269c6f61bfbe4e701"), "x" : 18 }
Type "it" for more
\end{verbatim}
Iterate through the cursor.
The find() method returns a cursor. To iterate the cursor and return more documents, type 
\verb|it| in the mongo shell. The shell will exhaust the cursor and return these documents:
\begin{verbatim}
> it
{ "_id" : ObjectId("552d791269c6f61bfbe4e702"), "x" : 19 }
.....
{ "_id" : ObjectId("552d791269c6f61bfbe4e708"), "x" : 25 }
\end{verbatim}

\parrafo{Working with the Cursor}

When you query a collection, MongoDB returns a “cursor” object that
contains the results of the query. The mongo shell then iterates over
the cursor to display the results. Rather than returning all results at
once, the shell iterates over the cursor 20 times to display the first
20 results and then waits for a request to iterate over the remaining
results. In the shell, enter it to iterate over the next set of results.

The procedures in this section show other ways to work with a cursor. For comprehensive documentation on cursors, see Iterate the Returned Cursor.

\section{Mongoose}

\htmladdnormallink{Mongoose}{http://mongoosejs.com/}
provides a straight-forward, schema-based solution to modeling your
application data and includes built-in type casting, validation, query
building, business logic hooks and more, out of the box.

\subsection{Getting Started}

Véase
\htmladdnormallink{mongoose: getting started}{http://mongoosejs.com/docs/index.html}.

Now say we like fuzzy kittens and want to record every kitten we ever
meet in MongoDB. 

The first thing we need to do is include mongoose in
our project and open a connection to the test database on
our locally running instance of MongoDB.

\begin{verbatim}
// getting-started.js
var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/test');
\end{verbatim}

We have a pending connection to the test database running on localhost. We
now need to get notified if we connect successfully or if a connection
error occurs:

\begin{verbatim}
var db = mongoose.connection;
db.on('error', console.error.bind(console, 'connection error:'));
db.once('open', function (callback) {
  // yay!
});
\end{verbatim}

Once our connection opens, our callback will be called. 

\red{For brevity, let's assume that all following code is within this callback}.

With Mongoose, everything is derived from a 
\verb|Schema|. 

Let's get a reference to it and define our kittens.

\begin{verbatim}
var kittySchema = mongoose.Schema({
    name: String
})
\end{verbatim}
Everything in Mongoose starts with a 
\htmladdnormallink{Schema}{http://mongoosejs.com/docs/guide.html}. 
Each schema maps to a \cei{MongoDB} collection and \red{defines the shape of the \cei{MongoDB documents} within that collection}.

So far so good. 

We've got a schema with one property, \verb|name|, which will be a \verb|String|. 

The next step is compiling our schema into a 
\htmladdnormallink{Model}{http://mongoosejs.com/docs/models.html}.

\begin{verbatim}
var Kitten = mongoose.model('Kitten', kittySchema)
\end{verbatim}
\red{A model is a class with which we construct documents}. 

In this case, each document will be a kitten with properties and behaviors as declared in our schema. 
Let's create a kitten document representing the little guy we just met on the sidewalk outside:
\begin{verbatim}
var silence = new Kitten({ name: 'Silence' })
console.log(silence.name) // 'Silence'
\end{verbatim}

Kittens can meow, so let's take a look at how to add "speak" functionality to our documents:

\red{methods must be added to the schema before compiling it with} \verb|mongoose.model()|
\begin{verbatim}
kittySchema.methods.speak = function () {
  var greeting = this.name
    ? "Meow name is " + this.name
    : "I don't have a name"
  console.log(greeting);
}

var Kitten = mongoose.model('Kitten', kittySchema)
\end{verbatim}
Functions added to the methods property of a schema get compiled into
the Model prototype and exposed on each document instance:
\begin{verbatim}
var fluffy = new Kitten({ name: 'fluffy' });
fluffy.speak()
\end{verbatim}

We have talking kittens! But we still haven't saved anything to
MongoDB. 

Each document can be saved to the database by calling its
\verb|save| method. 

The first argument to the callback will be an error if
any occured.

\begin{verbatim}
fluffy.save(function (err, fluffy) {
  if (err) return console.error(err);
  fluffy.speak();
});
\end{verbatim}

Say time goes by and we want to display all the kittens we've seen. 

We can access all of the kitten documents through our \verb|Kitten| model.

\begin{verbatim}
Kitten.find(function (err, kittens) {
  if (err) return console.error(err);
  console.log(kittens)
})
\end{verbatim}

We just logged all of the kittens in our \verb|db| to the console. 

If we want to filter our kittens by name, Mongoose supports MongoDBs rich querying syntax.

\begin{verbatim}
Kitten.find({ name: /^Fluff/ }, callback)
\end{verbatim}
This performs a search for all documents with a name property that begins with \verb|"Fluff"| 
and returns the result as an array of kittens to the \verb|callback|.

Este es el código completo de nuestro ejemplo:

\begin{verbatim}
[~/javascript/mongoose]$ cat getting-started.js 
var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/test');

var kittySchema = mongoose.Schema({
    name: String
  });


kittySchema.methods.speak = function() {
  var greeting = this.name? "Meow name is "+this.name : "I don't have a name";
  console.log(greeting);

}

// compiling our schema into a Model
var Kitten = mongoose.model('Kitten', kittySchema);

var db = mongoose.connection;
db.on('error', console.error.bind(console, 'Error en la conexión a MongoDB:'));

var errDisconnect =  function(err) {
  if (err) { console.log("Se produjo un error en la desconexión! "+err) }
  else { console.log("Desconectando!") }
}

var main = function() {
  console.log("Abierta la conexión con MongoDB!");

  var silence = new Kitten({ name: 'Silence' });
  console.log(silence.name);    // 'Silence'
  silence.speak(); // 'Meow name is Silence'

  var fluffy = new Kitten({ name: 'fluffy' });
  fluffy.speak();

  fluffy.save(function (err, fluffy) {
    if (err) console.error("no puedo guardar a fluffy! "+err)
    else console.error("fluffy guardado!");

    Kitten.find({ name: /^Fluff/i },function (err, kittens) {
      if (err) return console.error("Error buscando gatos! "+err);
      console.log(kittens);

      mongoose.disconnect(errDisconnect);
    });
  });
}

db.once('open', main);
\end{verbatim}
Cuando lo ejecutamos obtenemos:
\begin{verbatim}
[~/javascript/mongoose]$ node getting-started.js 
Abierta la conexión con MongoDB!
Silence
Meow name is Silence
Meow name is fluffy
fluffy guardado!
[ { _id: 552fb8f77e6de9990a4e6747, name: 'fluffy', __v: 0 } ]
Desconectando!
\end{verbatim}
Si lo ejecutamos una segunda vez obtenemos:
\begin{verbatim}
[~/javascript/mongoose]$ node getting-started.js 
Abierta la conexión con MongoDB!
Silence
Meow name is Silence
Meow name is fluffy
fluffy guardado!
[ { _id: 552fb8f77e6de9990a4e6747, name: 'fluffy', __v: 0 },
  { _id: 552fb8f987df0fa30ab92647, name: 'fluffy', __v: 0 } ]
Desconectando!
\end{verbatim}

\section{Añadiendo Persistencia: Posts con MongoDB y Mongoose}
Let’s add a dependency on mongoose to our project and freeze it at version 4.0.1.
As always, run \verb|npm install| to bring it in. 
\begin{verbatim}
$ npm install --save mongoose
$ grep mongoose package.json 
    "mongoose": "~4.0.1"
\end{verbatim}

\subsection{Definiendo el Modelo y Probando que Funciona}

Now we’ll create an initial test to just test mongoose out.
\begin{verbatim}
~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ cat test/post-test.coffee 
mongoose = require 'mongoose'
Post     = require '../models/Post'
chai     = require 'chai'
expect   = chai.expect

describe 'Post', ->
  before (done) ->
    mongoose.connect 'mongodb://localhost/coffeepress', ->
      Post.remove done
  it 'should create a new post', (done) ->
    post = new Post(title:'First!', body:'First post!')
    post.save ->
      Post.findOne _id: post._id, (err, retrievedPost) ->
        expect(retrievedPost.title).eql "First!"
        expect(retrievedPost.body).eql "First post!"
        done()
\end{verbatim}
\begin{itemize}
\item
Here we import both \verb|mongoose| and the model object that we’re going
to create
\item
Since we want our test to start with a clean slate, we use
the \verb|before| hook (which runs once before anything else in the test runs)
to both connect to the database and then \verb|remove| all of the Post objects
from mongodb
\begin{itemize}
\item
The four hooks in Mocha are:
\item
The \verb|beforeEach()| hook contains code that runs before every test in a describe block.
\item
The \verb|afterEach()| hook contains code that runs after every test in a describe block.
\item
The \verb|before()| hook contains code that runs before any tests in each \verb|describe()| block run. It runs before the first run of a \verb|beforeEach()| hook.
\item
The \verb|after()| hook contains code that runs after all tests in each \verb|describe()| block have run. The \verb|after()| hook will run after the last \verb|afterEach()| hook.
\item
See
\htmladdnormallink{Hooks in Mocha}{https://medium.com/@kanyang/hooks-in-mocha-87cb43baa91c}
\end{itemize}
\begin{itemize}
\item
Models have a static remove method available for removing all documents matching conditions.
\begin{verbatim}
Post.remove({ title: 'first' }, function (err) {
  if (err) return handleError(err);
  // removed!
});
\end{verbatim}
When no condition is specified all the documents are removed
\end{itemize}
\item  We pass the \verb|done| callback to the \verb|remove| call \red{so that tests
don’t run until all Posts have been removed}
\item Now we create a new \verb|Post| instance.
You can pass an object literal in to set properties on the model, so we do that here
\begin{verbatim}
    post = new Post(title:'First!', body:'First post!')
\end{verbatim}
\item Finally, in our post \verb|save| callback we look the post back up and verify certain attributes have been set
\begin{verbatim}
    post.save ->
      Post.findOne _id: post._id, (err, retrievedPost) ->
        expect(retrievedPost.title).eql "First!"
        expect(retrievedPost.body).eql "First post!"
        done()
\end{verbatim}
\begin{itemize}
\item
Documents can be retreived using each models 
\verb|find|, \verb|findById|, \verb|findOne|, or \verb|where| 
static methods.
\item
El primer argumento \verb|{_id: post._id}| es la condición y especifica el documento que 
queremos buscar
\item
El segundo argumento \verb|(err, retrievedPost) -> ...| es la callback que se ejecuta
cuando el documento ha sido encontrado. 

Aprovechamos esta callback para hacer
las pruebas y llamar finalmente a \verb|done()| para indicar la finalización de las pruebas.
\end{itemize}
\item Obsérvese que las pruebas se refieren a que el modelo
está definido correctamente. Obviamente nuestra aplicación aún no usa el modelo
y no se está comprobando nada acerca de la relación entre la aplicación y el modelo
\end{itemize}
\begin{verbatim}
~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp test
[11:05:16] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[11:05:16] Starting 'mocha'...

module.js:340
    throw err;
          ^
Error: Cannot find module '../models/Post'

\end{verbatim}

Now let’s implement our model:
\begin{verbatim}
$ mkdir models
$ cat models/Post.coffee 
mongoose = require 'mongoose'

Post = new mongoose.Schema(
  title: String
  body: String
)

module.exports = mongoose.model 'Post', Post
\end{verbatim}

\begin{itemize}
\item
Everything in Mongoose starts with a Schema. 
\begin{verbatim}
Post = new mongoose.Schema(
  title: String
  body: String
)
\end{verbatim}
\red{Each schema maps to a MongoDB collection and defines the shape of the documents within that collection}.
\item
To use our schema definition, we need to convert our \verb|Post| Schema
into a Model we can work with. To do so, we pass it into
\verb|mongoose.model(modelName, schema)|:
\begin{verbatim}
mongoose.model 'Post', Post
\end{verbatim}
\end{itemize}
Si ejecutamos las pruebas obtenemos un fallo porque el servidor \verb|mongod| no está arrancado:
\begin{verbatim}
$ gulp test
[11:34:22] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[11:34:22] Starting 'mocha'...

  Post
    1) "before all" hook

  routes
    index
      ok: should display index with posts
    new post
      ok: should display the add post page

  2 passing (2s)
  1 failing

  1) Post "before all" hook:
     Error: timeout of 2000ms exceeded. Ensure the done() callback is being called in this test.
\end{verbatim}
Será mejor extender el \verb|gulpfile|
un poco para controlar el estado del servidor
\verb|mongod| antes y después de las 
pruebas:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ cat gulpfile.coffee 
gulp = require('gulp')
shell = require('gulp-shell')
fs = require('fs')

# run coffee server via nodemon https://github.com/remy/nodemon
gulp.task 'default', ->
  gulp.src('').pipe shell( 'DEBUG=coffeepress:* nodemon bin/www.coffee' )

gulp.task 'test', [ 'mocha' ]

# run mocha
gulp.task 'mocha', ->
  gulp.src('')
    .pipe shell "mocha --compilers coffee:coffee-script/register --invert --grep 'feature' -R spec"

# run mongod server
gulp.task 'mongod', ->
  gulp.src('')
    .pipe shell([ 'mongod --config mongod.conf 2>1 > /usr/local/var/mongodb/salida &' ])

# kill mongod server
gulp.task 'killmongo', ->
    fs.readFile '/usr/local/var/mongodb/mongo.pid', 'utf8', (err, pid) ->
      return console.log(err) if (err)
      console.log("killing #{pid}")
      gulp.src('').pipe shell("kill #{pid}")

# show mongod PID
gulp.task 'ps', ->
  gulp.src('')
    .pipe shell( 'ps -fA | grep mongod')
\end{verbatim}
Este es el fichero de configuración para \verb|mongod| que estoy usando:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ cat mongod.conf 
# Store data in /usr/local/var/mongodb instead of the default /data/db
dbpath = /usr/local/var/mongodb

# Append logs to /usr/local/var/mongo.log
logpath = /usr/local/var/mongodb/mongo.log
logappend = true

# Save the PID of the daemon on that file
pidfilepath = /usr/local/var/mongodb/mongo.pid

# Only accept local connections
bind_ip = 127.0.0.1
\end{verbatim}

Ahora podemos fácilmente comprobar si el servidor mongo está activo:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp ps
[14:23:52] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:23:52] Starting 'ps'...
  501 33200 33199   0  2:23PM ttys011    0:00.01 /bin/sh -c ps -fA | grep mongod
  501 33202 33200   0  2:23PM ttys011    0:00.00 grep mongod
[14:23:53] Finished 'ps' after 107 ms
\end{verbatim}
Vemos que no. Lo arrancamos:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp mongod
[14:23:59] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:23:59] Starting 'mongod'...
[14:24:00] Finished 'mongod' after 37 ms
\end{verbatim}
Comprobamos que efectivamente está corriendo:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp ps
[14:24:11] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:24:11] Starting 'ps'...
  501 33212     1   0  2:24PM ttys011    0:00.25 mongod --config mongod.conf
  501 33228 33227   0  2:24PM ttys011    0:00.00 /bin/sh -c ps -fA | grep mongod
  501 33230 33228   0  2:24PM ttys011    0:00.00 grep mongod
[14:24:11] Finished 'ps' after 82 ms
\end{verbatim}
Ejecutamos las pruebas:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp test
[14:24:21] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:24:21] Starting 'mocha'...


  Post
    ok: should create a new post

  routes
    index
      ok: should display index with posts
    new post
      ok: should display the add post page

  3 passing (179ms)

[14:24:22] Finished 'mocha' after 1.4 s
[14:24:22] Starting 'test'...
[14:24:22] Finished 'test' after 17 microseg
\end{verbatim}
Vemos que la prueba \verb|should create a new post| pasa.

Si lo deseamos podemos parar el servidor \verb|mongod|:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp killmongo
[14:24:42] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:24:42] Starting 'killmongo'...
[14:24:42] Finished 'killmongo' after 537 microseg
killing 33212
\end{verbatim}
Comprobamos que - efectivamente - el proceso no existe:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp ps
[14:24:45] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[14:24:45] Starting 'ps'...
  501 33274 33270   0  2:24PM ttys011    0:00.00 /bin/sh -c ps -fA | grep mongod
  501 33276 33274   0  2:24PM ttys011    0:00.00 grep mongod
[14:24:46] Finished 'ps' after 89 ms
\end{verbatim}

\subsection{Usando la Base de Datos MongoDB en vez de un Array en Nuestro Ejemplo}

Now let’s refit our routes to use the \verb|Post| 
model instead of an in memory array.

En el fichero \verb|app.coffee| cargamos la librería \verb|mongoose| y conectamos
con la base de datos: 
\begin{verbatim}
...
bodyParser = require('body-parser')

mongoose = require "mongoose"
mongoose.connect 'mongodb://localhost/coffeepress'

routes = require('./routes/index')
...
\end{verbatim}

Los mayores cambios los hacemos en las rutas:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ cat routes/index.coffee 
express = require('express')
Post = require '../models/Post'
debug = require('debug')('coffeepress:server')
util = require 'util'

module.exports =
  index: (req, res) ->
    Post.find {}, (err, posts) ->
      res.render "index",
        title: "My Blog"
        posts: posts
  newPost: (req, res) ->
    res.render('add_post', {title: "Write New Post"})
  addPost: (req, res) ->
    post = req.body
    new Post(post).save ->
      res.redirect '/'
  viewPost: (req, res) ->
    Post.findById req.params.id, (err, post) ->
      res.render 'post', post: post, title: post.title
\end{verbatim}

Acabaremos mejorando un poco las pruebas:
\begin{verbatim}
[~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ cat test/routes-test.coffee 
chai = require 'chai'
expect = chai.expect
mongoose = require "mongoose"
Post     = require "../models/Post"

routes = require '../routes/index'

describe 'routes', ->
  req = 
    params: {}
    body: {}
  res = 
    redirect: (route) ->
      # do nothing
    render: (view, vars) -> 
      # do nothing
  before (done) ->
    mongoose.connect 'mongodb://localhost/coffeepress', ->
      Post.remove done

  describe 'index', ->
    it "should display index with posts", (done) ->
      res.render = (view, vars) -> # redefinimos render
        expect(view).to.be.equal 'index'
        expect(vars.title).to.be.equal 'My Blog'
        expect(vars.posts).deep.equal []
        done()
      routes.index(req, res)

  describe 'new post', ->
    it "should display the add post page", (done)->
      res.render = (view, vars) -> # redefinimos render
        expect(view).to.be.equal 'add_post'
        expect(vars.title).to.be.equal 'Write New Post'
        done()
      routes.newPost(req, res)
    it "should add a new post when posted to", (done) ->
      req.body = 
        title: "My Post!"
        body: "My wonderful post."

      routes.addPost req, redirect: (route) ->
        expect(route).eql "/"
        routes.index req, render: (view, vars) ->
          expect(view).equal "index"
          expect(vars.posts[0].title).eql 'My Post!'
          expect(vars.posts[0].body).eql "My wonderful post."
          done()
\end{verbatim}
Cuando las ejecutamos tenemos:
\begin{verbatim}
~/javascript/expressjs/clase-express-coffee(preparapl20042015)]$ gulp test
[22:14:06] Using gulpfile ~/local/src/javascript/expressjs/clase-express-coffee/gulpfile.js
[22:14:06] Starting 'mocha'...


  Post
    ok: should create a new post

  routes
    index
      ok: should display index with posts
    new post
      ok: should display the add post page
      ok: should add a new post when posted to


  4 passing (165ms)

[22:14:07] Finished 'mocha' after 1.42 s
[22:14:07] Starting 'test'...
[22:14:07] Finished 'test' after 17 micros
\end{verbatim}
