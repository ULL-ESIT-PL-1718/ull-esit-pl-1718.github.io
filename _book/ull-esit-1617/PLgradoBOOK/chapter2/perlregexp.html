<h1 id="chapter:regulares">Expresiones Regulares en Perl</h1>
<h2 id="introducción">Introducción</h2>
<p>Los rudimentos de las expresiones regulares pueden encontrarse en los trabajos pioneros de McCullogh y Pitts (1940) sobre redes neuronales. El lógico Stephen Kleene definió formalmente el algebra que denominó <em>conjuntos regulares</em> y desarrollo una notación para la descripción de dichos conjuntos, las <em>expresiones regulares</em>.</p>
<p>Durante las décadas de 1960 y 1970 hubo un desarrollo formal de las expresiones regulares. Una de las priemras publicaciones que utilizan las expresiones regulares en un marco informático es el artículo de 1968 de Ken Thompson <em>Regular Expression Search Algorithm</em> en el que describe un compilador de expresiones regulares que produce código objeto para un IBM 7094. Este compilador dió lugar al editor <em>qed</em>, en el cual se basó el editor de Unix <em>ed</em>. Aunque las expresiones regulares de este último no eran tan sofisticadas como las de <em>qed</em>, fueron las primeras en ser utilizadas en un contexto no académico. Se dice que el comando global <code>g</code> en su formato <code>g/re/p</code> que utilizaba para imprimir (opción <code>p</code>) las líneas que casan con la expresión regular <code>re</code> dió lugar a un programa separado al que se denomino .</p>
<p>Las expresiones regulares facilitadas por las primeras versiones de estas herramientas eran limitadas. Por ejemplo, se disponía del cierre de Kleene <code>*</code> pero no del cierre positivo <code>+</code> o del operador opcional <code>?</code>. Por eso, posteriormente, se han introducido los metacaracteres <code>\+</code> y <code>\?</code>. Existían numerosas limitaciones en dichas versiones, por ej. <code>$</code> sólo significa “final de línea” al final de la expresión regular. Eso dificulta expresiones como</p>
<pre><code>grep &#39;cierre$\|^Las&#39; viq.tex</code></pre>
<p>Sin embargo, la mayor parte de las versiones actuales resuelven correctamente estos problemas:</p>
<pre><code>nereida:~/viq&gt; grep &#39;cierre$\|^Las&#39; viq.tex
Las expresiones regulares facilitadas por las primeras versiones de estas herramientas
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
nereida:~/viq&gt;</code></pre>
<p>De hecho AT&amp;T Bell labs añadió numerosas funcionalidades, como por ejemplo, el uso de <code>\{min, max\}</code>, tomada de <em>lex</em>. Por esa época, Alfred Aho escribió <em>egrep</em> que, no sólo proporciona un conjunto mas rico de operadores sino que mejoró la implementación. Mientras que el <em>grep</em> de Ken Thompson usaba un autómata finito no determinista (NFA), la versión de <em>egrep</em> de Aho usa un autómata finito determinista (DFA).</p>
<p>En 1986 Henry Spencer desarrolló la librería <em>regex</em> para el lenguaje <code>C</code>, que proporciona un conjunto consistente de funciones que permiten el manejo de expresiones regulares. Esta librería ha contribuido a “homogeneizar” la sintáxis y semántica de las diferentes herramientas que utilizan expresiones regulares (como <em>awk</em>, <em>lex</em>, <em>sed</em>, …).</p>
<ul>
<li><p>La sección <span><em>Expresiones Regulares en Otros Lenguajes</em></span> [section:otroslenguajes]</p></li>
<li><p><span>http://oreilly.com/catalog/9780596520687/preview.html</span></p></li>
<li><p><span>http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</span></p></li>
<li><p><span>http://www.pcre.org/pcre.txt</span></p></li>
<li><p><span>http://java.sun.com/docs/books/tutorial/essential/regex/</span></p></li>
<li><p><span>http://oreilly.com/lpt/a/2299</span></p></li>
<li><p><span>http://msdn.microsoft.com/en-us/library/hs600312(VS.71).aspx</span></p></li>
</ul>
<h3 id="section:ejemplo">Un ejemplo sencillo</h3>
<pre><code>pl@nereida:~/Lperltesting$ cat -n c2f.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
  5    my $input = &lt;STDIN&gt;;
  6    chomp($input);
  7  
  8    if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
  9      warn &quot;Expecting a temperature, so don&#39;t understand \&quot;$input\&quot;.\n&quot;;
 10    }
 11    else {
 12      my $InputNum = $1;
 13      my $type = $3;
 14      my ($celsius, $farenheit);
 15      if ($type eq &quot;C&quot; or $type eq &quot;c&quot;) {
 16        $celsius = $InputNum;
 17        $farenheit = ($celsius * 9/5)+32;
 18      }
 19      else {
 20        $farenheit = $InputNum;
 21        $celsius = ($farenheit -32)*5/9;
 22      }
 23      printf &quot;%.2f C = %.2f F\n&quot;, $celsius, $farenheit;
 24    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n c2f.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Enter a temperature (i.e. 32F, 100C):&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; !~ &lt;span class=&quot;synStatement&quot;&gt;m/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/i&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;warn&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Expecting a temperature, so don&#39;t understand &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$3&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$farenheit&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;       &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;       &lt;span class=&quot;synIdentifier&quot;&gt;$farenheit&lt;/span&gt; = (&lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; * &lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;/&lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;synConstant&quot;&gt;+32&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;     }
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;       &lt;span class=&quot;synIdentifier&quot;&gt;$farenheit&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;       &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; = (&lt;span class=&quot;synIdentifier&quot;&gt;$farenheit&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;-32&lt;/span&gt;)*&lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;/&lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;     }
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;%.2f C = %.2f F&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$farenheit&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Véase también:</p>
<ul>
<li><p><code>perldoc</code></p></li>
<li><p><code>perldoc</code></p></li>
<li><p><code>perldoc</code></p></li>
<li><p><code>perldoc</code></p></li>
</ul>
<p>Ejecución con el depurador:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl -wd c2f.pl
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h&#39; for help, or `man perldebug&#39; for more help.
main::(c2f.pl:4):       print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
DB&lt;1&gt; c 8
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB&lt;2&gt; n
main::(c2f.pl:12):        my $InputNum = $1;
DB&lt;2&gt; x ($1, $2, $3)
0  32
1  undef
2  &#39;F&#39;
DB&lt;3&gt; use YAPE::Regex::Explain
DB&lt;4&gt; p YAPE::Regex::Explain-&gt;new(&#39;([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$&#39;)-&gt;explain
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: &#39;-&#39;, &#39;+&#39; (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: &#39;0&#39; to &#39;9&#39; (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       &#39;.&#39;
----------------------------------------------------------------------
      [0-9]*                   any character of: &#39;0&#39; to &#39;9&#39; (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you&#39;re using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and &quot; &quot;) (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: &#39;C&#39;, &#39;F&#39;
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$  &lt;span  class=&quot;dbuser&quot;&gt;perl -wd c2f.pl&lt;/span&gt;
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h&#39; for help, or `man perldebug&#39; for more help.
main::(c2f.pl:4):       print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
DB&lt;1&gt;  &lt;span  class=&quot;dbuser&quot;&gt;c 8&lt;/span&gt;
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB&lt;2&gt;  &lt;span  class=&quot;dbuser&quot;&gt;n&lt;/span&gt;
main::(c2f.pl:12):        my $InputNum = $1;
DB&lt;2&gt;  &lt;span  class=&quot;dbuser&quot;&gt;x ($1, $2, $3)&lt;/span&gt;
0  32
1  undef
2  &#39;F&#39;
DB&lt;3&gt;  &lt;span  class=&quot;dbuser&quot;&gt;use YAPE::Regex::Explain&lt;/span&gt;
DB&lt;4&gt;  &lt;span  class=&quot;dbuser&quot;&gt;p YAPE::Regex::Explain-&gt;new(&#39;([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$&#39;)-&gt;explain&lt;/span&gt;
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: &#39;-&#39;, &#39;+&#39; (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: &#39;0&#39; to &#39;9&#39; (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       &#39;.&#39;
----------------------------------------------------------------------
      [0-9]*                   any character of: &#39;0&#39; to &#39;9&#39; (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you&#39;re using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and &quot; &quot;) (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: &#39;C&#39;, &#39;F&#39;
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
&lt;/pre&gt;</code></pre>
<p>[section:dolar1] Dentro de una expresión regular es necesario referirse a los textos que casan con el primer, paréntesis, segundo, etc. como <code>\1</code>, <code>\2,</code> etc. La notación <code>$1</code> se refieré a lo que casó con el primer paréntesis en el último <em>matching</em>, no en el actual. Veamos un ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $a = &quot;hola juanito&quot;;
   5    my $b = &quot;adios anita&quot;;
   6  
   7    $a =~ /(ani)/;
   8    $b =~ s/(adios) *($1)/\U$1 $2/;
   9    print &quot;$b\n&quot;;</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;hola juanito&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;adios anita&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;ani&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;s/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;adios&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;*(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\U&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Observe como el <code>$1</code> que aparece en la cadena de reemplazo (línea 8) se refiere a la cadena <code>adios</code> mientras que el <code>$1</code> en la primera parte contiene <code>ani</code>:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./dollar1slash1.pl
ADIOS ANIta</code></pre>
<p>Indique cuál es la salida del programa anterior si se sustituye la línea 8 por</p>
<pre><code>$b =~ s/(adios) *(\1)/\U$1 $2/;</code></pre>
<p>El número de paréntesis con memoria no está limitado:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
            123456789ABCDEF
DB&lt;1&gt; $x = &quot;123456789AAAAAA&quot;
                   1  2  3  4  5  6  7  8  9 10 11  12
DB&lt;2&gt; $r = $x =~ /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/; print &quot;$r\n$10\n$11\n&quot;
1
A
A</code></pre>
<p>Véase el siguiente párrafo de (sección Capture buffers):</p>
<blockquote>
<p>There is no limit to the number of captured substrings that you may use. However Perl also uses <code>\10</code>, <code>\11</code>, etc. as aliases for <code>\010</code>, <code>\011</code>, etc. (Recall that <code>0</code> means octal, so <code>\011</code> is the character at number <code>9</code> in your coded character set; which would be the 10th character, a horizontal tab under ASCII.) Perl resolves this ambiguity by interpreting <code>\10</code> as a backreference only if at least <code>10</code> left parentheses have opened before it. Likewise <code>\11</code> is a backreference only if at least <code>11</code> left parentheses have opened before it. And so on. <code>\1</code> through <code>\9</code> are always interpreted as backreferences.</p>
</blockquote>
<p>Si se utiliza en un contexto que requiere una lista, el “pattern match” retorna una lista consistente en las subexpresiones casadas mediante los paréntesis, esto es <code>$1</code>, <code>$2</code>, <code>$3</code>, …. Si no hubiera emparejamiento se retorna la lista vacía. Si lo hubiera pero no hubieran paréntesis se retorna la lista <code>($&amp;)</code>.</p>
<pre><code>pl@nereida:~/src/perl/perltesting$ cat -n escapes.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $foo = &quot;one two three four five\nsix seven&quot;;
     5  my ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/);
     6  print &quot;List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n&quot;;
     7
     8  # This is &#39;almost&#39; the same than:
     9  ($F1, $F2, $Etc) = split(/\s+/, $foo, 3);
    10  print &quot;Split: F1 = $F1, F2 = $F2, Etc = $Etc\n&quot;;</code></pre>
<p>Observa el resultado de la ejecución:</p>
<pre><code>pl@nereida:~/src/perl/perltesting$ ./escapes.pl
List Context: F1 = one, F2 = two, Etc = three four five
Split: F1 = one, F2 = two, Etc = three four five
six seven</code></pre>
<p>La opción <code>s</code> usada en una regexp hace que el punto <code>'.'</code> case con el retorno de carro:</p>
<pre><code>pl@nereida:~/src/perl/perltesting$ perl -wd ./escapes.pl
main::(./escapes.pl:4): my $foo = &quot;one two three four five\nsix seven&quot;;
DB&lt;1&gt; c 9
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(&#39; &#39;,$foo, 3);
DB&lt;2&gt; ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)
DB&lt;3&gt; p &quot;List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n&quot;
List Context: F1 = one, F2 = two, Etc = three four five
six seven</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/src/perl/perltesting$  &lt;span  class=&quot;dbuser&quot;&gt;perl -wd ./escapes.pl&lt;/span&gt;
main::(./escapes.pl:4): my $foo = &quot;one two three four five\nsix seven&quot;;
DB&lt;1&gt;  &lt;span  class=&quot;dbuser&quot;&gt;c 9&lt;/span&gt;
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(&#39; &#39;,$foo, 3);
DB&lt;2&gt;  &lt;span  class=&quot;dbuser&quot;&gt;($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)&lt;/span&gt;
DB&lt;3&gt;  &lt;span  class=&quot;dbuser&quot;&gt;p &quot;List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n&quot;&lt;/span&gt;
List Context: F1 = one, F2 = two, Etc = three four five
six seven
&lt;/pre&gt;</code></pre>
<p>La opción <code>/s</code> hace que <code>.</code> se empareje con un <code>\n</code>. Esto es, casa con cualquier carácter.</p>
<p>Veamos otro ejemplo, que imprime los nombres de los ficheros que contienen cadenas que casan con un patrón dado, incluso si este aparece disperso en varias líneas:</p>
<pre><code>   1   #!/usr/bin/perl -w
   2   #use: 
   3   #smodifier.pl &#39;expr&#39; files
   4   #prints the names of the files that match with the give expr
   5   undef $/; # input record separator
   6   my $what = shift @ARGV;
   7   while(my $file = shift @ARGV) {
   8     open(FILE, &quot;&lt;$file&quot;);
   9     $line =  &lt;FILE&gt;;
  10     if ($line =~ /$what/s) {
  11       print &quot;$file\n&quot;;
  12     }
  13   }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;  &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;  &lt;span class=&quot;synComment&quot;&gt;#use: &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;  &lt;span class=&quot;synComment&quot;&gt;#smodifier.pl &#39;expr&#39; files&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;  &lt;span class=&quot;synComment&quot;&gt;#prints the names of the files that match with the give expr&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;undef&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt;; &lt;span class=&quot;synComment&quot;&gt;# input record separator&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$what&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@ARGV&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$file&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@ARGV&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;    &lt;span class=&quot;synStatement&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;FILE&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;    &lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt; =  &lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;FILE&amp;gt;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;    &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$what&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/s&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;      &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;    }
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;  }
&lt;/pre&gt;</code></pre>
<p>Ejemplo de uso:</p>
<pre><code>&gt; smodifier.pl &#39;three.*three&#39; double.in split.pl doublee.pl
double.in
doublee.pl </code></pre>
<p>Vea la sección [section:repetidas] para ver los contenidos del fichero <code>double.in</code>. En dicho fichero, el patrón <code>three.*three</code> aparece repartido entre varias líneas.</p>
<p>El modificador <code>s</code> se suele usar conjuntamente con el modificador <code>m</code>. He aquí lo que dice la seccion <span><em>Using character classes</em></span> de al respecto:</p>
<blockquote>
<ul>
<li><p><code>m</code> modifier (<code>//m</code>): Treat string as a set of multiple lines. <code>'.'</code> matches any character except <code>\n</code>. <code>^</code> and <code>$</code> are able to match at the start or end of any line within the string.</p></li>
<li><p>both <code>s</code> and <code>m</code> modifiers (<code>//sm</code>): Treat string as a single long line, but detect multiple lines. <code>'.'</code> matches any character, even <code>\n</code> . <code>^</code> and <code>$</code> , however, are able to match at the start or end of any line within the string.</p></li>
</ul>
<p>Here are examples of //s and //m in action:</p>
<pre><code>   1. $x = &quot;There once was a girl\nWho programmed in Perl\n&quot;;
   2.
   3. $x =~ /^Who/; # doesn&#39;t match, &quot;Who&quot; not at start of string
   4. $x =~ /^Who/s; # doesn&#39;t match, &quot;Who&quot; not at start of string
   5. $x =~ /^Who/m; # matches, &quot;Who&quot; at start of second line
   6. $x =~ /^Who/sm; # matches, &quot;Who&quot; at start of second line
   7.
   8. $x =~ /girl.Who/; # doesn&#39;t match, &quot;.&quot; doesn&#39;t match &quot;\n&quot;
   9. $x =~ /girl.Who/s; # matches, &quot;.&quot; matches &quot;\n&quot;
  10. $x =~ /girl.Who/m; # doesn&#39;t match, &quot;.&quot; doesn&#39;t match &quot;\n&quot;
  11. $x =~ /girl.Who/sm; # matches, &quot;.&quot; matches &quot;\n&quot;</code></pre>
<p>Most of the time, the default behavior is what is wanted, but <code>//s</code> and <code>//m</code> are occasionally very useful. If <code>//m</code> is being used, the start of the string can still be matched with <code>\A</code> and the end of the string can still be matched with the anchors <code>\Z</code> (matches both the end and the newline before, like <code>$</code>), and <code>\z</code> (matches only the end):</p>
<pre><code>   1. $x =~ /^Who/m; # matches, &quot;Who&quot; at start of second line
   2. $x =~ /\AWho/m; # doesn&#39;t match, &quot;Who&quot; is not at start of string
   3.
   4. $x =~ /girl$/m; # matches, &quot;girl&quot; at end of first line
   5. $x =~ /girl\Z/m; # doesn&#39;t match, &quot;girl&quot; is not at end of string
   6.
   7. $x =~ /Perl\Z/m; # matches, &quot;Perl&quot; is at newline before end
   8. $x =~ /Perl\z/m; # doesn&#39;t match, &quot;Perl&quot; is not at end of string</code></pre>
</blockquote>
<p>Normalmente el carácter <code>^</code> casa solamente con el comienzo de la cadena y el carácter <code>$</code> con el final. Los <code>\n</code> empotrados no casan con <code>^</code> ni <code>$</code>. El modificador <code>/m</code> modifica esta conducta. De este modo <code>^</code> y <code>$</code> casan con cualquier frontera de línea interna. Las anclas <code>\A</code> y <code>\Z</code> se utilizan entonces para casar con el comienzo y final de la cadena. Véase un ejemplo:</p>
<pre><code>nereida:~/perl/src&gt; perl -de 0
  DB&lt;1&gt; $a = &quot;hola\npedro&quot;
  DB&lt;2&gt; p &quot;$a&quot;
hola
pedro
  DB&lt;3&gt; $a =~ s/.*/x/m
  DB&lt;4&gt; p $a
x
pedro
  DB&lt;5&gt; $a =~ s/^pedro$/juan/
  DB&lt;6&gt; p &quot;$a&quot;
x
pedro
  DB&lt;7&gt; $a =~ s/^pedro$/juan/m
  DB&lt;8&gt;  p &quot;$a&quot;
x
juan</code></pre>
<p>Reescribamos el ejemplo anterior usando un contexto de lista:</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
  5    my $input = &lt;STDIN&gt;;
  6    chomp($input);
  7  
  8    my ($InputNum, $type);
  9  
 10    ($InputNum, $type) = $input =~ m/^
 11                                        ([-+]?[0-9]+(?:\.[0-9]*)?) # Temperature
 12                                        \s*
 13                                        ([cCfF]) # Celsius or Farenheit
 14                                     $/x;
 15  
 16    die &quot;Expecting a temperature, so don&#39;t understand \&quot;$input\&quot;.\n&quot; unless defined($InputNum);
 17  
 18    my ($celsius, $fahrenheit);
 19    if ($type eq &quot;C&quot; or $type eq &quot;c&quot;) {
 20      $celsius = $InputNum;
 21      $fahrenheit = ($celsius * 9/5)+32;
 22    }
 23    else {
 24      $fahrenheit = $InputNum;
 25      $celsius = ($fahrenheit -32)*5/9;
 26    }
 27    printf &quot;%.2f C = %.2f F\n&quot;, $celsius, $fahrenheit;</code></pre>
<pre><code>
&lt;pre&gt;
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Enter a temperature (i.e. 32F, 100C):&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   (&lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt;) = &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;^&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([-+]?[0-9]+(?:\.[0-9]*)?)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; # Temperature&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([cCfF])&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; # Celsius or Farenheit&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                   $&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Expecting a temperature, so don&#39;t understand &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;defined&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$fahrenheit&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$type&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$fahrenheit&lt;/span&gt; = (&lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; * &lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;/&lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;synConstant&quot;&gt;+32&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$fahrenheit&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$InputNum&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt; = (&lt;span class=&quot;synIdentifier&quot;&gt;$fahrenheit&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;-32&lt;/span&gt;)*&lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;/&lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;%.2f C = %.2f F&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$celsius&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$fahrenheit&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>[section:x] La opción <code>/x</code> en una regexp permite utilizar comentarios y espacios dentro de la expresión regular. Los espacios dentro de la expresión regular dejan de ser significativos. Si quieres conseguir un espacio que sea significativo, usa <code>\s</code> o bien escápalo. Véase y .</p>
<p>La notación <code>(?: ... )</code> se usa para introducir paréntesis de agrupamiento sin memoria. <code>(?: ...)</code> Permite agrupar las expresiones tal y como lo hacen los paréntesis ordinarios. La diferencia es que no “memorizan” esto es no guardan nada en <code>$1</code>, <code>$2</code>, etc. Se logra así una compilación mas eficiente. Veamos un ejemplo:</p>
<pre><code>&gt; cat groupingpar.pl
#!/usr/bin/perl

  my $a = shift;

  $a =~ m/(?:hola )*(juan)/;
  print &quot;$1\n&quot;;
nereida:~/perl/src&gt; groupingpar.pl &#39;hola juan&#39;
juan</code></pre>
<p>El patrón regular puede contener variables, que serán interpoladas (en tal caso, el patrón será recompilado). Si quieres que dicho patrón se compile una sóla vez, usa la opción <code>/o</code>.</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n mygrep.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die &quot;Usage $0 regexp files ...\n&quot;;
     3  while (&lt;&gt;) {
     4    print &quot;File $ARGV, rel. line $.: $_&quot; if (/$what/o); # compile only once
     5  }
     6</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./mygrep.pl
Usage ./mygrep.pl regexp files ...
pl@nereida:~/Lperltesting$ ./mygrep.pl if labels.c
File labels.c, rel. line 7:        if (a &lt; 10) goto LABEL;</code></pre>
<p>El siguiente texto es de :</p>
<blockquote>
<p>If <code>$pattern</code> won’t be changing over the lifetime of the script, we can add the //o modifier, which directs Perl to only perform variable substitutions once</p>
</blockquote>
<p>Otra posibilidad es hacer una compilación previa usando el operador <code>qr</code> (véase ). La siguiente variante del programa anterior también compila el patrón una sóla vez:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n mygrep2.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die &quot;Usage $0 regexp files ...\n&quot;;
     3  $what = qr{$what};
     4  while (&lt;&gt;) {
     5    print &quot;File $ARGV, rel. line $.: $_&quot; if (/$what/);
     6  }</code></pre>
<p>Véase</p>
<ul>
<li><p>El nodo en perlmonks por</p></li>
</ul>
<p>El siguiente extracto de la sección <span><em>Matching Repetitions</em></span> en ilustra la semántica <span><em>greedy</em></span> de los operadores de repetición <code>*+{}?</code> etc.</p>
<blockquote>
<p>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with <code>/a?.../</code>, Perl will first try to match the regexp with the a present; if that fails, Perl will try to match the regexp without the a present. For the quantifier <code>*</code> , we get the following:</p>
<pre><code>   1. $x = &quot;the cat in the hat&quot;;
   2. $x =~ /^(.*)(cat)(.*)$/; # matches,
   3. # $1 = &#39;the &#39;
   4. # $2 = &#39;cat&#39;
   5. # $3 = &#39; in the hat&#39;</code></pre>
<p>Which is what we might expect, the match finds the only cat in the string and locks onto it. Consider, however, this regexp:</p>
<pre><code>   1. $x =~ /^(.*)(at)(.*)$/; # matches,
   2. # $1 = &#39;the cat in the h&#39;
   3. # $2 = &#39;at&#39;
   4. # $3 = &#39;&#39; (0 characters match)</code></pre>
<p>One might initially guess that Perl would find the <code>at</code> in <code>cat</code> and stop there, but that wouldn’t give the longest possible string to the first quantifier <code>.*</code>. Instead, the first quantifier <code>.*</code> grabs as much of the string as possible while still having the regexp match. In this example, that means having the <code>at</code> sequence with the final <code>at</code> in the string.</p>
<p>The other important principle illustrated here is that when there are two or more elements in a regexp, the leftmost quantifier, if there is one, gets to grab as much the string as possible, leaving the rest of the regexp to fight over scraps. Thus in our example, the first quantifier <code>.*</code> grabs most of the string, while the second quantifier <code>.*</code> gets the empty string. Quantifiers that grab as much of the string as possible are called maximal match or greedy quantifiers.</p>
<p>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</p>
<ul>
<li><p><span><strong>Principle 0:</strong></span> Taken as a whole, any regexp will be matched at the earliest possible position in the string.</p></li>
<li><p><span><strong>Principle 1:</strong></span> In an alternation <code>a|b|c...</code> , the leftmost alternative that allows a match for the whole regexp will be the one used.</p></li>
<li><p><span><strong>Principle 2:</strong></span> The maximal matching quantifiers <code>?</code>, <code>*</code>, <code>+</code> and <code>{n,m}</code> will in general match as much of the string as possible while still allowing the whole regexp to match.</p></li>
<li><p><span><strong>Principle 3:</strong></span> If there are two or more elements in a regexp, the leftmost greedy quantifier, if any, will match as much of the string as possible while still allowing the whole regexp to match. The next leftmost greedy quantifier, if any, will try to match as much of the string remaining available to it as possible, while still allowing the whole regexp to match. And so on, until all the regexp elements are satisfied.</p></li>
</ul>
</blockquote>
<p>El siguiente párrafo está tomado de :</p>
<blockquote>
<p>Regular expressions provide a terse and powerful programming language. As with most other power tools, power comes together with the ability to wreak havoc.</p>
<p>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</p>
<pre><code>   1. &#39;foo&#39; =~ m{ ( o? )* }x;</code></pre>
<p>The <code>o?</code> matches at the beginning of <code>'foo'</code> , and since the position in the string is not moved by the match, <code>o?</code> would match again and again because of the <code>*</code> quantifier.</p>
<p>Another common way to create a similar cycle is with the looping modifier <code>//g</code> :</p>
<pre><code>   1. @matches = ( &#39;foo&#39; =~ m{ o? }xg );</code></pre>
<p>or</p>
<pre><code>   1. print &quot;match: &lt;$&amp;&gt;\n&quot; while &#39;foo&#39; =~ m{ o? }xg;</code></pre>
<p>or the loop implied by <code>split()</code>.</p>
<p>... Perl allows such constructs, by forcefully breaking the infinite loop. The rules for this are different for lower-level loops given by the greedy quantifiers <code>*+{}</code> , and for higher-level ones like the <code>/g</code> modifier or <code>split()</code> operator.</p>
<p>The lower-level loops are interrupted (that is, the loop is broken) when Perl detects that a repeated expression matched a zero-length substring. Thus</p>
<pre><code>   1.  m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;</code></pre>
<p>is made equivalent to</p>
<pre><code>   1.  m{ (?: NON_ZERO_LENGTH )*
   2.  |
   3.  (?: ZERO_LENGTH )?
   4.  }x;</code></pre>
<p>The higher level-loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see Backtracking), and so the second best match is chosen if the best match is of zero length.</p>
<p>For example:</p>
<pre><code>   1. $_ = &#39;bar&#39;;
   2. s/\w??/&lt;$&amp;&gt;/g;</code></pre>
<p>results in <code>&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;</code> . At each position of the string the best match given by non-greedy <code>??</code> is the zero-length match, and the second best match is what is matched by <code>\w</code> . Thus zero-length matches alternate with one-character-long matches.</p>
<p>Similarly, for repeated <code>m/()/g</code> the second-best match is the match at the position one notch further in the string.</p>
<p>The additional state of being matched with zero-length is associated with the matched string, and is reset by each assignment to <code>pos()</code>. Zero-length matches at the end of the previous match are ignored during <code>split</code>.</p>
</blockquote>
<ul>
<li><p>Explique la conducta del siguiente matching:</p>
<pre><code>  DB&lt;25&gt; $c = 0

  DB&lt;26&gt;  print(($c++).&quot;: &lt;$&amp;&gt;\n&quot;) while &#39;aaaabababab&#39; =~ /a*(ab)*/g;
0: &lt;aaaa&gt;
1: &lt;&gt;
2: &lt;a&gt;
3: &lt;&gt;
4: &lt;a&gt;
5: &lt;&gt;
6: &lt;a&gt;
7: &lt;&gt;
8: &lt;&gt;</code></pre>
<pre><code>&lt;pre&gt;
  DB&amp;lt;25&gt;  &lt;span class=&quot;dbuser&quot;&gt;$c = 0&lt;/span&gt;

  DB&amp;lt;26&gt;  &lt;span class=&quot;dbuser&quot;&gt; print(($c++).&quot;: &amp;lt;$&amp;&gt;\n&quot;) while &#39;aaaabababab&#39; =~ /a*(ab)*/g;&lt;/span&gt;
0: &amp;lt;aaaa&gt;
1: &amp;lt;&gt;
2: &amp;lt;a&gt;
3: &amp;lt;&gt;
4: &amp;lt;a&gt;
5: &amp;lt;&gt;
6: &amp;lt;a&gt;
7: &amp;lt;&gt;
8: &amp;lt;&gt;
&lt;/pre&gt;</code></pre></li>
</ul>
<p>[section:nogreedy] Las expresiones <em>lazy</em> o <em>no greedy</em> hacen que el NFA se detenga en la cadena mas corta que casa con la expresión. Se denotan como sus análogas <em>greedy</em> añadiéndole el postfijo <code>?</code>:</p>
<ul>
<li><p><code>{n,m}?</code></p></li>
<li><p><code>{n,}?</code></p></li>
<li><p><code>{n}?</code></p></li>
<li><p><code>*?</code></p></li>
<li><p><code>+?</code></p></li>
<li><p><code>??</code></p></li>
</ul>
<p>Repasemos lo que dice la sección Matching Repetitions en :</p>
<blockquote>
<p>Sometimes greed is not good. At times, we would like quantifiers to match a minimal piece of string, rather than a maximal piece. For this purpose, Larry Wall created the minimal match or non-greedy quantifiers <code>??</code> ,<code>*?</code>, <code>+?</code>, and <code>{}?</code>. These are the usual quantifiers with a ? appended to them. They have the following meanings:</p>
<ul>
<li><p><code>a??</code> means: match ’a’ 0 or 1 times. Try 0 first, then 1.</p></li>
<li><p><code>a*?</code> means: match ’a’ 0 or more times, i.e., any number of times, but as few times as possible</p></li>
<li><p><code>a+?</code> means: match ’a’ 1 or more times, i.e., at least once, but as few times as possible</p></li>
<li><p><code>a{n,m}?</code> means: match at least n times, not more than m times, as few times as possible</p></li>
<li><p><code>a{n,}?</code> means: match at least n times, but as few times as possible</p></li>
<li><p><code>a{n}?</code> means: match exactly n times. Because we match exactly n times, a<span>n</span>? is equivalent to a<span>n</span> and is just there for notational consistency.</p></li>
</ul>
<p>Let’s look at the example above, but with minimal quantifiers:</p>
<pre><code>   1. $x = &quot;The programming republic of Perl&quot;;
   2. $x =~ /^(.+?)(e|r)(.*)$/; # matches,
   3. # $1 = &#39;Th&#39;
   4. # $2 = &#39;e&#39;
   5. # $3 = &#39; programming republic of Perl&#39;</code></pre>
<p>The minimal string that will allow both the start of the string <code>^</code> and the alternation to match is <code>Th</code> , with the alternation <code>e|r</code> matching <code>e</code>. The second quantifier <code>.*</code> is free to gobble up the rest of the string.</p>
<pre><code>   1. $x =~ /(m{1,2}?)(.*?)$/; # matches,
   2. # $1 = &#39;m&#39;
   3. # $2 = &#39;ming republic of Perl&#39;</code></pre>
<p>The first string position that this regexp can match is at the first <code>m</code> in programming . At this position, the minimal <code>m{1,2}?</code> matches just one <code>m</code> . Although the second quantifier <code>.*?</code> would prefer to match no characters, it is constrained by the end-of-string anchor <code>$</code> to match the rest of the string.</p>
<pre><code>   1. $x =~ /(.*?)(m{1,2}?)(.*)$/; # matches,
   2. # $1 = &#39;The progra&#39;
   3. # $2 = &#39;m&#39;
   4. # $3 = &#39;ming republic of Perl&#39;</code></pre>
<p>In this regexp, you might expect the first minimal quantifier <code>.*?</code> to match the empty string, because it is not constrained by a <code>^</code> anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it will match at the start of the string. Thus the first quantifier has to match everything up to the first m. The second minimal quantifier matches just one <code>m</code> and the third quantifier matches the rest of the string.</p>
<pre><code>   1. $x =~ /(.??)(m{1,2})(.*)$/; # matches,
   2. # $1 = &#39;a&#39;
   3. # $2 = &#39;mm&#39;
   4. # $3 = &#39;ing republic of Perl&#39;</code></pre>
<p>Just as in the previous regexp, the first quantifier <code>.??</code> can match earliest at position <code>a</code> , so it does. The second quantifier is greedy, so it matches mm , and the third matches the rest of the string.</p>
<p>We can modify principle 3 above to take into account non-greedy quantifiers:</p>
<ul>
<li><p><span><strong>Principle 3:</strong></span> If there are two or more elements in a regexp, the leftmost greedy (non-greedy) quantifier, if any, will match as much (little) of the string as possible while still allowing the whole regexp to match. The next leftmost greedy (non-greedy) quantifier, if any, will try to match as much (little) of the string remaining available to it as possible, while still allowing the whole regexp to match. And so on, until all the regexp elements are satisfied.</p></li>
</ul>
</blockquote>
<p>Explique cuál será el resultado de el segundo comando de matching introducido en el depurador:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x (&#39;1&#39;x34) =~ m{^(11+)\1+$}
0  11111111111111111
  DB&lt;2&gt; x (&#39;1&#39;x34) =~ m{^(11+?)\1+$}
????????????????????????????????????</code></pre>
<p>Veamos en detalle lo que ocurre durante un matching. Repasemos lo que dice la sección Matching Repetitions en :</p>
<blockquote>
<p>Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example</p>
<pre><code>   1. $x = &quot;the cat in the hat&quot;;
   2. $x =~ /^(.*)(at)(.*)$/; # matches,
   3. # $1 = &#39;the cat in the h&#39;
   4. # $2 = &#39;at&#39;
   5. # $3 = &#39;&#39; (0 matches)</code></pre>
<ol>
<li><p>Start with the first letter in the string ’t’.</p></li>
<li><p>The first quantifier ’.*’ starts out by matching the whole string ’the cat in the hat’.</p></li>
<li><p>’a’ in the regexp element ’at’ doesn’t match the end of the string. Backtrack one character.</p></li>
<li><p>’a’ in the regexp element ’at’ still doesn’t match the last letter of the string ’t’, so backtrack one more character.</p></li>
<li><p>Now we can match the ’a’ and the ’t’.</p></li>
<li><p>Move on to the third element ’.*’. Since we are at the end of the string and ’.*’ can match 0 times, assign it the empty string.</p></li>
<li><p>We are done!</p></li>
</ol>
</blockquote>
<p>La forma en la que se escribe una regexp puede dar lugar agrandes variaciones en el rendimiento. Repasemos lo que dice la sección Matching Repetitions en :</p>
<blockquote>
<p>Most of the time, all this moving forward and backtracking happens quickly and searching is fast. There are some pathological regexps, however, whose execution time exponentially grows with the size of the string. A typical structure that blows up in your face is of the form</p>
<pre><code>            /(a|b+)*/;</code></pre>
<p>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the <code>+</code> and <code>*</code>: one repetition with <code>b+</code> of length <span class="math"><em>n</em></span>, two repetitions with the first <code>b+</code> length <span class="math"><em>k</em></span> and the second with length <span class="math"><em>n</em> − <em>k</em></span>, <span class="math"><em>m</em></span> repetitions whose bits add up to length <span class="math"><em>n</em></span>, etc.</p>
<p>In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try every possibility before giving up. So be careful with nested <code>*</code>’s, <code>{n,m}</code>’s, and <code>+</code> ’s.</p>
<p>The book by Jeffrey Friedl <span class="citation"></span> gives a wonderful discussion of this and other efficiency issues.</p>
</blockquote>
<p>[parrfo:comments]</p>
<p>El siguiente ejemplo elimina los comentarios de un programa <code>C</code>.</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n comments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die &quot;Usage:\n$0 prog.c\n&quot;;
   5    open(my $PROGRAM,&quot;&lt;$progname&quot;) || die &quot;can&#39;t find $progname\n&quot;;
   6    my $program = &#39;&#39;;
   7    {
   8      local $/ = undef;
   9      $program = &lt;$PROGRAM&gt;;
  10    }
  11    $program =~ s{
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15    }[]gsx;
  16  
  17    print $program;</code></pre>
<pre><code>
&lt;pre&gt;
casiano@millo:~/Lperltesting$ cat -n comments.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@ARGV&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Usage:&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; prog.c&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$PROGRAM&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;) || &lt;span class=&quot;synStatement&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;can&#39;t find &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   {
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;undef&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; = &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$PROGRAM&lt;/span&gt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;s{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # Match the opening delimiter&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.*?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # Match a minimal number of characters&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/  # Match the closing delimiter&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}&lt;/span&gt;[]gsx;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Veamos un ejemplo de ejecución. Supongamos el fichero de entrada:</p>
<pre><code>&gt; cat hello.c
#include &lt;stdio.h&gt;
/* first
comment
*/
main() {
  printf(&quot;hello world!\n&quot;); /* second comment */
}</code></pre>
<p>Entonces la ejecución con ese fichero de entrada produce la salida:</p>
<pre><code>&gt; comments.pl hello.c
#include &lt;stdio.h&gt;
 
main() {
  printf(&quot;hello world!\n&quot;);
}</code></pre>
<p>Veamos la diferencia de comportamiento entre <code>*</code> y <code>*?</code> en el ejemplo anterior:</p>
<pre><code>pl@nereida:~/src/perl/perltesting$ perl5_10_1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt;  use re &#39;debug&#39;; &#39;main() /* 1c */ { /* 2c */ return; /* 3c */ }&#39; =~ qr{(/\*.*\*/)}; print &quot;\n$1\n&quot;
Compiling REx &quot;(/\*.*\*/)&quot;
Final program:
   1: OPEN1 (3)
   3:   EXACT &lt;/*&gt; (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT &lt;*/&gt; (9)
   9: CLOSE1 (11)
  11: END (0)
anchored &quot;/*&quot; at 0 floating &quot;*/&quot; at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx &quot;(/\*.*\*/)&quot; against &quot;main() /* 1c */ { /* 2c */ return; /* 3c */ }&quot;
Found floating substr &quot;*/&quot; at offset 13...
Found anchored substr &quot;/*&quot; at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx &quot;(/\*.*\*/)&quot; against &quot;/* 1c */ { /* 2c */ return; /* 3c */ }&quot;
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  1:OPEN1(3)
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  3:EXACT &lt;/*&gt;(5)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 &lt;; /* 3c &gt; &lt;*/ }&gt;       |  7:  EXACT &lt;*/&gt;(9)
  43 &lt;; /* 3c */&gt; &lt; }&gt;       |  9:  CLOSE1(11)
  43 &lt;; /* 3c */&gt; &lt; }&gt;       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: &quot;(/\*.*\*/)&quot;

  DB&lt;2&gt;  use re &#39;debug&#39;; &#39;main() /* 1c */ { /* 2c */ return; /* 3c */ }&#39; =~ qr{(/\*.*?\*/)}; print &quot;\n$1\n&quot;
Compiling REx &quot;(/\*.*?\*/)&quot;
Final program:
   1: OPEN1 (3)
   3:   EXACT &lt;/*&gt; (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT &lt;*/&gt; (10)
  10: CLOSE1 (12)
  12: END (0)
anchored &quot;/*&quot; at 0 floating &quot;*/&quot; at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx &quot;(/\*.*?\*/)&quot; against &quot;main() /* 1c */ { /* 2c */ return; /* 3c */ }&quot;
Found floating substr &quot;*/&quot; at offset 13...
Found anchored substr &quot;/*&quot; at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx &quot;(/\*.*?\*/)&quot; against &quot;/* 1c */ { /* 2c */ return; /* 3c */ }&quot;
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  1:OPEN1(3)
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  3:EXACT &lt;/*&gt;(5)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  5:MINMOD(6)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 &lt;* 1c &gt; &lt;*/ { /* 2c&gt;    |  8:  EXACT &lt;*/&gt;(10)
  15 &lt;1c */&gt; &lt; { /* 2c *&gt;    | 10:  CLOSE1(12)
  15 &lt;1c */&gt; &lt; { /* 2c *&gt;    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: &quot;(/\*.*?\*/)&quot;

  DB&lt;3&gt;</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/src/perl/perltesting$  &lt;span class=&quot;dbuser&quot;&gt;perl5_10_1 -wde 0&lt;/span&gt;
main::(-e:1):   0
  DB&lt;1&gt;  &lt;span class=&quot;dbuser&quot;&gt; use re &#39;debug&#39;; &#39;main() /* 1c */ { /* 2c */ return; /* 3c */ }&#39; =~ qr{(/\*.*\*/)}; print &quot;\n$1\n&quot;&lt;/span&gt;
Compiling REx &quot;(/\*.*\*/)&quot;
Final program:
   1: OPEN1 (3)
   3:   EXACT &lt;/*&gt; (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT &lt;*/&gt; (9)
   9: CLOSE1 (11)
  11: END (0)
anchored &quot;/*&quot; at 0 floating &quot;*/&quot; at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx &quot;(/\*.*\*/)&quot; against &quot;main() /* 1c */ { /* 2c */ return; /* 3c */ }&quot;
Found floating substr &quot;*/&quot; at offset 13...
Found anchored substr &quot;/*&quot; at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx &quot;(/\*.*\*/)&quot; against &quot;/* 1c */ { /* 2c */ return; /* 3c */ }&quot;
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  1:OPEN1(3)
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  3:EXACT &lt;/*&gt;(5)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 &lt;; /* 3c &gt; &lt;*/ }&gt;       |  7:  EXACT &lt;*/&gt;(9)
  43 &lt;; /* 3c */&gt; &lt; }&gt;       |  9:  CLOSE1(11)
  43 &lt;; /* 3c */&gt; &lt; }&gt;       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: &quot;(/\*.*\*/)&quot;

  DB&lt;2&gt;  &lt;span class=&quot;dbuser&quot;&gt; use re &#39;debug&#39;; &#39;main() /* 1c */ { /* 2c */ return; /* 3c */ }&#39; =~ qr{(/\*.*?\*/)}; print &quot;\n$1\n&quot;&lt;/span&gt;
Compiling REx &quot;(/\*.*?\*/)&quot;
Final program:
   1: OPEN1 (3)
   3:   EXACT &lt;/*&gt; (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT &lt;*/&gt; (10)
  10: CLOSE1 (12)
  12: END (0)
anchored &quot;/*&quot; at 0 floating &quot;*/&quot; at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx &quot;(/\*.*?\*/)&quot; against &quot;main() /* 1c */ { /* 2c */ return; /* 3c */ }&quot;
Found floating substr &quot;*/&quot; at offset 13...
Found anchored substr &quot;/*&quot; at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx &quot;(/\*.*?\*/)&quot; against &quot;/* 1c */ { /* 2c */ return; /* 3c */ }&quot;
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  1:OPEN1(3)
   7 &lt;in() &gt; &lt;/* 1c */ {&gt;    |  3:EXACT &lt;/*&gt;(5)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  5:MINMOD(6)
   9 &lt;() /*&gt; &lt; 1c */ { /&gt;    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 &lt;* 1c &gt; &lt;*/ { /* 2c&gt;    |  8:  EXACT &lt;*/&gt;(10)
  15 &lt;1c */&gt; &lt; { /* 2c *&gt;    | 10:  CLOSE1(12)
  15 &lt;1c */&gt; &lt; { /* 2c *&gt;    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: &quot;(/\*.*?\*/)&quot;

  DB&lt;3&gt;
&lt;/pre&gt;</code></pre>
<p>Véase también la documentación en y .</p>
<p>A menudo las expresiones <code>X[^X]*X</code> y <code>X.*?X</code>, donde <code>X</code> es un carácter arbitrario se usan de forma casi equivalente.</p>
<ul>
<li><p>La primera significa:</p>
<p>Una cadena que no contiene <code>X</code> en su interior y que está delimitada por <code>X</code>s</p></li>
<li><p>La segunda significa:</p>
<p>Una cadena que comienza en <code>X</code> y termina en la <code>X</code> mas próxima a la <code>X</code> de comienzo</p></li>
</ul>
<p>Esta equivalencia se rompe si no se cumplen las hipótesis establecidas.</p>
<p>En el siguiente ejemplo se intentan detectar las cadenas entre comillas dobles que terminan en el signo de exclamación:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n negynogreedy.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $b = &#39;Ella dijo &quot;Ana&quot; y yo contesté: &quot;Jamás!&quot;. Eso fué todo.&#39;;
     5  my $a;
     6  ($a = $b) =~ s/&quot;.*?!&quot;/-$&amp;-/;
     7  print &quot;$a\n&quot;;
     8
     9  $b =~ s/&quot;[^&quot;]*!&quot;/-$&amp;-/;
    10  print &quot;$b\n&quot;;</code></pre>
<p>Al ejecutar el programa obtenemos:</p>
<pre><code>&gt; negynogreedy.pl
Ella dijo -&quot;Ana&quot; y yo contesté: &quot;Jamás!&quot;-. Eso fué todo.
Ella dijo &quot;Ana&quot; y yo contesté: -&quot;Jamás!&quot;-. Eso fué todo.</code></pre>
<p>[section:copia] El operador de <em>binding</em> <code>=~</code> nos permite “asociar” la variable con la operación de casamiento o sustitución. Si se trata de una sustitución y se quiere conservar la cadena, es necesario hacer una copia:</p>
<pre><code>$d = $s;
$d =~ s/esto/por lo otro/;</code></pre>
<p>en vez de eso, puedes abreviar un poco usando la siguiente “perla”:</p>
<pre><code>($d = $s) =~ s/esto/por lo otro/;</code></pre>
<p>Obsérvese la asociación por la izquierda del operador de asignación.</p>
<p>Las referencias relativas permiten escribir expresiones regulares mas reciclables. Véase la documentación en :</p>
<blockquote>
<p>Counting the opening parentheses to get the correct number for a backreference is errorprone as soon as there is more than one capturing group. A more convenient technique became available with Perl 5.10: relative backreferences. To refer to the immediately preceding capture group one now may write <code>\g{-1}</code> , the next but last is available via <code>\g{-2}</code>, and so on.</p>
<p>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</p>
<pre><code>   1. $a99a = &#39;([a-z])(\d)\2\1&#39;; # matches a11a, g22g, x33x, etc.</code></pre>
<p>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</p>
<pre><code>   1. $line = &quot;code=e99e&quot;;
   2. if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   3.   print &quot;$1 is valid\n&quot;;
   4. } else {
   5.   print &quot;bad line: &#39;$line&#39;\n&quot;;
   6. }</code></pre>
<p>But this doesn’t match – at least not the way one might expect. Only after inserting the interpolated <code>$a99a</code> and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired – the subexpression <code>(\w+)</code> has snatched number 1 and demoted the groups in <code>$a99a</code> by one rank. This can be avoided by using relative backreferences:</p>
<pre><code>   1. $a99a = &#39;([a-z])(\d)\g{-1}\g{-2}&#39;; # safe for being interpolated</code></pre>
</blockquote>
<p>El siguiente programa ilustra lo dicho:</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n backreference.pl
   1    use strict;
   2    use re &#39;debug&#39;;
   3  
   4    my $a99a = &#39;([a-z])(\d)\2\1&#39;;
   5    my $line = &quot;code=e99e&quot;;
   6    if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   7      print &quot;$1 is valid\n&quot;;
   8    } else {
   9      print &quot;bad line: &#39;$line&#39;\n&quot;;
  10    }</code></pre>
<pre><code>
&lt;pre&gt;
casiano@millo:~/Lperltesting$ cat -n backreference.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;re &lt;span class=&quot;synConstant&quot;&gt;&#39;debug&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$a99a&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;([a-z])(\d)\2\1&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;code=e99e&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\w+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$a99a&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;){ &lt;span class=&quot;synComment&quot;&gt;# unexpected behavior!&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is valid&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   } &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;bad line: &#39;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Sigue la ejecución:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl5.10.1 -wd backreference.pl
main::(backreference.pl:4):     my $a99a = &#39;([a-z])(\d)\2\1&#39;;
  DB&lt;1&gt; c 6
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB&lt;2&gt; x ($line =~ /^(\w+)=$a99a$/)
  empty array
  DB&lt;4&gt; $a99a = &#39;([a-z])(\d)\g{-1}\g{-2}&#39;
  DB&lt;5&gt; x ($line =~ /^(\w+)=$a99a$/)
0  &#39;code&#39;
1  &#39;e&#39;
2  9</code></pre>
<pre><code>&lt;pre&gt;
casiano@millo:~/Lperltesting$  &lt;span class=&quot;dbuser&quot;&gt;perl5.10.1 -wd backreference.pl&lt;/span&gt;
main::(backreference.pl:4):     my $a99a = &#39;([a-z])(\d)\2\1&#39;;
  DB&lt;1&gt;  &lt;span class=&quot;dbuser&quot;&gt;c 6&lt;/span&gt;
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB&lt;2&gt;  &lt;span class=&quot;dbuser&quot;&gt;x ($line =~ /^(\w+)=$a99a$/)&lt;/span&gt;
  empty array
  DB&lt;4&gt;  &lt;span class=&quot;dbuser&quot;&gt;$a99a = &#39;([a-z])(\d)\g{-1}\g{-2}&#39;&lt;/span&gt;
  DB&lt;5&gt;  &lt;span class=&quot;dbuser&quot;&gt;x ($line =~ /^(\w+)=$a99a$/)&lt;/span&gt;
0  &#39;code&#39;
1  &#39;e&#39;
2  9
&lt;/pre&gt;</code></pre>
<p>El siguiente texto esta tomado de :</p>
<blockquote>
<p>Perl 5.10 also introduced named capture buffers and named backreferences. To attach a name to a capturing group, you write either <code>(?&lt;name&gt;...)</code> or <code>(?'name'...)</code>. The backreference may then be written as <code>\g{name}</code> .</p>
<p>It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture buffer is accessible through the <code>%+</code> hash.</p>
<p>Assuming that we have to match calendar dates which may be given in one of the three formats <code>yyyy-mm-dd</code>, <code>mm/dd/yyyy</code> or <code>dd.mm.yyyy</code>, we can write three suitable patterns where we use <code>'d'</code>, <code>'m'</code> and <code>'y'</code> respectively as the names of the buffers capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</p>
<pre><code>   1.  $fmt1 = &#39;(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)&#39;;
   2.  $fmt2 = &#39;(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)&#39;;
   3.  $fmt3 = &#39;(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)&#39;;
   4.  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
   5.    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
   6.      print &quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;;
   7.    }
   8.  }</code></pre>
<p>If any of the alternatives matches, the hash <code>%+</code> is bound to contain the three key-value pairs.</p>
</blockquote>
<p>En efecto, al ejecutar el programa:</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n namedbackreferences.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $fmt1 = &#39;(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)&#39;;
     5  my $fmt2 = &#39;(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)&#39;;
     6  my $fmt3 = &#39;(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)&#39;;
     7
     8  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
     9    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
    10      print &quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;;
    11    }
    12  }</code></pre>
<p>Obtenemos la salida:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl5.10.1 -w namedbackreferences.pl
day=21 month=10 year=2006
day=15 month=01 year=2007
day=31 month=10 year=2005</code></pre>
<p>Como se comentó:</p>
<blockquote>
<p>... It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced.</p>
</blockquote>
<p>Veamos un ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
DB&lt;1&gt;  # ... only the leftmost one of the eponymous set can be referenced
DB&lt;2&gt; $r = qr{(?&lt;a&gt;[a-c])(?&lt;a&gt;[a-f])}
DB&lt;3&gt; print $+{a} if &#39;ad&#39; =~ $r
a
DB&lt;4&gt; print $+{a} if &#39;cf&#39; =~ $r
c
DB&lt;5&gt; print $+{a} if &#39;ak&#39; =~ $r</code></pre>
<p>Reescribamos el ejemplo de conversión de temperaturas usando paréntesis con nombre:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n c2f_5_10v2.pl
 1  #!/usr/local/bin/perl5_10_1 -w
 2  use strict;
 3
 4  print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
 5  my $input = &lt;STDIN&gt;;
 6  chomp($input);
 7
 8  $input =~ m/^
 9              (?&lt;farenheit&gt;[-+]?[0-9]+(?:\.[0-9]*)?)\s*[fF]
10              |
11              (?&lt;celsius&gt;[-+]?[0-9]+(?:\.[0-9]*)?)\s*[cC]
12           $/x;
13
14  my ($celsius, $farenheit);
15  if (exists $+{celsius}) {
16    $celsius = $+{celsius};
17    $farenheit = ($celsius * 9/5)+32;
18  }
19  elsif (exists $+{farenheit}) {
20    $farenheit = $+{farenheit};
21    $celsius = ($farenheit -32)*5/9;
22  }
23  else {
24    die &quot;Expecting a temperature, so don&#39;t understand \&quot;$input\&quot;.\n&quot;;
25  }
26
27  printf &quot;%.2f C = %.2f F\n&quot;, $celsius, $farenheit;</code></pre>
<p>La función retorna verdadero si existe la clave en el hash y falso en otro caso.</p>
<p>El uso de nombres hace mas robustas y mas factorizables las expresiones regulares. Consideremos la siguiente regexp que usa notación posicional:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x &quot;abbacddc&quot; =~ /(.)(.)\2\1/
0  &#39;a&#39;
1  &#39;b&#39;</code></pre>
<p>Supongamos que queremos reutilizar la regexp con repetición</p>
<pre><code>  DB&lt;2&gt; x &quot;abbacddc&quot; =~ /((.)(.)\2\1){2}/
  empty array</code></pre>
<p>¿Que ha ocurrido? La introducción del nuevo paréntesis nos obliga a renombrar las referencias a las posiciones:</p>
<pre><code>  DB&lt;3&gt; x &quot;abbacddc&quot; =~ /((.)(.)\3\2){2}/
0  &#39;cddc&#39;
1  &#39;c&#39;
2  &#39;d&#39;
  DB&lt;4&gt; &quot;abbacddc&quot; =~ /((.)(.)\3\2){2}/; print &quot;$&amp;\n&quot;
abbacddc</code></pre>
<p>Esto no ocurre si utilizamos nombres. El operador <code>\k&lt;a&gt;</code> sirve para hacer referencia al valor que ha casado con el paréntesis con nombre <code>a</code>:</p>
<pre><code>  DB&lt;5&gt; x &quot;abbacddc&quot; =~ /((?&lt;a&gt;.)(?&lt;b&gt;.)\k&lt;b&gt;\k&lt;a&gt;){2}/
0  &#39;cddc&#39;
1  &#39;c&#39;
2  &#39;d&#39;</code></pre>
<p>El uso de grupos con nombre y <code>\k</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> en lugar de referencias numéricas absolutas hace que la regexp sea mas reutilizable.</p>
<p>Es posible también llamar a la expresión regular asociada con un paréntesis.</p>
<p>Este parrafo tomado de explica el modo de uso:</p>
<p><code>(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)</code></p>
<blockquote>
<p><code>PARNO</code> is a sequence of digits (not starting with 0) whose value reflects the paren-number of the capture buffer to recurse to.</p>
<p>....</p>
<p>Capture buffers contained by the pattern will have the value as determined by the outermost recursion. ....</p>
<p>If <code>PARNO</code> <span><strong>is preceded by a plus or minus sign then it is assumed to be relative, with negative numbers indicating preceding capture buffers and positive ones following</strong></span>. Thus <code>(?-1)</code> refers to the most recently declared buffer, and <code>(?+1)</code> indicates the next buffer to be declared.</p>
<p><span><strong>Note that the counting for relative recursion differs from that of relative backreferences, in that with recursion unclosed buffers are included.</strong></span></p>
</blockquote>
<p>Veamos un ejemplo:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; x &quot;AABB&quot; =~ /(A)(?-1)(?+1)(B)/
0  &#39;A&#39;
1  &#39;B&#39;
  # Parenthesis:       1   2   2                  1
  DB&lt;2&gt; x &#39;ababa&#39; =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  &#39;ababa&#39;
1  &#39;a&#39;
  DB&lt;3&gt; x &#39;bbabababb&#39; =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  &#39;bbabababb&#39;
1  &#39;b&#39;</code></pre>
<p>Véase también:</p>
<ul>
<li><p><span>http://perltraining.com.au/tips/2008-02-08.html</span></p></li>
<li><p><span>http://www.regex-engineer.org/slides/perl510<sub>r</sub>egex.html</span></p></li>
<li><p><span>http://szabgab.com/blog/2007/12/1198488988.html</span></p></li>
</ul>
<p>La siguiente reescritura de nuestro ejemplo básico utiliza el módulo para factorizar la expresión regular:</p>
<pre><code>casiano@millo:~/src/perl/perltesting$ cat -n c2f_5_10v3.pl
 1  #!/soft/perl5lib/bin/perl5.10.1 -w
 2  use strict;
 3  use Regexp::Common;
 4
 5  print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
 6  my $input = &lt;STDIN&gt;;
 7  chomp($input);
 8
 9  $input =~ m/^
10              (?&lt;farenheit&gt;$RE{num}{real})\s*[fF]
11              |
12              (?&lt;celsius&gt;$RE{num}{real})\s*[cC]
13           $/x;
14
15  my ($celsius, $farenheit);
16  if (&#39;celsius&#39; ~~ %+) {
17    $celsius = $+{celsius};
18    $farenheit = ($celsius * 9/5)+32;
19  }
20  elsif (&#39;farenheit&#39; ~~ %+) {
21    $farenheit = $+{farenheit};
22    $celsius = ($farenheit -32)*5/9;
23  }
24  else {
25    die &quot;Expecting a temperature, so don&#39;t understand \&quot;$input\&quot;.\n&quot;;
26  }
27
28  printf &quot;%.2f C = %.2f F\n&quot;, $celsius, $farenheit;</code></pre>
<p>Véase:</p>
<ul>
<li><p>La documentación del módulo por Abigail</p></li>
<li><p>Smart Matching: <span>http://perltraining.com.au/tips/2008-04-18.html</span></p></li>
<li><p>Rafael García Suárez:</p></li>
<li></li>
</ul>
<p>El módulo provee un extenso número de expresiones regulares que son accesibles vía el hash <code>%RE</code>. sigue un ejemplo de uso:</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n regexpcommonsynopsis.pl
     1  use strict;
     2  use Perl6::Say;
     3  use Regexp::Common;
     4
     5  while (&lt;&gt;) {
     6      say q{a number}              if /$RE{num}{real}/;
     7
     8      say q{a [&#39;&quot;`] quoted string} if /$RE{quoted}/;
     9
    10      say q{a /.../ sequence}      if m{$RE{delimited}{&#39;-delim&#39;=&gt;&#39;/&#39;}};
    11
    12      say q{balanced parentheses}  if /$RE{balanced}{&#39;-parens&#39;=&gt;&#39;()&#39;}/;
    13
    14      die q{a #*@%-ing word}.&quot;\n&quot;  if /$RE{profanity}/;
    15
    16  }
    17</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl regexpcommonsynopsis.pl
43
a number
&quot;2+2 es&quot; 4
a number
a [&#39;&quot;`] quoted string
x/y/z
a /.../ sequence
(2*(4+5/(3-2)))
a number
balanced parentheses
fuck you!
a #*@%-ing word</code></pre>
<p>El siguiente fragmento de la documentación de explica el modo simplificado de uso:</p>
<blockquote>
<p>To access a particular pattern, <code>%RE</code> is treated as a hierarchical hash of hashes (of hashes...), with each successive key being an identifier. For example, to access the pattern that matches real numbers, you specify:</p>
<pre><code>        $RE{num}{real}</code></pre>
<p>and to access the pattern that matches integers:</p>
<pre><code>        $RE{num}{int}</code></pre>
<p>Deeper layers of the hash are used to specify flags: arguments that modify the resulting pattern in some way.</p>
<ul>
<li><p>The keys used to access these layers are prefixed with a minus sign and may have a value;</p></li>
<li><p>if a value is given, it’s done by using a multidimensional key.</p></li>
</ul>
<p>For example, to access the pattern that matches base-2 real numbers with embedded commas separating groups of three digits (e.g. <code>10,101,110.110101101</code>):</p>
<pre><code>        $RE{num}{real}{-base =&gt; 2}{-sep =&gt; &#39;,&#39;}{-group =&gt; 3}</code></pre>
<p>Through the magic of Perl, these flag layers may be specified in any order (and even interspersed through the identifier keys!) so you could get the same pattern with:</p>
<pre><code>        $RE{num}{real}{-sep =&gt; &#39;,&#39;}{-group =&gt; 3}{-base =&gt; 2}</code></pre>
<p>or:</p>
<pre><code>        $RE{num}{-base =&gt; 2}{real}{-group =&gt; 3}{-sep =&gt; &#39;,&#39;}</code></pre>
<p>or even:</p>
<pre><code>        $RE{-base =&gt; 2}{-group =&gt; 3}{-sep =&gt; &#39;,&#39;}{num}{real}</code></pre>
<p>etc.</p>
<p>Note, however, that the relative order of amongst the identifier keys is significant. That is:</p>
<pre><code>        $RE{list}{set}</code></pre>
<p>would not be the same as:</p>
<pre><code>        $RE{set}{list}</code></pre>
</blockquote>
<p>Veamos un ejemplo con el depurador:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x &#39;numero: 10,101,110.110101101 101.1e-1 234&#39; =~ m{($RE{num}{real}{-base =&gt; 2}{-sep =&gt; &#39;,&#39;}{-group =&gt; 3})}g
0  &#39;10,101,110.110101101&#39;
1  &#39;101.1e-1&#39;</code></pre>
<p>La expresión regular para un número real es relativamente compleja:</p>
<pre><code>casiano@millo:~/src/perl/perltesting$ perl5.10.1 -wd c2f_5_10v3.pl
main::(c2f_5_10v3.pl:5):     print &quot;Enter a temperature (i.e. 32F, 100C):\n&quot;;
  DB&lt;1&gt; p $RE{num}{real}
(?:(?i)(?:[+-]?)(?:(?=[0123456789]|[.])(?:[0123456789]*)(?:(?:[.])(?:[0123456789]{0,}))?)(?:(?:[E])(?:(?:[+-]?)(?:[0123456789]+))|))</code></pre>
<p>Si se usa la opción <code>-keep</code> el patrón proveído usa paréntesis con memoria:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
DB&lt;2&gt; x &#39;one, two, three, four, five&#39; =~ /$RE{list}{-pat =&gt; &#39;\w+&#39;}/
0  1
DB&lt;3&gt; x &#39;one, two, three, four, five&#39; =~ /$RE{list}{-pat =&gt; &#39;\w+&#39;}{-keep}/
0  &#39;one, two, three, four, five&#39;
1  &#39;, &#39;</code></pre>
<p>Perl 5.10 introduce el operador de smart matching. El siguiente texto es tomado casi verbatim del site de la compañía <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<blockquote>
<p>Perl 5.10 introduces a new-operator, called smart-match, written <code>~~</code>. As the name suggests, smart-match tries to compare its arguments in an intelligent fashion. Using smart-match effectively allows many complex operations to be reduces to very simple statements.</p>
<p>Unlike many of the other features introduced in Perl 5.10, there’s no need to use the feature pragma to enable smart-match, as long as you’re using 5.10 it’s available.</p>
<p>The smart-match operator is always commutative. That means that <code>$x ~~ $y</code> works the same way as <code>$y ~~ $x</code>. You’ll never have to remember which order to place to your operands with smart-match. Smart-match in action.</p>
<p>As a simple introduction, we can use smart-match to do a simple string comparison between simple scalars. For example:</p>
<pre><code>    use feature qw(say);

    my $x = &quot;foo&quot;;
    my $y = &quot;bar&quot;;
    my $z = &quot;foo&quot;;

    say &#39;$x and $y are identical strings&#39; if $x ~~ $y;
    say &#39;$x and $z are identical strings&#39; if $x ~~ $z;    # Printed</code></pre>
<p>If one of our arguments is a number, then a numeric comparison is performed:</p>
<pre><code>    my $num   = 100;
    my $input = &lt;STDIN&gt;;

    say &#39;You entered 100&#39; if $num ~~ $input;</code></pre>
<p>This will print our message if our user enters 100, 100.00, +100, 1e2, or any other string that looks like the number 100.</p>
<p>We can also smart-match against a regexp:</p>
<pre><code>    my $input  = &lt;STDIN&gt;;

    say &#39;You said the secret word!&#39; if $input ~~ /xyzzy/;</code></pre>
<p>Smart-matching with a regexp also works with saved regexps created with qr.</p>
<p>So we can use smart-match to act like eq, <code>==</code> and <code>=~</code>, so what? Well, it does much more than that.</p>
<p>We can use smart-match to search a list:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB&lt;2&gt; print &quot;You&#39;re a friend&quot; if &#39;Pippin&#39; ~~ @friends
You&#39;re a friend
  DB&lt;3&gt; print &quot;You&#39;re a friend&quot; if &#39;Mordok&#39; ~~ @friends</code></pre>
<p>It’s important to note that searching an array with smart-match is extremely fast. It’s faster than using grep, it’s faster than using <code>first</code> from , and it’s faster than walking through the loop with <code>foreach</code>, even if you do know all the clever optimisations.</p>
<p>Esta es la forma típica de buscar un elemento en un array en versiones anteriores a la 5.10:</p>
<pre><code>casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; use List::Util qw{first}
  DB&lt;2&gt; @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB&lt;3&gt; x first { $_ eq &#39;Pippin&#39;} @friends
0  &#39;Pippin&#39;
  DB&lt;4&gt; x first { $_ eq &#39;Mordok&#39;} @friends
0  undef</code></pre>
<p>We can also use smart-match to compare arrays:</p>
<pre><code>  DB&lt;4&gt; @foo = qw(x y z xyzzy ninja)
  DB&lt;5&gt; @bar = qw(x y z xyzzy ninja)
  DB&lt;7&gt; print &quot;Identical arrays&quot; if @foo ~~ @bar
Identical arrays
  DB&lt;8&gt; @bar = qw(x y z xyzzy nOnjA)
  DB&lt;9&gt; print &quot;Identical arrays&quot; if @foo ~~ @bar
  DB&lt;10&gt;     </code></pre>
<p>And even search inside an array using a string:</p>
<pre><code> DB&lt;11&gt; x @foo = qw(x y z xyzzy ninja)
0  &#39;x&#39;
1  &#39;y&#39;
2  &#39;z&#39;
3  &#39;xyzzy&#39;
4  &#39;ninja&#39;
  DB&lt;12&gt; print &quot;Array contains a ninja &quot; if @foo ~~ &#39;ninja&#39;</code></pre>
<p>or using a regexp:</p>
<pre><code>  DB&lt;13&gt; print &quot;Array contains magic pattern&quot; if @foo ~~ /xyz/
Array contains magic pattern
  DB&lt;14&gt; print &quot;Array contains magic pattern&quot; if @foo ~~ /\d+/</code></pre>
<p>Smart-match works with array references, too<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>:</p>
<pre><code>  DB&lt;16&gt; $array_ref = [ 1..10 ]
  DB&lt;17&gt; print &quot;Array contains 10&quot; if 10 ~~ $array_ref
Array contains 10
  DB&lt;18&gt; print &quot;Array contains 10&quot; if $array_ref ~~ 10
  DB&lt;19&gt;     </code></pre>
<p>En el caso de un número y un array devuelve cierto si el escalar aparece en un array anidado:</p>
<pre><code>casiano@millo:~/Lperltesting$ perl5.10.1 -E &#39;say &quot;ok&quot; if 42 ~~  [23, 17, [40..50], 70];&#39;
ok
casiano@millo:~/Lperltesting$ perl5.10.1 -E &#39;say &quot;ok&quot; if 42 ~~  [23, 17, [50..60], 70];&#39;
casiano@millo:~/Lperltesting$                                                           </code></pre>
<p>Of course, we can use smart-match with more than just arrays and scalars, it works with searching for the key in a hash, too!</p>
<pre><code>  DB&lt;19&gt; %colour = ( sky   =&gt; &#39;blue&#39;, grass =&gt; &#39;green&#39;, apple =&gt; &#39;red&#39;,)
  DB&lt;20&gt; print &quot;I know the colour&quot; if &#39;grass&#39; ~~ %colour
I know the colour
  DB&lt;21&gt; print &quot;I know the colour&quot; if &#39;cloud&#39; ~~ %colour
  DB&lt;22&gt;
  DB&lt;23&gt; print &quot;A key starts with &#39;gr&#39;&quot; if %colour ~~ /^gr/
A key starts with &#39;gr&#39;
  DB&lt;24&gt; print &quot;A key starts with &#39;clou&#39;&quot; if %colour ~~ /^clou/
  DB&lt;25&gt;</code></pre>
<p>You can even use it to see if the two hashes have identical keys:</p>
<pre><code>  DB&lt;26&gt; print &#39;Hashes have identical keys&#39; if %taste ~~ %colour;
Hashes have identical keys</code></pre>
</blockquote>
<p>La conducta del operador de smart matching viene dada por la siguiente tabla tomada de :</p>
<blockquote>
<p>The behaviour of a smart match depends on what type of thing its arguments are. The behaviour is determined by the following table: the first row that applies determines the match behaviour (which is thus mostly determined by the type of the right operand). Note that the smart match implicitly dereferences any non-blessed hash or array ref, so the “Hash” and “Array” entries apply in those cases. (For blessed references, the “Object” entries apply.)</p>
<p>Note that the “Matching Code” column is not always an exact rendition. For example, the smart match operator short-circuits whenever possible, but grep does not.</p>
<pre><code> $a      $b        Type of Match Implied    Matching Code
 ======  =====     =====================    =============
 Any     undef     undefined                !defined $a

 Any     Object    invokes ~~ overloading on $object, or dies

 Hash    CodeRef   sub truth for each key[1] !grep { !$b-&gt;($_) } keys %$a
 Array   CodeRef   sub truth for each elt[1] !grep { !$b-&gt;($_) } @$a
 Any     CodeRef   scalar sub truth          $b-&gt;($a)

 Hash    Hash      hash keys identical (every key is found in both hashes)
 Array   Hash      hash slice existence     grep { exists $b-&gt;{$_} } @$a
 Regex   Hash      hash key grep            grep /$a/, keys %$b
 undef   Hash      always false (undef can&#39;t be a key)
 Any     Hash      hash entry existence     exists $b-&gt;{$a}

 Hash    Array     hash slice existence     grep { exists $a-&gt;{$_} } @$b
 Array   Array     arrays are comparable[2]
 Regex   Array     array grep               grep /$a/, @$b
 undef   Array     array contains undef     grep !defined, @$b
 Any     Array     match against an array element[3]
                                            grep $a ~~ $_, @$b

 Hash    Regex     hash key grep            grep /$b/, keys %$a
 Array   Regex     array grep               grep /$b/, @$a
 Any     Regex     pattern match            $a =~ /$b/

 Object  Any       invokes ~~ overloading on $object, or falls back:
 Any     Num       numeric equality         $a == $b
 Num     numish[4] numeric equality         $a == $b
 undef   Any       undefined                !defined($b)
 Any     Any       string equality          $a eq $b</code></pre>
</blockquote>
<ul>
<li><p>Indique la salida del siguiente programa:</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat twonumbers.pl
  2  $_ = &quot;I have 2 numbers: 53147&quot;;
  3  @pats = qw{
  4    (.*)(\d*)
  5    (.*)(\d+)
  6    (.*?)(\d*)
  7    (.*?)(\d+)
  8    (.*)(\d+)$
  9    (.*?)(\d+)$
 10    (.*)\b(\d+)$
 11    (.*\D)(\d+)$
 12  };
 13  
 14  print &quot;$_\n&quot;;
 15  for $pat (@pats) {
 16    printf &quot;%-12s &quot;, $pat;
 17    &lt;&gt;;
 18    if ( /$pat/ ) {
 19      print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;
 20    } else {
 21      print &quot;FAIL\n&quot;;
 22    }
 23  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat twonumbers&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = &amp;quot;I have 2 numbers: 53147&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@pats&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = qw{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*)(\d*)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*)(\d+)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*?)(\d*)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*?)(\d+)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*)(\d+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*?)(\d+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*)\b(\d+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.*\D)(\d+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;print &amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$pat&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@pats&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; {&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  printf &amp;quot;%-12s &amp;quot;, &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$pat&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &amp;lt;&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  if &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$pat&lt;/span&gt;/ ) {
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;   } &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;FAIL&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; }
&lt;/pre&gt;</code></pre></li>
</ul>
<h3 id="depuración-de-expresiones-regulares">Depuración de Expresiones Regulares</h3>
<p>Para obtener información sobre la forma en que es compilada una expresión regular y como se produce el proceso de matching podemos usar la opción <code>'debug'</code> del módulo <code>re</code>. La versión de Perl 5.10 da una información algo mas legible que la de las versiones anteriores:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5_10_1 -wde 0

Loading DB routines from perl5db.pl version 1.32
Editor support available.

Enter h or `h h&#39; for help, or `man perldebug&#39; for more help.

main::(-e:1):   0
  DB&lt;1&gt; use re &#39;debug&#39;; &#39;astr&#39; =~ m{[sf].r}
Compiling REx &quot;[sf].r&quot;
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT &lt;r&gt; (15)
  15: END (0)
anchored &quot;r&quot; at 2 (checking anchored) stclass ANYOF[fs][] minlen 3
Guessing start of match in sv for REx &quot;[sf].r&quot; against &quot;astr&quot;
Found anchored substr &quot;r&quot; at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx &quot;[sf].r&quot; against &quot;str&quot;
   1 &lt;a&gt; &lt;str&gt;               |  1:ANYOF[fs][](12)
   2 &lt;as&gt; &lt;tr&gt;               | 12:REG_ANY(13)
   3 &lt;ast&gt; &lt;r&gt;               | 13:EXACT &lt;r&gt;(15)
   4 &lt;astr&gt; &lt;&gt;               | 15:END(0)
Match successful!
Freeing REx: &quot;[sf].r&quot;</code></pre>
<p>Si se usa la opción <code>debug</code> de <code>re</code> con objetos expresión regular, se obtendrá información durante el proceso de matching:</p>
<pre><code> DB&lt;3&gt; use re &#39;debug&#39;; $re = qr{[sf].r}
Compiling REx &quot;[sf].r&quot;
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT &lt;r&gt; (15)
  15: END (0)
anchored &quot;r&quot; at 2 (checking anchored) stclass ANYOF[fs][] minlen 3

  DB&lt;4&gt; &#39;astr&#39; =~ $re
Guessing start of match in sv for REx &quot;[sf].r&quot; against &quot;astr&quot;
Found anchored substr &quot;r&quot; at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx &quot;[sf].r&quot; against &quot;str&quot;
   1 &lt;a&gt; &lt;str&gt;               |  1:ANYOF[fs][](12)
   2 &lt;as&gt; &lt;tr&gt;               | 12:REG_ANY(13)
   3 &lt;ast&gt; &lt;r&gt;               | 13:EXACT &lt;r&gt;(15)
   4 &lt;astr&gt; &lt;&gt;               | 15:END(0)
Match successful!</code></pre>
<h3 id="section:abreviadas">Tablas de Escapes, Metacarácteres, Cuantificadores, Clases</h3>
<p>Sigue una sección de tablas con notaciones tomada de :</p>
<p>The following metacharacters have their standard egrep-ish meanings:</p>
<pre><code>   1. \ Quote the next metacharacter
   2. ^ Match the beginning of the line
   3. . Match any character (except newline)
   4. $ Match the end of the line (or before newline at the end)
   5. | Alternation
   6. () Grouping
   7. [] Character class</code></pre>
<p>The following standard greedy quantifiers are recognized:</p>
<pre><code>   1. * Match 0 or more times
   2. + Match 1 or more times
   3. ? Match 1 or 0 times
   4. {n} Match exactly n times
   5. {n,} Match at least n times
   6. {n,m} Match at least n but not more than m times</code></pre>
<p>The following non greedy quantifiers are recognized:</p>
<pre><code>   1. *? Match 0 or more times, not greedily
   2. +? Match 1 or more times, not greedily
   3. ?? Match 0 or 1 time, not greedily
   4. {n}? Match exactly n times, not greedily
   5. {n,}? Match at least n times, not greedily
   6. {n,m}? Match at least n but not more than m times, not greedily</code></pre>
<p>The following possesive quantifiers are recognized:</p>
<pre><code>   1. *+ Match 0 or more times and give nothing back
   2. ++ Match 1 or more times and give nothing back
   3. ?+ Match 0 or 1 time and give nothing back
   4. {n}+ Match exactly n times and give nothing back (redundant)
   5. {n,}+ Match at least n times and give nothing back
   6. {n,m}+ Match at least n but not more than m times and give nothing back</code></pre>
<pre><code>   1. \t tab (HT, TAB)
   2. \n newline (LF, NL)
   3. \r return (CR)
   4. \f form feed (FF)
   5. \a alarm (bell) (BEL)
   6. \e escape (think troff) (ESC)
   7. \033 octal char (example: ESC)
   8. \x1B hex char (example: ESC)
   9. \x{263a} long hex char (example: Unicode SMILEY)
  10. \cK control char (example: VT)
  11. \N{name} named Unicode character
  12. \l lowercase next char (think vi)
  13. \u uppercase next char (think vi)
  14. \L lowercase till \E (think vi)
  15. \U uppercase till \E (think vi)
  16. \E end case modification (think vi)
  17. \Q quote (disable) pattern metacharacters till \E</code></pre>
<p>Explique la salida:</p>
<pre><code>casiano@tonga:~$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = &#39;([a-z]+)&#39;
  DB&lt;2&gt; x &#39;hola&#39; =~ /$x/
0  &#39;hola&#39;
  DB&lt;3&gt; x &#39;hola&#39; =~ /\Q$x/
  empty array
  DB&lt;4&gt; x &#39;([a-z]+)&#39; =~ /\Q$x/
0  1</code></pre>
<pre><code>   1. \w Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;)
   2. \W Match a non-&quot;word&quot; character
   3. \s Match a whitespace character
   4. \S Match a non-whitespace character
   5. \d Match a digit character
   6. \D Match a non-digit character
   7. \pP Match P, named property. Use \p{Prop} for longer names.
   8. \PP Match non-P
   9. \X Match eXtended Unicode &quot;combining character sequence&quot;,
  10.    equivalent to (?&gt;\PM\pM*)
  11. \C Match a single C char (octet) even under Unicode.
  12.    NOTE: breaks up characters into their UTF-8 bytes,
  13.    so you may end up with malformed pieces of UTF-8.
  14.    Unsupported in lookbehind.
  15. \1 Backreference to a specific group.
  16. &#39;1&#39; may actually be any positive integer.
  17. \g1 Backreference to a specific or previous group,
  18. \g{-1} number may be negative indicating a previous buffer and may
  19.        optionally be wrapped in curly brackets for safer parsing.
  20. \g{name} Named backreference
  21. \k&lt;name&gt; Named backreference
  22. \K Keep the stuff left of the \K, don&#39;t include it in $&amp;
  23. \v Vertical whitespace
  24. \V Not vertical whitespace
  25. \h Horizontal whitespace
  26. \H Not horizontal whitespace
  27. \R Linebreak</code></pre>
<p>Perl defines the following zero-width assertions:</p>
<pre><code>   1. \b Match a word boundary
   2. \B Match except at a word boundary
   3. \A Match only at beginning of string
   4. \Z Match only at end of string, or before newline at the end
   5. \z Match only at end of string
   6. \G Match only at pos() (e.g. at the end-of-match position
   7. of prior m//g)</code></pre>
<h4 id="the-posix-character-class-syntax">The POSIX character class syntax</h4>
<p>The POSIX character class syntax:</p>
<pre><code>   1. [:class:]</code></pre>
<p>is also available. Note that the <code>[</code> and <code>]</code> brackets are literal; they must always be used within a character class expression.</p>
<pre><code>   1. # this is correct:
   2. $string =~ /[[:alpha:]]/;
   3.
   4. # this is not, and will generate a warning:
   5. $string =~ /[:alpha:]/;</code></pre>
<p>The available classes and their backslash equivalents (if available) are as follows:</p>
<pre><code>   1. alpha
   2. alnum
   3. ascii
   4. blank
   5. cntrl
   6. digit \d
   7. graph
   8. lower
   9. print
  10. punct
  11. space \s 
  12. upper
  13. word \w 
  14. xdigit</code></pre>
<p>For example use <code>[:upper:]</code> to match all the uppercase characters. Note that the <code>[]</code> are part of the <code>[::]</code> construct, not part of the whole character class. For example:</p>
<pre><code>   1. [01[:alpha:]%]</code></pre>
<p>matches zero, one, any alphabetic character, and the percent sign.</p>
<p>The following equivalences to Unicode <code>\p{}</code> constructs and equivalent backslash character classes (if available), will hold:</p>
<pre><code>   1. [[:...:]] \p{...} backslash
   2.
   3. alpha IsAlpha
   4. alnum IsAlnum
   5. ascii IsASCII
   6. blank
   7. cntrl IsCntrl
   8. digit IsDigit \d
   9. graph IsGraph
  10. lower IsLower
  11. print IsPrint 
  12. punct IsPunct 
  13. space IsSpace
  14. IsSpacePerl \s
  15. upper IsUpper
  16. word IsWord \w
  17. xdigit IsXDigit</code></pre>
<p>You can negate the <code>[::]</code> character classes by prefixing the class name with a <code>'^'</code>. This is a Perl extension. For example:</p>
<pre><code>   1. POSIX traditional Unicode
   2.
   3. [[:^digit:]] \D \P{IsDigit}
   4. [[:^space:]] \S \P{IsSpace}
   5. [[:^word:]] \W \P{IsWord}</code></pre>
<h3 id="section:variablesmagicasereg">Variables especiales después de un emparejamiento</h3>
<p>Despues de un emparejamiento con éxito, las siguientes variables especiales quedan definidas:</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>$&amp;</code></th>
<th align="left">El texto que casó</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>$`</code></td>
<td align="left">El texto que está a la izquierda de lo que casó</td>
</tr>
<tr class="even">
<td align="left"><code>$'</code></td>
<td align="left">El texto que está a la derecha de lo que casó</td>
</tr>
<tr class="odd">
<td align="left"><code>$1, $2, $3</code>, etc.</td>
<td align="left">Los textos capturados por los paréntesis</td>
</tr>
<tr class="even">
<td align="left"><code>$+</code></td>
<td align="left">Una copia del <code>$1, $2,</code> …con número mas alto</td>
</tr>
<tr class="odd">
<td align="left"><code>@-</code></td>
<td align="left">Desplazamientos de las subcadenas que casan en <code>$1</code> …</td>
</tr>
<tr class="even">
<td align="left"><code>@+</code></td>
<td align="left">Desplazamientos de los finales de las subcadenas en <code>$1</code> …</td>
</tr>
<tr class="odd">
<td align="left"><code>$#-</code></td>
<td align="left">El índice del último paréntesis que casó</td>
</tr>
<tr class="even">
<td align="left"><code>$#+</code></td>
<td align="left">El índice del último paréntesis en la última expresión regular</td>
</tr>
</tbody>
</table>
<p>[parrafo:prematch]</p>
<p>Ejemplo:</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 if (&quot;Hello there, neighbor&quot; =~ /\s(\w+),/) {
   3   print &quot;That was: ($`)($&amp;)($&#39;).\n&quot;,
   4 }</code></pre>
<pre><code>&gt; matchvariables.pl
That was: (Hello)( there,)( neighbor).</code></pre>
<p>El uso de estas variables tenía un efecto negativo en el rendimiento de la regexp. Véase la sección <code>Why does using $&amp;, $`, or $' slow my program down?</code>.</p>
<blockquote>
<p>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to <code>$`</code>, part to <code>$&amp;</code>, and part to <code>$'</code>. Thus the penalty is most severe with long strings and patterns that match often. Avoid <code>$&amp;</code>, <code>$'</code>, and <code>$`</code> if you can, but if you can’t, once you’ve used them at all, use them at will because you’ve already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the <code>$&amp;</code> variable is no longer “expensive” the way the other two are.</p>
<p>Since Perl 5.6.1 the special variables <code>@-</code> and <code>@+</code> can functionally replace <code>$`</code>, <code>$&amp;</code> and <code>$'</code>. These arrays contain pointers to the beginning and end of each match (see for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</p>
<p>Perl 5.10 added three specials, <code>${^MATCH}</code>, <code>${^PREMATCH}</code>, and <code>${^POSTMATCH}</code> to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the <code>/p</code> modifier.</p>
</blockquote>
<pre><code>pl@nereida:~/Lperltesting$ cat ampersandoldway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

&#39;hola juan&#39; =~ /ju/;
my ($a, $b, $c) = ($`, $&amp;, $&#39;);


cmpthese( -1, {
    oldway =&gt; sub { &#39;hola juan&#39; =~ /ju/  },
});
pl@nereida:~/Lperltesting$ cat ampersandnewway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

&#39;hola juan&#39; =~ /ju/p;
my ($a, $b, $c) = (${^PREMATCH}, ${^MATCH}, ${^POSTMATCH});


cmpthese( -1, {
    newway =&gt; sub { &#39;hola juan&#39; =~ /ju/  },
});

pl@nereida:~/Lperltesting$ time ./ampersandoldway.pl
            Rate oldway
oldway 2991861/s     --

real    0m3.761s
user    0m3.740s
sys     0m0.020s
pl@nereida:~/Lperltesting$ time ./ampersandnewway.pl
            Rate newway
newway 8191999/s     --

real    0m6.721s
user    0m6.704s
sys     0m0.016s</code></pre>
<p>Véase</p>
<ul>
<li><p>(busque por <code>$MATCH</code>)</p></li>
</ul>
<p>La variable <code>$+</code> contiene el texto que casó con el último paréntesis en el patrón. Esto es útil en situaciones en las cuáles una de un conjunto de alternativas casa, pero no sabemos cuál:</p>
<pre><code>  DB&lt;9&gt; &quot;Revision: 4.5&quot; =~ /Version: (.*)|Revision: (.*)/ &amp;&amp; ($rev = $+);
  DB&lt;10&gt; x $rev
0  4.5
  DB&lt;11&gt; &quot;Version: 4.5&quot; =~ /Version: (.*)|Revision: (.*)/ &amp;&amp; ($rev = $+);
  DB&lt;12&gt; x $rev
0  4.5</code></pre>
<p>[parrafo:iniciocas]</p>
<p>El vector <code>@-</code> contiene los <em>offsets</em> o desplazamientos de los casamientos en la última expresión regular. La entrada <code>$-[0]</code> es el desplazamiento del último casamiento con éxito y <code>$-[n]</code> es el desplazamiento de la subcadena que casa con el <code>n</code>-ésimo paréntesis (o <code>undef</code> si el párentesis no casó). Por ejemplo:</p>
<pre><code>#           012345678
DB&lt;1&gt; $z = &quot;hola13.47&quot;
DB&lt;2&gt; if ($z =~ m{a(\d+)(\.(\d+))?}) { print &quot;@-\n&quot;; }
3 4 6 7</code></pre>
<p>El resultado se interpreta como sigue:</p>
<ul>
<li><p>3 = desplazamiento de comienzo de <code>$&amp; = a13.47</code></p></li>
<li><p>4 = desplazamiento de comienzo de <code>$1 = 13</code></p></li>
<li><p>6 = desplazamiento de comienzo de <code>$2 = .</code></p></li>
<li><p>7 = desplazamiento de comienzo de <code>$3 = 47</code></p></li>
</ul>
<p>Esto es lo que dice sobre <code>@-</code>:</p>
<blockquote>
<p>This array holds the offsets of the beginnings of the last successful submatches in the currently active dynamic scope. <code>$-[0]</code> is the offset into the string of the beginning of the entire match. The nth element of this array holds the offset of the nth submatch, so <code>$-[1]</code> is the offset where <code>$1</code> begins, <code>$-[2]</code> the offset where <code>$2</code> begins, and so on.</p>
<p>After a match against some variable <code>$var</code>:</p>
<pre><code>    $` is the same as substr($var, 0, $-[0])
    $&amp; is the same as substr($var, $-[0], $+[0] - $-[0])
    $&#39; is the same as substr($var, $+[0])
    $1 is the same as substr($var, $-[1], $+[1] - $-[1])
    $2 is the same as substr($var, $-[2], $+[2] - $-[2])
    $3 is the same as substr($var, $-[3], $+[3] - $-[3])</code></pre>
</blockquote>
<p>[parrafo:fincas]</p>
<p>El array <code>@+</code> contiene los desplazamientos de los finales de los emparejamientos. La entrada <code>$+[0]</code> contiene el desplazamiento del final de la cadena del emparejamiento completo. Siguiendo con el ejemplo anterior:</p>
<pre><code>#            0123456789
DB&lt;17&gt; $z = &quot;hola13.47x&quot;
DB&lt;18&gt; if ($z =~ m{a(\d+)(\.)(\d+)?}) { print &quot;@+\n&quot;; }
9 6 7 9</code></pre>
<p>El resultado se interpreta como sigue:</p>
<ul>
<li><p>9 = desplazamiento final de <code>$&amp; = a13.47x</code></p></li>
<li><p>6 = desplazamiento final de <code>$1 = 13</code></p></li>
<li><p>7 = desplazamiento final de <code>$2 = .</code></p></li>
<li><p>9 = desplazamiento final de <code>$3 = 47</code></p></li>
</ul>
<p>Se puede usar <code>$#+</code> para determinar cuantos parentesis había en el último emparejamiento que tuvo éxito.</p>
<pre><code>  DB&lt;29&gt; $z = &quot;h&quot;
  DB&lt;30&gt; print &quot;$#+\n&quot; if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
3
  DB&lt;31&gt; $z = &quot;ab&quot;
  DB&lt;32&gt; print &quot;$#+\n&quot; if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
2</code></pre>
<p>[parrafo:lastpar]</p>
<p>La variable <code>$#-</code> contiene el índice del último paréntesis que casó. Observe la siguiente ejecución con el depurador:</p>
<pre><code>  DB&lt;1&gt; $x = &#39;13.47&#39;; $y = &#39;125&#39;
  DB&lt;2&gt; if ($y =~ m{(\d+)(\.(\d+))?}) { print &quot;last par = $#-, content = $+\n&quot;; }
last par = 1, content = 125
  DB&lt;3&gt; if ($x =~ m{(\d+)(\.(\d+))?}) { print &quot;last par = $#-, content = $+\n&quot;; }
last par = 3, content = 47</code></pre>
<p>En general no puede asumirse que <code>@-</code> y <code>@+</code> sean del mismo tamaño.</p>
<pre><code>  DB&lt;1&gt; &quot;a&quot; =~ /(a)|(b)/; @a = @-; @b = @+
  DB&lt;2&gt; x @a
0  0
1  0
  DB&lt;3&gt; x @b
0  1
1  1
2  undef</code></pre>
<p>Para saber más sobre las variables especiales disponibles consulte</p>
<ul>
<li><p><code>perldoc</code></p></li>
<li><p><code>perldoc</code> .</p></li>
</ul>
<h3 id="ambito-automático">Ambito Automático</h3>
<p>Como sabemos, ciertas variables (como <code>$1</code>, <code>$&amp;</code> …) reciben automáticamente un valor con cada operación de “matching”.</p>
<p>Considere el siguiente código:</p>
<pre><code>if (m/(...)/) {
  &amp;do_something();
  print &quot;the matched variable was $1.\n&quot;;
}</code></pre>
<p>Puesto que <code>$1</code> es automáticamente declarada <code>local</code> a la entrada de cada bloque, no importa lo que se haya hecho en la función <code> &amp;do_something()</code>, el valor de <code>$1</code> en la sentencia <code>print</code> es el correspondiente al “matching” realizado en el <code>if</code>.</p>
<h3 id="section:opciones">Opciones</h3>
<table>
<thead>
<tr class="header">
<th align="left">Modificador</th>
<th align="left">Significado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">e</td>
<td align="left">evaluar: evaluar el lado derecho de una sustitución como una expresión</td>
</tr>
<tr class="even">
<td align="left">g</td>
<td align="left">global: Encontrar todas las ocurrencias</td>
</tr>
<tr class="odd">
<td align="left">i</td>
<td align="left">ignorar: no distinguir entre mayúsculas y minúsculas</td>
</tr>
<tr class="even">
<td align="left">m</td>
<td align="left">multilínea (<code>^</code> y <code>$</code> casan con <code>\n</code> internos)</td>
</tr>
<tr class="odd">
<td align="left">o</td>
<td align="left">optimizar: compilar una sola vez</td>
</tr>
<tr class="even">
<td align="left">s</td>
<td align="left"><code>^</code> y <code>$</code> ignoran <code>\n</code> pero el punto <code>.</code> “casa” con <code>\n</code></td>
</tr>
<tr class="odd">
<td align="left">x</td>
<td align="left">extendida: permitir comentarios</td>
</tr>
</tbody>
</table>
<p>[section:g] La conducta de este modificador depende del contexto. En un contexto de listas devuelve una lista con todas las subcadenas casadas por todos los paréntesis en la expresión regular. Si no hubieran paréntesis devuelve una lista con todas las cadenas casadas (como si hubiera paréntesis alrededor del patrón global).</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 ($one, $five, $fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
   3 print &quot;$one, $five, $fifteen\n&quot;;</code></pre>
<p>Observe la salida:</p>
<pre><code>&gt; uptime
  1:35pm  up 19:22,  0 users,  load average: 0.01, 0.03, 0.00
&gt; glist.pl
0.01, 0.03, 0.00 </code></pre>
<p>En un contexto escalar <code>m//g</code> itera sobre la cadena, devolviendo cierto cada vez que casa, y falso cuando deja de casar. En otras palabras, recuerda donde se quedo la última vez y se recomienza la búsqueda desde ese punto. Se puede averiguar la posicion del emparejamiento utilizando la función . Si por alguna razón modificas la cadena en cuestión, la posición de emparejamiento se reestablece al comienzo de la cadena.</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 # count sentences in a document
   3 #defined as ending in [.!?] perhaps with
   4 # quotes or parens on either side.
   5 $/ = &quot;&quot;; # paragraph mode
   6 while ($paragraph = &lt;&gt;) {
   7   print $paragraph;
   8   while ($paragraph =~ /[a-z][&#39;&quot;)]*[.!?]+[&#39;&quot;)]*\s/g) {
   9     $sentences++;
  10   }
  11 }
  12 print &quot;$sentences\n&quot;;</code></pre>
<p>Observe el uso de la variable especial <code>$/</code>. Esta variable contiene el separador de registros en el fichero de entrada. Si se iguala a la cadena vacía usará las líneas en blanco como separadores. Se le puede dar el valor de una cadena multicarácter para usarla como delimitador. Nótese que establecerla a <code>\n\n</code> es diferente de asignarla a <code>&quot;&quot;</code>. Si se deja <code>undef</code>, la siguiente lectura leerá todo el fichero.</p>
<p>Sigue un ejemplo de ejecución. El programa se llama <code>gscalar.pl</code>. Introducimos el texto desde <code>STDIN</code>. El programa escribe el número de párrafos:</p>
<pre><code>&gt; gscalar.pl
este primer parrafo. Sera seguido de un
segundo parrafo.
 
&quot;Cita de Seneca&quot;.
 
3 </code></pre>
<p>[section:regeval] La opción <code>/e</code> permite la evaluación como expresión perl de la cadena de reemplazo (En vez de considerarla como una cadena delimitada por doble comilla).</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 $_ = &quot;abc123xyz\n&quot;;
   3 s/\d+/$&amp;*2/e;
   4 print;
   5 s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;
   6 print;
   7 s/\w/$&amp; x 2/eg;
   8 print;</code></pre>
<p>El resultado de la ejecución es:</p>
<pre><code>&gt; replacement.pl
abc246xyz
abc  246xyz
aabbcc  224466xxyyzz </code></pre>
<p>Véase un ejemplo con anidamiento de <span>/e</span>:</p>
<pre><code>   1 #!/usr/bin/perl 
   2 $a =&quot;one&quot;;
   3 $b = &quot;two&quot;;
   4 $_ = &#39;$a $b&#39;;
   5 print &quot;_ = $_\n\n&quot;;
   6 s/(\$\w+)/$1/ge;
   7 print &quot;After &#39;s/(\$\w+)/$1/ge&#39; _ = $_\n\n&quot;;
   8 s/(\$\w+)/$1/gee;
   9 print &quot;After &#39;s/(\$\w+)/$1/gee&#39; _ = $_\n\n&quot;;</code></pre>
<p>El resultado de la ejecución es:</p>
<pre><code>&gt; enested.pl
_ = $a $b
 
After &#39;s/($w+)/$b/ge&#39; _ = $a $b
 
After &#39;s/($w+)/$b/gee&#39; _ = one two  </code></pre>
<p>He aqui una solución que hace uso de <code>e</code> al siguiente ejercicio (véase ’Regex to add space after punctuation sign’ en ) Se quiere poner un espacio en blanco después de la aparición de cada coma:</p>
<pre><code>s/,/, /g;</code></pre>
<p>pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre dos dígitos. Además se pide que si hay ya un espacio después de la coma, no se duplique</p>
<pre><code>s/(\d[,.]\d)|(,(?!\s))/$1 || &quot;$2 &quot;/ge; </code></pre>
<p>Se hace uso de un lookahead negativo <code>(?!\s)</code>. Véase la sección [subsection:lookaheadlookbehind] para entender como funciona un lookahead negativo.</p>
<h2 id="algunas-extensiones">Algunas Extensiones</h2>
<h3 id="comentarios">Comentarios</h3>
<p><code>(?#text)</code> Un comentario. Se ignora <code>text</code>. Si se usa la opción <code>x</code> basta con poner <code>#</code>.</p>
<h3 id="modificadores-locales">Modificadores locales</h3>
<p>Los modificadores de la conducta de una expresión regular pueden ser empotrados en una subexpresión usando el formato <code>(?pimsx-imsx)</code>.</p>
<p>Véase el correspondiente texto <span><em>Extended Patterns</em></span> de :</p>
<blockquote>
<p>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by ’<code>-</code>’ ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any). This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case sensitive and some do not: The case insensitive ones merely need to include (?i) at the front of the pattern. For example:</p>
<pre><code>   1. $pattern = &quot;foobar&quot;;
   2. if ( /$pattern/i ) { }
   3.
   4. # more flexible:
   5.
   6. $pattern = &quot;(?i)foobar&quot;;
   7. if ( /$pattern/ ) { }</code></pre>
<p>These modifiers are restored at the end of the enclosing group. For example,</p>
<pre><code>   1. ( (?i) blah ) \s+ \1</code></pre>
<p>will match <code>blah</code> in any case, some spaces, and an exact (including the case!) repetition of the previous word, assuming the <code>/x</code> modifier, and no <code>/i</code> modifier outside this group.</p>
</blockquote>
<p>El siguiente ejemplo extiende el ejemplo visto en la sección [parrfo:comments] eliminando los comentarios <code>/* ... */</code> y <code>// ... </code> de un programa C. En dicho ejemplo se usaba el modificador <code>s</code> para hacer que el punto casara con cualquier carácter:</p>
<pre><code>casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die &quot;Usage:\n$0 prog.c\n&quot;;
   5    open(my $PROGRAM,&quot;&lt;$progname&quot;) || die &quot;can&#39;t find $progname\n&quot;;
   6    my $program = &#39;&#39;;
   7    {
   8      local $/ = undef;
   9      $program = &lt;$PROGRAM&gt;;
  10    }
  11    $program =~ s{(?xs)
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15      |
  16        (?-s)//.* # C++ // comments. No s modifier
  17    }[]g;
  18  
  19    print $program;</code></pre>
<pre><code>
&lt;pre&gt;
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@ARGV&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Usage:&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; prog.c&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$PROGRAM&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;) || &lt;span class=&quot;synStatement&quot;&gt;die&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;can&#39;t find &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$progname&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   {
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;undef&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;     &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; = &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$PROGRAM&lt;/span&gt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;s{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?xs)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # Match the opening delimiter&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.*?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # Match a minimal number of characters&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/  # Match the closing delimiter&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    |&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; # C&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; // comments&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; No s modifier&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}&lt;/span&gt;[]g;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$program&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Sigue un ejemplo de ejecución. Usaremos como entrada el programa C:</p>
<pre><code>casiano@tonga:~/Lperltesting$ cat -n ehello.c
     1  #include &lt;stdio.h&gt;
     2  /* first
     3  comment
     4  */
     5  main() { // A C++ comment
     6    printf(&quot;hello world!\n&quot;); /* second comment */
     7  } // final comment</code></pre>
<p>Al ejecutar el programa eliminamos los comentarios:</p>
<pre><code>casiano@tonga:~/Lperltesting$ extendedcomments.pl ehello.c | cat -n
     1  #include &lt;stdio.h&gt;
     2
     3  main() {
     4    printf(&quot;hello world!\n&quot;);
     5  }</code></pre>
<h3 id="subsection:lookaheadlookbehind">Mirando hacia adetrás y hacia adelante</h3>
<p>El siguiente fragmento esta ’casi’ literalmente tomado de :</p>
<p>In Perl regular expressions, most regexp elements ’eat up’ a certain amount of string when they match. For instance, the regexp element <code>[abc}]</code> eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don’t eat up characters (advance the character position) if they match.</p>
<p>The examples we have seen so far are the anchors. The anchor <code>^</code> matches the beginning of the line, but doesn’t eat any characters.</p>
<p>Similarly, the word boundary anchor <code>\b</code> matches wherever a character matching <code>\w</code> is next to a character that doesn’t, but it doesn’t eat up any characters itself.</p>
<p>Anchors are examples of . Zero-width, because they consume no characters, and assertions, because they test some property of the string.</p>
<p>In the context of our walk in the woods analogy to regexp matching, most regexp elements move us along a trail, but anchors have us stop a moment and check our surroundings. If the local environment checks out, we can proceed forward. But if the local environment doesn’t satisfy us, we must backtrack.</p>
<p>Checking the environment entails either looking ahead on the trail, looking behind, or both.</p>
<ul>
<li><p><code>^</code> looks behind, to see that there are no characters before.</p></li>
<li><p><code>$</code> looks ahead, to see that there are no characters after.</p></li>
<li><p><code>\b</code> looks both ahead and behind, to see if the characters on either side differ in their “word-ness”.</p></li>
</ul>
<p>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for.</p>
<p>The lookahead assertion is denoted by <code>(?=regexp)</code> and the lookbehind assertion is denoted by <code>(?&lt;=fixed-regexp)</code>.</p>
<p>En español, operador de “trailing” o “mirar-adelante” positivo. Por ejemplo, <code>/\w+(?=\t)/</code> solo casa una palabra si va seguida de un tabulador, pero el tabulador no formará parte de <code>$&amp;</code>. Ejemplo:</p>
<pre><code>&gt; cat -n lookahead.pl
   1  #!/usr/bin/perl
   2  
   3   $a = &quot;bugs the rabbit&quot;;
   4   $b = &quot;bugs the frog&quot;;
   5   if ($a =~ m{bugs(?= the cat| the rabbit)}i) { print &quot;$a matches. \$&amp; = $&amp;\n&quot;; }
   6   else { print &quot;$a does not match\n&quot;; }
   7   if ($b =~ m{bugs(?= the cat| the rabbit)}i) { print &quot;$b matches. \$&amp; = $&amp;\n&quot;; }
   8   else { print &quot;$b does not match\n&quot;; }</code></pre>
<pre><code>
&lt;pre&gt;
&gt; cat -n lookahead.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;  &lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;bugs the rabbit&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;  &lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;bugs the frog&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m{&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;bugs&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?=&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; the cat| the rabbit&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}i&lt;/span&gt;) { &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; matches. &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp; = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;; }
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; does not match&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;; }
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m{&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;bugs&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?=&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; the cat| the rabbit&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}i&lt;/span&gt;) { &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; matches. &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp; = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;; }
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$b&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; does not match&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;; }
&lt;/pre&gt;</code></pre>
<p>Al ejecutar el programa obtenemos:</p>
<pre><code>&gt; lookahead.pl
bugs the rabbit matches. $&amp; = bugs
bugs the frog does not match
&gt;</code></pre>
<p>Some examples using the debugger<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>:</p>
<pre><code>  DB&lt;1&gt;      #012345678901234567890
  DB&lt;2&gt; $x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;
  DB&lt;3&gt; print &quot;($&amp;) (&quot;.pos($x).&quot;)\n&quot; if $x  =~ /cat(?=\s)/g
(cat) (20)                    # matches &#39;cat&#39; in &#39;housecat&#39;

  DB&lt;5&gt; $x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot; # To reset pos
  DB&lt;6&gt; x @catwords = ($x =~ /(?&lt;=\s)cat\w+/g)
0  &#39;catch&#39;
1  &#39;catnip&#39;

  DB&lt;7&gt;      #012345678901234567890123456789
  DB&lt;8&gt; $x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;
  DB&lt;9&gt; print &quot;($&amp;) (&quot;.pos($x).&quot;)\n&quot; if $x =~ /\bcat\b/g
(cat) (29) # matches &#39;cat&#39; in &#39;Tom-cat&#39;

  DB&lt;10&gt; $x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;
  DB&lt;11&gt; x  $x =~ /(?&lt;=\s)cat(?=\s)/
  empty array
  DB&lt;12&gt; # doesn&#39;t match; no isolated &#39;cat&#39; in middle of $x</code></pre>
<pre><code>&lt;pre&gt;
  DB&lt;1&gt;  &lt;span class=&quot;dbuser&quot;&gt;     #012345678901234567890&lt;/span&gt;
  DB&lt;2&gt;  &lt;span class=&quot;dbuser&quot;&gt;$x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;&lt;/span&gt;
  DB&lt;3&gt;  &lt;span class=&quot;dbuser&quot;&gt;print &quot;($&amp;) (&quot;.pos($x).&quot;)\n&quot; if $x  =~ /cat(?=\s)/g&lt;/span&gt;
(cat) (20)                    # matches &#39;cat&#39; in &#39;housecat&#39;

  DB&lt;5&gt;  &lt;span class=&quot;dbuser&quot;&gt;$x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot; # To reset pos&lt;/span&gt;
  DB&lt;6&gt;  &lt;span class=&quot;dbuser&quot;&gt;x @catwords = ($x =~ /(?&lt;=\s)cat\w+/g)&lt;/span&gt;
0  &#39;catch&#39;
1  &#39;catnip&#39;

  DB&lt;7&gt;  &lt;span class=&quot;dbuser&quot;&gt;     #012345678901234567890123456789&lt;/span&gt;
  DB&lt;8&gt;  &lt;span class=&quot;dbuser&quot;&gt;$x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;&lt;/span&gt;
  DB&lt;9&gt;  &lt;span class=&quot;dbuser&quot;&gt;print &quot;($&amp;) (&quot;.pos($x).&quot;)\n&quot; if $x =~ /\bcat\b/g&lt;/span&gt;
(cat) (29) # matches &#39;cat&#39; in &#39;Tom-cat&#39;

  DB&lt;10&gt;  &lt;span class=&quot;dbuser&quot;&gt;$x = &quot;I catch the housecat &#39;Tom-cat&#39; with catnip&quot;&lt;/span&gt;
  DB&lt;11&gt;  &lt;span class=&quot;dbuser&quot;&gt;x  $x =~ /(?&lt;=\s)cat(?=\s)/&lt;/span&gt;
  empty array
  DB&lt;12&gt;  &lt;span class=&quot;dbuser&quot;&gt;# doesn&#39;t match; no isolated &#39;cat&#39; in middle of $x&lt;/span&gt;
&lt;/pre&gt;</code></pre>
<p>Véase el nodo <span><em>A hard RegEx problem</em></span> en . Un monje solicita:</p>
<blockquote>
<p>Hi Monks,</p>
<p>I wanna to match this issues:</p>
<ol>
<li><p>The string length is between 3 and 10</p></li>
<li><p>The string ONLY contains [0-9] or [a-z] or [A-Z], but</p></li>
<li><p>The string must contain a number AND a letter at least</p></li>
</ol>
<p>Pls help me check. Thanks</p>
</blockquote>
<p>Solución:</p>
<pre><code>casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x &#39;aaa2a1&#39; =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
  DB&lt;2&gt; x &#39;aaaaaa&#39; =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;3&gt; x &#39;1111111&#39; =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;4&gt; x &#39;1111111bbbbb&#39; =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB&lt;5&gt; x &#39;111bbbbb&#39; =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1</code></pre>
<p>Note that the parentheses in <code>(?=regexp)</code> and <code>(?&lt;=regexp)</code> are non-capturing, since these are zero-width assertions.</p>
<p>Lookahead <code>(?=regexp)</code> can match arbitrary regexps, but lookbehind <code>(?&lt;=fixed-regexp)</code> only works for regexps of fixed width, i.e., a fixed number of characters long.</p>
<p>Thus <code>(?&lt;=(ab|bc))</code> is fine, but <code>(?&lt;=(ab)*)</code> is not.</p>
<p>The negated versions of the lookahead and lookbehind assertions are denoted by <code>(?!regexp)</code> and <code>(?&lt;!fixed-regexp)</code> respectively. They evaluate true if the regexps do not match:</p>
<pre><code>    $x = &quot;foobar&quot;;
    $x =~ /foo(?!bar)/;  # doesn&#39;t match, &#39;bar&#39; follows &#39;foo&#39;
    $x =~ /foo(?!baz)/;  # matches, &#39;baz&#39; doesn&#39;t follow &#39;foo&#39;
    $x =~ /(?&lt;!\s)foo/;  # matches, there is no \s before &#39;foo&#39;</code></pre>
<p>Here is an example where a string containing blank-separated words, numbers and single dashes is to be split into its components.</p>
<p>Using <code>/\s+/</code> alone won’t work, because spaces are not required between dashes, or a word or a dash. Additional places for a split are established by looking ahead and behind:</p>
<pre><code>casiano@tonga:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $str = &quot;one two - --6-8&quot;
  DB&lt;2&gt; x @toks = split / \s+ | (?&lt;=\S) (?=-) | (?&lt;=-)  (?=\S)/x, $str
0  &#39;one&#39;
1  &#39;two&#39;
2  &#39;-&#39;
3  &#39;-&#39;
4  &#39;-&#39;
5  6
6  &#39;-&#39;
7  8</code></pre>
<p>El siguiente párrafo ha sido extraído . Usémoslo como texto de repaso:</p>
<blockquote>
<p>Look-around assertions are zero width patterns which match a specific pattern without including it in <code>$&amp;</code>. Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Look-behind matches text up to the current match position, look-ahead matches text following the current match position.</p>
<ul>
<li><p><code>(?=pattern)</code></p>
<p>A zero-width positive look-ahead assertion. For example, <code>/\w+(?=\t)/</code> matches a word followed by a tab, without including the tab in <code>$&amp;</code>.</p></li>
<li><p><code>(?!pattern)</code></p>
<p>A zero-width negative look-ahead assertion. For example <code>/foo(?!bar)/</code> matches any occurrence of <code>foo</code> that isn’t followed by <code>bar</code>.</p>
<p>Note however that look-ahead and look-behind are NOT the same thing. You cannot use this for look-behind.</p>
<p>If you are looking for a <code>bar</code> that isn’t preceded by a <code>foo</code>, <code>/(?!foo)bar/</code> will not do what you want.</p>
<p>That’s because the <code>(?!foo)</code> is just saying that the next thing cannot be <code>foo</code> –and it’s not, it’s a <code>bar</code>, so <code>foobar</code> will match.</p>
<p>You would have to do something like <code>/(?!foo)...bar/</code> for that.</p>
<p>We say “like” because there’s the case of your <code>bar</code> not having three characters before it.</p>
<p>You could cover that this way: <code>/(?:(?!foo)...|^.{0,2})bar/</code>. Sometimes it’s still easier just to say:</p>
<pre><code>    if (/bar/ &amp;&amp; $` !~ /foo$/)</code></pre>
<p>For look-behind see below.</p></li>
<li><p><code>(?&lt;=pattern)</code></p>
<p>A zero-width positive look-behind assertion.</p>
<p>For example, <code>/(?&lt;=\t)\w+/</code> matches a word that follows a tab, without including the tab in <code>$&amp;</code>. Works only for fixed-width look-behind.</p></li>
<li><p><code>\K</code></p>
<p>There is a special form of this construct, called <code>\K</code> , which causes the regex engine to ’keep’ everything it had matched prior to the <code>\K</code> and not include it in <code>$&amp;</code>. This effectively provides variable length look-behind. The use of <code>\K</code> inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</p>
<p>For various reasons <code>\K</code> may be significantly more efficient than the equivalent <code>(?&lt;=...)</code> construct, and it is especially useful in situations where you want to efficiently remove something following something else in a string. For instance</p>
<pre><code>  s/(foo)bar/$1/g;</code></pre>
<p>can be rewritten as the much more efficient</p>
<pre><code>  s/foo\Kbar//g;</code></pre>
<p>Sigue una sesión con el depurador que ilustra la semántica del operador:</p>
<pre><code>casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /([^aeiou][a-z][aeiou])[a-z]/
&amp; = &lt;phab&gt; 1 = &lt;pha&gt;
  DB&lt;2&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /\K([^aeiou][a-z][aeiou])[a-z]/
&amp; = &lt;phab&gt; 1 = &lt;pha&gt;
  DB&lt;3&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /([^aeiou]\K[a-z][aeiou])[a-z]/
&amp; = &lt;hab&gt; 1 = &lt;pha&gt;
  DB&lt;4&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /([^aeiou][a-z]\K[aeiou])[a-z]/
&amp; = &lt;ab&gt; 1 = &lt;pha&gt;
  DB&lt;5&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /([^aeiou][a-z][aeiou])\K[a-z]/
&amp; = &lt;b&gt; 1 = &lt;pha&gt;
  DB&lt;6&gt; print &quot;&amp; = &lt;$&amp;&gt; 1 = &lt;$1&gt;\n&quot; if &quot;alphabet&quot; =~ /([^aeiou][a-z][aeiou])[a-z]\K/
&amp; = &lt;&gt; 1 = &lt;pha&gt;
  DB&lt;7&gt; @a = &quot;alphabet&quot; =~ /([aeiou]\K[^aeiou])/g; print &quot;$&amp;\n&quot;
t
  DB&lt;8&gt; x @a
0  &#39;al&#39;
1  &#39;ab&#39;
2  &#39;et&#39;</code></pre>
<p>Otro ejemplo: eliminamos los blancos del final en una cadena:</p>
<pre><code>  DB&lt;23&gt; $x = &#39;  cadena entre blancos  &#39;
  DB&lt;24&gt; ($y = $x) =~ s/.*\b\K.*//g
  DB&lt;25&gt; p &quot;&lt;$y&gt;&quot;
&lt;  cadena entre blancos&gt;</code></pre></li>
<li><p><code>(?&lt;!pattern)</code></p>
<p>A zero-width negative look-behind assertion.</p>
<p>For example <code>/(?&lt;!bar)foo/</code> matches any occurrence of <code>foo</code> that does not follow <code>bar</code>. Works only for fixed-width look-behind.</p></li>
</ul>
</blockquote>
<p>Veamos un ejemplo de uso. Se quiere sustituir las extensiones <code>.something</code> por <code>.txt</code> en cadenas que contienen una ruta a un fichero:</p>
<pre><code>casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; ($b = $a = &#39;abc/xyz.something&#39;) =~ s{\.[^.]*$}{.txt}
  DB&lt;2&gt; p $b
abc/xyz.txt
  DB&lt;3&gt; ($b = $a = &#39;abc/xyz.something&#39;) =~ s/\.\K[^.]*$/txt/;
  DB&lt;4&gt; p $b
abc/xyz.txt
  DB&lt;5&gt; p $a
abc/xyz.something</code></pre>
<p>Véase también:</p>
<ul>
<li><p>por Jeff Pinyan</p></li>
<li><p>El nodo <span><em>positive look behind regexp mystery</em></span> en</p></li>
</ul>
<p>Escriba una expresión regular que encuentre la última aparición de la cadena <code>foo</code> en una cadena dada.</p>
<pre><code>  DB&lt;6&gt; x ($a = &#39;foo foo bar bar foo bar bar&#39;) =~ /foo(?!.*foo)/g; print pos($a).&quot;\n&quot;
19
  DB&lt;7&gt; x ($a = &#39;foo foo bar bar foo bar bar&#39;) =~ s/foo(?!.*foo)/\U$&amp;/
0  1
  DB&lt;8&gt; x $a
0  &#39;foo foo bar bar FOO bar bar&#39;</code></pre>
<p>Aparentemente el operador “mirar-adelante” negativo es parecido a usar el operador “mirar-adelante” positivo con la negación de una clase.</p>
<p><span>p<span>4cm</span>|p<span>4cm</span></span></p>
<pre><code>/regexp(?![abc])/</code></pre>
<p>&amp;</p>
<pre><code>/regexp(?=[^abc])/</code></pre>
<p><br /></p>
<p>Sin embargo existen al menos dos diferencias:</p>
<ul>
<li><p>Una negación de una clase debe casar algo para tener éxito. Un ‘mirar-adelante’’ negativo tiene éxito si, en particular no logra casar con algo. Por ejemplo:</p>
<p><code>\d+(?!\.)</code> casa con <code>$a = '452'</code>, mientras que <code>\d+(?=[^.])</code> lo hace, pero porque <code>452</code> es <code>45</code> seguido de un carácter que no es el punto:</p>
<pre><code>&gt; cat lookaheadneg.pl
#!/usr/bin/perl

 $a = &quot;452&quot;;
 if ($a =~ m{\d+(?=[^.])}i) { print &quot;$a casa clase negada. \$&amp; = $&amp;\n&quot;; }
 else { print &quot;$a no casa\n&quot;; }
 if ($a =~ m{\d+(?!\.)}i) { print &quot;$a casa predicción negativa. \$&amp; = $&amp;\n&quot;; }
 else { print &quot;$b no casa\n&quot;; }
nereida:~/perl/src&gt; lookaheadneg.pl
452 casa clase negada. $&amp; = 45
452 casa predicción negativa. $&amp; = 452</code></pre></li>
<li><p>Una clase negada casa un único carácter. Un ‘mirar-adelante’’ negativo puede tener longitud arbitraria.</p></li>
</ul>
<p>Otros dos ejemplos:</p>
<ul>
<li><p><code>^(?![A-Z]*$)[a-zA-Z]*$</code></p>
<p>casa con líneas formadas por secuencias de letras tales que no todas son mayúsculas. (Obsérvese el uso de las anclas).</p></li>
<li><p><code>^(?=.*?esto)(?=.*?eso)</code></p>
<p>casan con cualquier línea en la que aparezcan <code>esto</code> y <code>eso</code>. Ejemplo:</p>
<pre><code>&gt; cat estoyeso.pl
#!/usr/bin/perl

 my $a = shift;

 if ($a =~ m{^(?=.*?esto)(?=.*?eso)}i) { print &quot;$a matches.\n&quot;; }
 else { print &quot;$a does not match\n&quot;; }

&gt;estoyeso.pl &#39;hola eso y esto&#39;
hola eso y esto matches.
&gt; estoyeso.pl &#39;hola esto y eso&#39;
hola esto y eso matches.
&gt; estoyeso.pl &#39;hola aquello y eso&#39;
hola aquello y eso does not match
&gt; estoyeso.pl &#39;hola esto y aquello&#39;
hola esto y aquello does not match</code></pre>
<p>El ejemplo muestra que la interpretación es que cada operador mirar-adelante se interpreta siempre a partir de la posición actual de búsqueda. La expresión regular anterior es básicamente equivalente a <code>(/esto/ &amp;&amp; /eso/)</code>.</p></li>
<li><p><code>(?!000)(\d\d\d)</code></p>
<p>casa con cualquier cadena de tres dígitos que no sea la cadena <code>000</code>.</p></li>
</ul>
<p>Nótese que el “mirar-adelante” negativo no puede usarse fácilmente para imitar un “mirar-atrás”, esto es, que no se puede imitar la conducta de <code>(?&lt;!foo)bar</code> mediante algo como <code>(/?!foo)bar</code>. Tenga en cuenta que:</p>
<ul>
<li><p>Lo que dice <code>(?!foo)</code> es que los tres caracteres que siguen no puede ser <code>foo</code>.</p></li>
<li><p>Así, <code>foo</code> no pertenece a <code>/(?!foo)bar/</code>, pero <code>foobar</code> pertenece a <code>(?!foo)bar/</code> porque <code>bar</code> es una cadena cuyos tres siguientes caracteres son <code>bar</code> y no son <code>foo</code>.</p></li>
<li><p>Si quisieramos conseguir algo parecido a <code>(?&lt;!foo)bar</code> usando un lookahead negativo tendríamos que escribir algo asi como <code>/(?!foo)...bar/</code> que casa con una cadena de tres caracteres que no sea <code>foo</code> seguida de <code>bar</code> (pero que tampoco es exactamente equivalente):</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n foobar.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $a = shift;
     5
     6  for my $r (q{(?&lt;!foo)bar}, q{(?!foo)bar}, q{(?!foo)...bar}) {
     7    if ($a =~ /$r/) {
     8      say &quot;$a casa con $r&quot;
     9    }
    10    else {
    11      say &quot;$a no casa con $r&quot;
    12    }
    13  }</code></pre></li>
<li><p>Al ejecutar con diferentes entradas el programa anterior vemos que la solución <code>q{(?!foo)...bar}</code> se apróxima mas a <code>(q{(?&lt;!foo)bar}</code>:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl foobar
foobar no casa con (?&lt;!foo)bar
foobar casa con (?!foo)bar
foobar no casa con (?!foo)...bar

pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl bar
bar casa con (?&lt;!foo)bar
bar casa con (?!foo)bar
bar no casa con (?!foo)...bar</code></pre>
<p>Explique porqué <code>bar</code> casa con <code>(?&lt;!foo)bar</code> pero no con <code>(?!foo)...bar</code>. ¿Sabría encontrar una expresión regular mas apropiada usando lookahead negativo?</p></li>
<li><p>En realidad, posiblemente sea mas legible una solución como:</p>
<pre><code>        if (/bar/ and $` !~ /foo$/) </code></pre>
<p>o aún mejor (véase [parrafo:prematch]):</p>
<pre><code>        if (/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/)</code></pre>
<p>El siguiente programa puede ser utilizado para ilustrar la equivalencia:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n foobarprematch.pl
 1  use v5.10;
 2  use strict;
 3
 4  $_ = shift;
 5
 6  if (/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/) {
 7    say &quot;$_ no cumple &quot;.q{/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/};
 8  }
 9  else {
10    say &quot;$_ cumple &quot;.q{/bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/};
11  }
12  if (/(?&lt;!foo)bar/) {
13    say &quot;$_ casa con (?&lt;!foo)bar&quot;
14  }
15  else {
16    say &quot;$_ no casa con (?&lt;!foo)bar&quot;
17  }</code></pre>
<p>Siguen dos ejecuciones:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl bar
bar cumple /bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/
bar casa con (?&lt;!foo)bar
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl foobar
foobar no cumple /bar/p &amp;&amp; ${^PREMATCH} =~ /foo$/
foobar no casa con (?&lt;!foo)bar</code></pre></li>
</ul>
<ul>
<li><p>Escriba una sustitución que reemplaze todas las apariciones de <code>foo</code> por <code>foo,</code> usando <code>\K</code> o lookbehind</p></li>
<li><p>Escriba una sustitución que reemplaze todas las apariciones de <code>lookahead</code> por <code>look-ahead</code> usando lookaheads y lookbehinds</p></li>
<li><p>Escriba una expresión regular que capture todo lo que hay entre las cadenas <code>foo</code> y <code>bar</code> siempre que no se incluya la palabra <code>baz</code></p></li>
<li><p>¿Cuál es la salida?</p>
<pre><code>  DB&lt;1&gt; x &#39;abc&#39; =~ /(?=(.)(.)(.))a(b)/</code></pre></li>
<li><p>Se quiere poner un espacio en blanco después de la aparición de cada coma:</p>
<pre><code>s/,/, /g;</code></pre>
<p>pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre dos dígitos.</p></li>
<li><p>Se quiere poner un espacio en blanco después de la aparición de cada coma:</p>
<pre><code>s/,/, /g;</code></pre>
<p>pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre dos dígitos. Además se pide que si hay ya un espacio después de la coma, no se duplique</p></li>
<li><p>¿Cuál es la salida?</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ABC123.pl
  1  use warnings;
  2  use strict;
  3
  4  my $c = 0;
  5  my @p = (&#39;^(ABC)(?!123)&#39;, &#39;^(\D*)(?!123)&#39;,);
  6
  7  for my $r (@p) {
  8    for my $s (qw{ABC123 ABC445}) {
  9      $c++;
 10      print &quot;$c: &#39;$s&#39; =~ /$r/ : &quot;;
 11      &lt;&gt;;
 12      if ($s =~ /$r/) {
 13        print &quot; YES ($1)\n&quot;;
 14      }
 15      else {
 16        print &quot; NO\n&quot;;
 17      }
 18    }
 19  }</code></pre>
<pre><code>
&lt;pre&gt;
pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat -n ABC123&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     1  use warnings;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     2  use strict;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     3&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     4  my &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$c&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = 0;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     5  my &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@p&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39;^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;ABC&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)(?!&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39;, &#39;^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\D*)(?!&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39;,&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     6&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     7  for my &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@p&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; {&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     8    for my &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;qw{ABC123 ABC445}&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; {&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     9      &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$c&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    10      print &amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$c&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;: &#39;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39; =~ &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;/ : &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    11      &amp;lt;&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    12      if (&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =~ /&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/) {&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    13        print &amp;quot;&lt;/span&gt; YES (&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;)\n&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    14      }&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    15      else {&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    16        print &amp;quot;&lt;/span&gt; NO\n&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    17      }&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    18    }&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    19  }&lt;/span&gt;
&lt;/pre&gt;</code></pre></li>
</ul>
<h3 id="definición-de-nombres-de-patrones">Definición de Nombres de Patrones</h3>
<p>Perl 5.10 introduce la posibilidad de definir subpatrones en una sección del patrón.</p>
<p>Citando la sección <span><em>Defining named patterns</em></span> en el documento para perl5.10:</p>
<blockquote>
<p>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is <code>&quot;(?(DEFINE)(?&lt;name&gt;pattern)...)&quot;</code> An insertion of a named pattern is written as <code>(?&amp;name)</code>.</p>
</blockquote>
<p>Veamos un ejemplo que define el lenguaje de los números en punto flotante:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n definingnamedpatterns.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3
 4  my $regexp = qr{
 5     ^ (?&lt;num&gt;
 6               (?&amp;osg)[\t\ ]* (?: (?&amp;int)(?&amp;dec)? | (?&amp;dec) )
 7       )
 8       (?: [eE]
 9       (?&lt;exp&gt; (?&amp;osg)(?&amp;int)) )?
10     $
11        (?(DEFINE)
12         (?&lt;osg&gt;[-+]?)         # optional sign
13         (?&lt;int&gt;\d++)          # integer
14         (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction
15        )
16  }x;
17
18  my $input = &lt;&gt;;
19  chomp($input);
20  my @r;
21  if (@r = $input =~ $regexp) {
22    my $exp = $+{exp} || &#39;&#39;;
23    say &quot;$input matches: (num =&gt; &#39;$+{num}&#39;, exp =&gt; &#39;$exp&#39;)&quot;;
24  }
25  else {
26    say &quot;does not match&quot;;
27  }</code></pre>
<p>comenta sobre este ejemplo:</p>
<blockquote>
<p>The example above illustrates this feature. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The <code>DEFINE</code> group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</p>
</blockquote>
<p>Curiosamente, <code>(DEFINE)</code> se considera un caso particular de las expresiones regulares condicionales de la forma <code>(?(condition)yes-pattern)</code> (véase la sección [subsection:regexpcondicionales]). Esto es lo que dice al respecto:</p>
<blockquote>
<p>A special form is the <code>(DEFINE)</code> predicate, which never executes directly its yes-pattern, and does not allow a no-pattern. This allows to define subpatterns which will be executed only by using the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</p>
<p>It is recommended that for this usage you put the <code>DEFINE</code> block at the end of the pattern, and that you name any subpatterns defined within it.</p>
<p>Also, it’s worth noting that patterns defined this way probably will not be as efficient, as the optimiser is not very clever about handling them.</p>
<p>An example of how this might be used is as follows:</p>
<pre><code>   1. /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
   2.        (?(DEFINE)
   3.          (?&lt;NAME_PAT&gt;....)
   4.          (?&lt;ADRESS_PAT&gt;....)
   5. )/x</code></pre>
<p>Note that <span><strong>capture buffers matched inside of recursion are not accessible after the recursion returns</strong></span>, so the extra layer of capturing buffers is necessary. Thus <code>$+{NAME_PAT}</code> would not be defined even though <code>$+{NAME}</code> would be.</p>
</blockquote>
<p>Esto es lo que dice respecto a las variables implicadas <code>%+</code> y <code>%-</code>. Con respecto a el hash <code>%+</code>:</p>
<blockquote>
<ul>
<li><p><code>%LAST_PAREN_MATCH</code>, <code>%+</code></p>
<p>Similar to <code>@+</code> , the <code>%+</code> hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</p>
<p>For example, <code>$+{foo}</code> is equivalent to <code>$1</code> after the following match:</p>
<pre><code>   1. &#39;foo&#39; =~ /(?&lt;foo&gt;foo)/;</code></pre>
<p>The keys of the <code>%+</code> hash list only the names of buffers that have captured (and that are thus associated to defined values).</p>
<p>The underlying behaviour of <code>%+</code> is provided by the module.</p>
<p>Note: <code>%-</code> and <code>%+</code> are tied views into a common internal hash associated with the last successful regular expression. Therefore mixing iterative access to them via <code>each</code> may have unpredictable results. Likewise, if the last successful match changes, then the results may be surprising.</p></li>
<li><p><code>%-</code></p>
<p>Similar to <code>%+</code> , this variable allows access to the named capture buffers in the last successful match in the currently active dynamic scope. <span><strong>To each capture buffer name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear</strong></span>.</p>
<p>Here’s an example:</p>
<pre><code>   1. if (&#39;1234&#39; =~ /(?&lt;A&gt;1)(?&lt;B&gt;2)(?&lt;A&gt;3)(?&lt;B&gt;4)/) {
   2.   foreach my $bufname (sort keys %-) {
   3.     my $ary = $-{$bufname};
   4.     foreach my $idx (0..$#$ary) {
   5.       print &quot;\$-{$bufname}[$idx] : &quot;,
   6.             (defined($ary-&gt;[$idx]) ? &quot;&#39;$ary-&gt;[$idx]&#39;&quot; : &quot;undef&quot;),
   7.             &quot;\n&quot;;
   8.     }
   9.   }
  10. }</code></pre>
<p>would print out:</p>
<pre><code>   1. $-{A}[0] : &#39;1&#39;
   2. $-{A}[1] : &#39;3&#39;
   3. $-{B}[0] : &#39;2&#39;
   4. $-{B}[1] : &#39;4&#39;</code></pre>
<p>The keys of the <code>%-</code> hash correspond to all buffer names found in the regular expression.</p></li>
</ul>
</blockquote>
<h3 id="patrones-recursivos">Patrones Recursivos</h3>
<p>Perl 5.10 introduce la posibilidad de definir subpatrones en una sección del patrón. Citando la versión del documento para perl5.10:</p>
<blockquote>
<p>This feature (introduced in Perl 5.10) significantly extends the power of Perl’s pattern matching. By referring to some other capture group anywhere in the pattern with the construct <code>(?group-ref)</code>, the pattern within the referenced group is used as an independent subpattern in place of the group reference itself. Because the group reference may be contained within the group it refers to, it is now possible to apply pattern matching to tasks that hitherto required a recursive parser.</p>
<p>...</p>
<p>In <code>(?...)</code> both absolute and relative backreferences may be used. The entire pattern can be reinserted with <code>(?R)</code> or <code>(?0)</code>. If you prefer to name your buffers, you can use <code>(?&amp;name)</code> to recurse into that buffer.</p>
</blockquote>
<p>[parrafo:palabrapalindromos]</p>
<p>Véase un ejemplo que reconoce los palabra-palíndromos (esto es, la lectura directa y la inversa de la cadena pueden diferir en los signos de puntuación):</p>
<pre><code>casiano@millo:~/Lperltesting$ cat -n palindromos.pl
  1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  2  use v5.10;
  3
  4  my $regexp = qr/^(\W*
  5                       (?:
  6                             (\w) (?1) \g{-1}  # palindromo estricto
  7                           |
  8                             \w?               # no recursiva
  9                       )
 10                    \W*)$/ix;
 11
 12  my $input = &lt;&gt;;
 13  chomp($input);
 14  if ($input =~ $regexp) {
 15    say &quot;$input is a palindrome&quot;;
 16  }
 17  else {
 18    say &quot;does not match&quot;;
 19  }</code></pre>
<pre><code>
&lt;pre&gt;
casiano&lt;span class=&quot;synIdentifier&quot;&gt;@millo&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat -n palindromos&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     1  #!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt;
     &lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
     &lt;span class=&quot;synConstant&quot;&gt;3&lt;/span&gt;
     &lt;span class=&quot;synConstant&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\W*&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     5                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     6                             &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\w)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\g&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{-1}  # palindromo estricto&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     7                           |&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     8                             &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\w?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # no recursiva&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;     9                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synConstant&quot;&gt;    10                    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\W*)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;$/ix&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;11&lt;/span&gt;
    &lt;span class=&quot;synConstant&quot;&gt;12&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
    &lt;span class=&quot;synConstant&quot;&gt;13&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
    &lt;span class=&quot;synConstant&quot;&gt;14&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
    &lt;span class=&quot;synConstant&quot;&gt;15&lt;/span&gt;    say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is a palindrome&amp;quot;&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;16&lt;/span&gt;  }
    &lt;span class=&quot;synConstant&quot;&gt;17&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;synConstant&quot;&gt;18&lt;/span&gt;    say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;19&lt;/span&gt;  }
&lt;/pre&gt;</code></pre>
<p>¿Cuál es el efecto del modificador <code>i</code> en la regexp <code>qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix</code>?</p>
<p>Siguen algunos ejemplos de ejecución<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<pre><code>pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a canal: Panama!
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cam, a yak, a yam, a canal – Panama!
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
saippuakauppias
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
dfghjgfd
does not match
pl@nereida:~/Lperltesting$ ./palindromos.pl
...,;;;;
...,;;;; is a palindrome</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;A man, a plan, a canal: Panama!&lt;/span&gt;
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;A man, a plan, a cam, a yak, a yam, a canal – Panama!&lt;/span&gt;
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!&lt;/span&gt;
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;saippuakauppias&lt;/span&gt;
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;dfghjgfd&lt;/span&gt;
does not match
&lt;span class=&quot;dbuser&quot;&gt;pl@nereida:~/Lperltesting$ ./palindromos.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;...,;;;;&lt;/span&gt;
...,;;;; is a palindrome
&lt;/pre&gt;</code></pre>
<blockquote>
<p><code>(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)</code></p>
<p>Similar to <code>(??{ code })</code> (véase la sección [subsection:tiempodematching]) except it does not involve compiling any code, instead it treats the contents of a capture buffer as an independent pattern that must match at the current position. Capture buffers contained by the pattern will have the value as determined by the outermost recursion.</p>
<p><code>PARNO</code> is a sequence of digits (not starting with 0) whose value reflects the paren-number of the capture buffer to recurse to.</p>
<p><code>(?R)</code> recurses to the beginning of the whole pattern. <code>(?0)</code> is an alternate syntax for <code>(?R)</code>.</p>
<p>If <code>PARNO</code> is preceded by a plus or minus sign then it is assumed to be relative, with negative numbers indicating preceding capture buffers and positive ones following. Thus (?-1) refers to the most recently declared buffer, and (?+1) indicates the next buffer to be declared.</p>
<p>Note that the counting for relative recursion differs from that of relative backreferences, in that with recursion unclosed buffers are included.</p>
</blockquote>
<p>Hay una diferencia fundamental entre <code>\g{-1}</code> y <code>(?-1)</code>. El primero significa <span><em>lo que casó con el último paréntesis</em></span>. El segundo significa que se debe <span><em>llamar a la expresión regular que define el último paréntesis</em></span>. Véase un ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt;  x ($a = &quot;12 aAbB 34&quot;) =~ s/([aA])(?-1)(?+1)([bB])/-\1\2-/g
0  1
  DB&lt;2&gt; p $a
12 -aB- 34</code></pre>
<p>En también se comenta sobre este punto:</p>
<blockquote>
<p>If there is no corresponding capture buffer defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</p>
</blockquote>
<p>El siguiente programa (inspirado en uno que aparece en ) reconoce una llamada a una función <code>foo()</code> que puede contener una secuencia de expresiones con paréntesis equilibrados como argumento:</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat perlrebalancedpar.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
  3  use v5.10;
  4  use strict;
  5  
  6  my $regexp = qr{ (                      # paren group 1 (full function)
  7                  foo
  8                     (                    # paren group 2 (parens)
  9                       \(
 10                          (               # paren group 3 (contents of parens)
 11                             (?:
 12                                  [^()]+  # Non-parens
 13                                |
 14                                  (?2) # Recurse to start of paren group 2
 15                             )*
 16                          )               # 3
 17                       \)
 18                      )                   # 2
 19                )                         # 1
 20      }x;
 21  
 22  my $input = &lt;&gt;;
 23  chomp($input);
 24  my @res = ($input =~ /$regexp/);
 25  if (@res) {
 26    say &quot;&lt;$&amp;&gt; is balanced\nParen: (@res)&quot;;
 27  }
 28  else {
 29    say &quot;does not match&quot;;
 30  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat perlrebalancedpar&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;#!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{ &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                      # paren group 1 &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;full function&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                foo&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                   &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                    # paren group 2 &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;parens&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # paren group 3 &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;contents of parens&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^()]+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # Non-parens&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                              |&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; # Recurse to start of paren group 2&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # 3&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                   # 2&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                         # 1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    }x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@res&lt;/span&gt; = (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;@res&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; is balanced&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Paren: (&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@res&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; }
&lt;/pre&gt;</code></pre>
<p>Al ejecutar obtenemos:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./perlrebalancedpar.pl
foo(bar(baz)+baz(bop))
&lt;foo(bar(baz)+baz(bop))&gt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$  &lt;span class=&quot;dbuser&quot;&gt;./perlrebalancedpar.pl&lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;foo(bar(baz)+baz(bop))&lt;/span&gt;
&amp;lt;foo(bar(baz)+baz(bop))&amp;gt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
&lt;/pre&gt;</code></pre>
<p>Como se comenta en es conveniente usar índices relativos si se quiere tener una expresión regular reciclable:</p>
<blockquote>
<p>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a <code>qr//</code> construct for later use:</p>
<pre><code>   1. my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
   2. if (/foo $parens \s+ + \s+ bar $parens/x) {
   3.   # do something here...
   4. }</code></pre>
</blockquote>
<p>Véase la sección [subsection:cuantificadoresposesivos] para comprender el uso de los operadores posesivos como <code>++</code>.</p>
<p>[parrafo:bloquesanidados]</p>
<p>El siguiente programa presenta una heurística para determinar los bloques de un programa:</p>
<pre><code>  1    pl@nereida:~/Lperltesting$ cat blocks.pl
  2    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3    use v5.10;
  4    use strict;
  5    #use re &#39;debug&#39;;
  6    
  7    my $rb = qr{(?x)
  8        (
  9          \{               # llave abrir
 10             (?:
 11                 [^{}]++   # no llaves
 12             |
 13                  [^{}]*+  # no llaves
 14                  (?1)     # recursivo
 15                  [^{}]*+  # no llaves
 16             )*+
 17           \}              # llave cerrar
 18        )
 19      };
 20    
 21    local $/ = undef;
 22    my $input = &lt;&gt;;
 23    my@blocks = $input =~ m{$rb}g;
 24    my $i = 0;
 25    say($i++.&quot;:\n$_\n===&quot;) for @blocks;</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat blocks&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  #!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#use re &#39;debug&#39;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$rb&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?x)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;{&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # llave abrir&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;               &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^{}]++&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;   # no llaves&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           |&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^{}]*+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # no llaves&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;     # recursivo&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^{}]*+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  # no llaves&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)*+&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;}&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;              # llave cerrar&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    }&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;   
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;undef&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@blocks&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$rb&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}g&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$i&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;   say(&lt;span class=&quot;synIdentifier&quot;&gt;$i&lt;/span&gt;++.&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;:&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;===&amp;quot;&lt;/span&gt;) &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@blocks&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Veamos una ejecución. Le daremos como entrada el siguiente programa: Al ejecutar el programa con esta entrada obtenemos:</p>
<p><span>|p<span>8cm</span>|p<span>8cm</span>|</span></p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n blocks.c
     1  main() { /* 1 */
     2    { /* 2 */ }
     3    { /* 3 */ }
     4  }
     5
     6  f(){  /* 4 */
     7    {   /* 5 */
     8      { /* 6 */ }
     9    }
    10    {   /* 7 */
    11      { /* 8 */ }
    12    }
    13  }
    14
    15  g(){ /* 9 */
    16  }
    17
    18  h() {
    19  {{{}}}
    20  }
    21  /* end h */</code></pre>
<p>&amp;</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 blocks.pl blocks.c
0:
{ /* 1 */
  { /* 2 */ }
  { /* 3 */ }
}
===
1:
{  /* 4 */
  {   /* 5 */
    { /* 6 */ }
  }
  {   /* 7 */
    { /* 8 */ }
  }
}
===
2:
{ /* 9 */
}
===
3:
{
{{{}}}
}
===</code></pre>
<p><br /></p>
<p>[subsection:regexp510lenrec]</p>
<p>La posibilidad de combinar en las expresiones regulares Perl 5.10 la recursividad con los constructos <code>(?&lt;name&gt;...)</code> y <code>?&amp;name)</code> así como las secciones <code>(?(DEFINE) ...)</code> permiten la escritura de expresiones regulares que reconocen lenguajes recursivos. El siguiente ejemplo muestra un reconocedor de un subconjunto del lenguaje LaTeX (véase ):</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat latex5_10.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use strict;
  4  use v5.10;
  5  
  6  my $regexp = qr{
  7      \A(?&amp;File)\z
  8  
  9      (?(DEFINE)
 10          (?&lt;File&gt;     (?&amp;Element)*+\s*
 11          )
 12  
 13          (?&lt;Element&gt;  \s* (?&amp;Command)
 14                    |  \s* (?&amp;Literal)
 15          )
 16  
 17          (?&lt;Command&gt;  \\ \s* (?&lt;L&gt;(?&amp;Literal)) \s* (?&lt;Op&gt;(?&amp;Options)?) \s* (?&lt;A&gt;(?&amp;Args))
 18             (?{
 19                say &quot;command: &lt;$+{L}&gt; options: &lt;$+{Op}&gt; args: &lt;$+{A}&gt;&quot;
 20             })
 21          )
 22  
 23          (?&lt;Options&gt;  \[ \s* (?:(?&amp;Option) (?:\s*,\s* (?&amp;Option) )*)? \s* \]
 24          )
 25  
 26          (?&lt;Args&gt;     (?: \{ \s* (?&amp;Element)* \s* \} )*
 27          )
 28  
 29          (?&lt;Option&gt;   \s* [^][\$&amp;%#_{}~^\s,]+
 30          )
 31  
 32          (?&lt;Literal&gt;  \s* ([^][\$&amp;%#_{}~^\s]+)
 33          )
 34      )
 35  }xms;
 36  
 37  my $input = do{ local $/; &lt;&gt;};
 38  if ($input =~ $regexp) {
 39    say &quot;$@: matches:\n$&amp;&quot;;
 40  }
 41  else {
 42    say &quot;does not match&quot;;
 43  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat latex5_10&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;#!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\A(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;File&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)\z&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;DEFINE&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;File&amp;gt;     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Element&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)*+\s*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;Element&amp;gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Command&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                  |  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Literal&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;Command&amp;gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;L&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Literal&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;Op&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Options&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)?)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;A&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;Args&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              say &amp;quot;command: &amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{L}&lt;/span&gt;&amp;gt; options: &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{Op}&amp;gt; args: &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{A}&amp;gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           })&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        (?&amp;lt;Options&amp;gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\[&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* (?:(?&amp;amp;Option) (?:&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;*,&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* (?&amp;amp;Option) )*)? &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\]&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        (?&amp;lt;Args&amp;gt;     (?: &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;{&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* (?&amp;amp;Element)* &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;}&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; )*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        (?&amp;lt;Option&amp;gt;   &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* [^][&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;%#_{}~^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;,]+&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        (?&amp;lt;Literal&amp;gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;* ([^][&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;%#_{}~^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;]+)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;}xms;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;my &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = do{ local &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;; &amp;lt;&amp;gt;};&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;if (&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;) {&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  say &amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$@&lt;/span&gt;: matches:\n&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;else {&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  say &amp;quot;&lt;/span&gt;does &lt;span class=&quot;synStatement&quot;&gt;not&lt;/span&gt; match&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;</code></pre>
<p>Añadimos una acción semántica al final de la aceptación de un <code>&lt;Command&gt;</code>.</p>
<pre><code>         (?&lt;Command&gt;  \\ \s* (?&lt;L&gt;(?&amp;Literal)) \s* (?&lt;Op&gt;(?&amp;Options)?) \s* (?&lt;A&gt;(?&amp;Args)?)
            (?{
               say &quot;command: &lt;$+{L}&gt; options: &lt;$+{Op}&gt; args: &lt;$+{A}&gt;&quot;
            })
         )</code></pre>
<p>Esta acción es ejecutada pero no afecta al proceso de análisis. (véase la sección [subsection:codigoenregexp] para mas información sobre las acciones semánticas en medio de una regexp). La acción se limita a mostrar que ha casado con cada una de las tres componentes: el comando, las opciones y los argumentos.</p>
<p>Los paréntesis adicionales, como en <code>(?&lt;L&gt;(?&amp;Literal))</code> son necesarios para guardar lo que casó.</p>
<p>Cuando se ejecuta produce la siguiente salida<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat prueba.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it&#39;s easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba.tex
command: &lt;documentclass&gt; options: &lt;[a4paper,11pt]&gt; args: &lt;{article}&gt;
command: &lt;usepackage&gt; options: &lt;&gt; args: &lt;{latexsym}&gt;
command: &lt;author&gt; options: &lt;&gt; args: &lt;{D. Conway}&gt;
command: &lt;LaTeX&gt; options: &lt;&gt; args: &lt;{}&gt;
command: &lt;title&gt; options: &lt;&gt; args: &lt;{Parsing \LaTeX{}}&gt;
command: &lt;begin&gt; options: &lt;&gt; args: &lt;{document}&gt;
command: &lt;maketitle&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;tableofcontents&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;section&gt; options: &lt;&gt; args: &lt;{Description}&gt;
command: &lt;emph&gt; options: &lt;&gt; args: &lt;{necessarily}&gt;
command: &lt;footnote&gt; options: &lt;&gt; args: &lt;{But not\\ \emph{necessarily} simple}&gt;
command: &lt;end&gt; options: &lt;&gt; args: &lt;{document}&gt;
: matches:
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it&#39;s easy peasy to do.
\end{document}</code></pre>
<p>La siguiente entrada <code>prueba3.tex</code> no pertenece al lenguaje definido por el patrón regular, debido a la presencia de la cadena <code>$In$</code> en la última línea:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat prueba3.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
\comm{a}{b}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
$In$ fact it&#39;s easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba3.tex
command: &lt;documentclass&gt; options: &lt;[a4paper,11pt]&gt; args: &lt;{article}&gt;
command: &lt;usepackage&gt; options: &lt;&gt; args: &lt;{latexsym}&gt;
command: &lt;author&gt; options: &lt;&gt; args: &lt;{D. Conway}&gt;
command: &lt;LaTeX&gt; options: &lt;&gt; args: &lt;{}&gt;
command: &lt;title&gt; options: &lt;&gt; args: &lt;{Parsing \LaTeX{}}&gt;
command: &lt;begin&gt; options: &lt;&gt; args: &lt;{document}&gt;
command: &lt;maketitle&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;tableofcontents&gt; options: &lt;&gt; args: &lt;&gt;
command: &lt;section&gt; options: &lt;&gt; args: &lt;{Description}&gt;
command: &lt;comm&gt; options: &lt;&gt; args: &lt;{a}{b}&gt;
command: &lt;emph&gt; options: &lt;&gt; args: &lt;{necessarily}&gt;
command: &lt;footnote&gt; options: &lt;&gt; args: &lt;{But not\\ \emph{necessarily} simple}&gt;
does not match</code></pre>
<p>Obsérvese el uso del cuantificador posesivo en:</p>
<pre><code> 10          (?&lt;File&gt;     (?&amp;Element)*+\s*
 11          )</code></pre>
<p>¿Que ocurrre si se quita el posesivo y se vuelve a ejecutar <code>$ ./latex5_10.pl prueba3.tex</code>?</p>
<p>Véase el nodo en perlmonks para la formulación del problema. Un monje pregunta:</p>
<blockquote>
<p>Hiya monks,</p>
<p>Im having trouble getting my head around a regular expression to match sequences. I need to catch all exceptions where a mathematical expression is illegal...</p>
<p>There must be either a letter or a digit either side of an operator parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist variables must not be more than one letter Nothing other than <code>a-z,A-Z,0-9,+,-,*,/,(,)</code> can be used</p>
<p>Can anyone offer a hand on how best to tackle this problem?</p>
<p>many thanks</p>
</blockquote>
<p>La solución parte de que una <span><em>expresión</em></span> es o bien un <span><em>término</em></span> o bien un <span><em>término</em></span> seguido de una operador y un <span><em>término</em></span>, esto es:</p>
<ul>
<li><p><code>termino</code></p></li>
<li><p><code>termino op termino op termino</code> …</p></li>
</ul>
<p>que puede ser unificado como <code>termino (op termino)*</code>.</p>
<p>Un <span><em>término</em></span> es un número o un identificador o una <span><em>expresión</em></span> entre paréntesis, esto es:</p>
<ul>
<li><p><code>numero</code></p></li>
<li><p><code>identificador</code></p></li>
<li><p><code> ( expresión ) </code></p></li>
</ul>
<p>La siguiente expresión regular recursiva sigue esta idea:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    local our ($skip, $term, $expr);
  7    $skip = qr/\s*/;
  8    $expr = qr{ (?&lt;EXPR&gt;
  9                       (?&lt;TERM&gt;              # An expression is a TERM  ...
 10                              $skip (?&lt;ID&gt;[a-zA-Z]+)
 11                            | $skip (?&lt;INT&gt;[1-9]\d*)
 12                            | $skip \(
 13                              $skip  (?&amp;EXPR)
 14                              $skip \)
 15                       ) (?: $skip           # possibly followed by a sequence of ...
 16                             (?&lt;OP&gt;[-+*/])
 17                             (?&amp;TERM)        # ... operand TERM pairs
 18                         )*
 19                )
 20              }x;
 21    my $re = qr/^ $expr $skip \z/x;
 22    sub is_valid { shift =~ /$re/o }
 23  
 24    my @test = ( &#39;(a + 3)&#39;, &#39;(3 * 4)+(b + x)&#39;, &#39;(5 - a)*z&#39;,
 25                  &#39;((5 - a))*((((z)))+2)&#39;, &#39;3 + 2&#39;, &#39;!3 + 2&#39;, &#39;3 + 2!&#39;,
 26                  &#39;3 a&#39;, &#39;3 3&#39;, &#39;3 * * 3&#39;,
 27                  &#39;2 - 3 * 4&#39;,  &#39;2 - 3 + 4&#39;,
 28                );
 29    foreach (@test) {
 30      say(&quot;$_:&quot;);
 31      say(is_valid($_) ? &quot;\n&lt;$_&gt; is valid&quot; : &quot;\n&lt;$_&gt; is not valid&quot;)
 32    }</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use warnings&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{ &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;EXPR&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;TERM&amp;gt;              # An expression is a TERM  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;ID&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[a-zA-Z]+)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                          | &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;INT&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[1-9]\d*)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                          | &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;EXPR&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;           # possibly followed by a sequence of &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;OP&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[-+*/])&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;TERM&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;        # &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; operand TERM pairs&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;            }x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$re&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/^ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; is_valid &lt;/span&gt;{ &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$re&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/o&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@test&lt;/span&gt; = ( &lt;span class=&quot;synConstant&quot;&gt;&#39;(a + 3)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;(3 * 4)+(b + x)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;(5 - a)*z&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;((5 - a))*((((z)))+2)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;!3 + 2&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2!&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;3 a&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 3&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 * * 3&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 * 4&#39;&lt;/span&gt;,  &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 + 4&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;               );
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;@test&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt;     say(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;:&amp;quot;&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;     say(is_valid(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;) ? &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; is valid&amp;quot;&lt;/span&gt; : &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; is not valid&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Podemos usar acciones semánticas empotradas para ver la forma en la que trabaja la expresión regular (véase la sección [subsection:codigoenregexp]):</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    use re &#39;eval&#39;; # to allow Eval-group at runtime
  7  
  8    local our ($skip, $term, $expr);
  9    $skip = qr/\s*/;
 10    $expr = qr{ (?&lt;EXPR&gt;
 11                       (?&lt;TERM&gt;              # An expression is a TERM  ...
 12                              $skip (?&lt;ID&gt;[a-zA-Z]+)  (?{ print &quot;[ID $+{ID}] &quot;  })
 13                            | $skip (?&lt;INT&gt;[1-9]\d*)  (?{ print &quot;[INT $+{INT}] &quot; })
 14                            | $skip \(                (?{ print &quot;[(] &quot; })
 15                              $skip  (?&amp;EXPR)
 16                              $skip \)                (?{ print &quot;[)] &quot; })
 17                       ) (?: $skip           # possibly followed by a sequence of ...
 18                             (?&lt;OP&gt;[-+*/])            (?{ print &quot;[OP $+{OP}] &quot; })
 19                             (?&amp;TERM)        # ... operand TERM pairs
 20                         )*
 21                )
 22              }x;
 23    my $re = qr/^ $expr $skip \z/x;
 24    sub is_valid { shift =~ /$re/o }
 25  
 26    my @test = ( &#39;(a + 3)&#39;, &#39;(3 * 4)+(b + x)&#39;, &#39;(5 - a)*z&#39;,
 27                  &#39;((5 - a))*((((z)))+2)&#39;, &#39;3 + 2&#39;, &#39;!3 + 2&#39;, &#39;3 + 2!&#39;,
 28                  &#39;3 a&#39;, &#39;3 3&#39;, &#39;3 * * 3&#39;,
 29                  &#39;2 - 3 * 4&#39;,  &#39;2 - 3 + 4&#39;,
 30                );
 31    foreach (@test) {
 32      say(&quot;$_:&quot;);
 33      say(is_valid($_) ? &quot;\n&lt;$_&gt; is valid&quot; : &quot;\n&lt;$_&gt; is not valid&quot;)
 34    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use warnings&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;re &lt;span class=&quot;synConstant&quot;&gt;&#39;eval&#39;&lt;/span&gt;; &lt;span class=&quot;synComment&quot;&gt;# to allow Eval-group at runtime&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{ &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;EXPR&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                     &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;TERM&amp;gt;              # An expression is a TERM  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;ID&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[a-zA-Z]+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ print &amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[ID $+{ID}]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;quot;  }&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;                           | &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;INT&amp;gt;&lt;/span&gt;[&lt;span class=&quot;synConstant&quot;&gt;1-9&lt;/span&gt;]\d*)  (?{ &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;[INT &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{INT}] &amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;                           | &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; \(                (?{ &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;[(] &amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;                             &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;  (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;EXPR&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;                             &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; \)                (?{ &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;[)] &amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;                      ) (?: &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;           &lt;span class=&quot;synComment&quot;&gt;# possibly followed by a sequence of ...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;                            (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;OP&amp;gt;&lt;/span&gt;[-+*/])            (?{ &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;[OP &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{OP}] &amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;                            (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;TERM&lt;/span&gt;)        &lt;span class=&quot;synComment&quot;&gt;# ... operand TERM pairs&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;                        )*
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;               )
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;             }x;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$re&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/^ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;/x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; is_valid &lt;/span&gt;{ &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$re&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/o&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@test&lt;/span&gt; = ( &lt;span class=&quot;synConstant&quot;&gt;&#39;(a + 3)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;(3 * 4)+(b + x)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;(5 - a)*z&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;((5 - a))*((((z)))+2)&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;!3 + 2&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2!&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;3 a&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 3&#39;&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;3 * * 3&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;                 &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 * 4&#39;&lt;/span&gt;,  &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 + 4&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt;               );
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;@test&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;     say(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;:&amp;quot;&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;     say(is_valid(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;) ? &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; is valid&amp;quot;&lt;/span&gt; : &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; is not valid&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./simpleexpressions.pl
(a + 3):
[(] [ID a] [OP +] [INT 3] [)]
&lt;(a + 3)&gt; is valid
(3 * 4)+(b + x):
[(] [INT 3] [OP *] [INT 4] [)] [OP +] [(] [ID b] [OP +] [ID x] [)]
&lt;(3 * 4)+(b + x)&gt; is valid
(5 - a)*z:
[(] [INT 5] [OP -] [ID a] [)] [OP *] [ID z]
&lt;(5 - a)*z&gt; is valid
((5 - a))*((((z)))+2):
[(] [(] [INT 5] [OP -] [ID a] [)] [)] [OP *] [(] [(] [(] [(] [ID z] [)] [)] [)] [OP +] [INT 2] [)]
&lt;((5 - a))*((((z)))+2)&gt; is valid
3 + 2:
[INT 3] [OP +] [INT 2]
&lt;3 + 2&gt; is valid
!3 + 2:

&lt;!3 + 2&gt; is not valid
3 + 2!:
[INT 3] [OP +] [INT 2]
&lt;3 + 2!&gt; is not valid
3 a:
[INT 3]
&lt;3 a&gt; is not valid
3 3:
[INT 3]
&lt;3 3&gt; is not valid
3 * * 3:
[INT 3] [OP *]
&lt;3 * * 3&gt; is not valid
2 - 3 * 4:
[INT 2] [OP -] [INT 3] [OP *] [INT 4]
&lt;2 - 3 * 4&gt; is valid
2 - 3 + 4:
[INT 2] [OP -] [INT 3] [OP +] [INT 4]
&lt;2 - 3 + 4&gt; is valid</code></pre>
<h3 id="subsection:cuantificadoresposesivos">Cuantificadores Posesivos</h3>
<p>Por defecto, cuando un subpatrón con un cuantificador impide que el patrón global tenga éxito, se produce un backtrack. Hay ocasiones en las que esta conducta da lugar a ineficiencia.</p>
<p>Perl 5.10 provee los cuantificadores posesivos: Un cuantificador posesivo actúa como un cuantificador greedy pero no se produce backtracking.</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>*+</code></th>
<th align="left">Casar 0 o mas veces y no retroceder</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>++</code></td>
<td align="left">Casar 1 o mas veces y no retroceder</td>
</tr>
<tr class="even">
<td align="left"><code>?+</code></td>
<td align="left">Casar 0 o 1 veces y no retroceder</td>
</tr>
<tr class="odd">
<td align="left"><code>{n}+</code></td>
<td align="left">Casar exactamente n veces y no retroceder (redundante)</td>
</tr>
<tr class="even">
<td align="left"><code>{n,}+</code></td>
<td align="left">Casar al menos n veces y no retroceder</td>
</tr>
<tr class="odd">
<td align="left"><code>{n,m}+</code></td>
<td align="left">Casar al menos n veces y no mas de m veces y no retroceder</td>
</tr>
</tbody>
</table>
<p>Por ejemplo, la cadena <code>'aaaa'</code> no casa con <code>/(a++a)/</code> porque no hay retroceso después de leer las 4 aes:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x &#39;aaaa&#39; =~ /(a+a)/
0  &#39;aaaa&#39;
  DB&lt;2&gt; x &#39;aaaa&#39; =~ /(a++a)/
  empty array</code></pre>
<p>Los operadores posesivos sirven para poder escribir expresiones regulares mas eficientes en aquellos casos en los que sabemos que el retroceso no conducirá a nuevas soluciones, como es el caso del reconocimiento de las cadenas delimitadas por comillas dobles:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./quotedstrings.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
     2  use v5.10;
     3
     4  my $regexp = qr/
     5    &quot;             # double quote
     6    (?:           # no memory
     7        [^&quot;\\]++  # no &quot; or escape: Don&#39;t backtrack
     8      | \\.       # escaped character
     9    )*+
    10    &quot;             # end double quote
    11  /x;
    12
    13  my $input = &lt;&gt;;
    14  chomp($input);
    15  if ($input =~ $regexp) {
    16    say &quot;$&amp; is a string&quot;;
    17  }
    18  else {
    19    say &quot;does not match&quot;;
    20  }</code></pre>
<p>Los paréntesis posesivos <code>(?&gt; ...)</code> dan lugar a un reconocedor que rechaza las demandas de retroceso. De hecho, los operadores posesivos pueden ser reescritos en términos de los paréntesis posesivos: La notación <code>X++</code> es equivalente a <code>(?&gt;X+)</code>.</p>
<p>El siguiente ejemplo reconoce el lenguaje de los paréntesis balanceados:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./balancedparenthesis.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3
 4  my $regexp =
 5      qr/^(
 6             [^()]*+ # no hay paréntesis, no backtrack
 7            \(
 8                (?&gt;        # subgrupo posesivo
 9                   [^()]++ # no hay paréntesis, + posesivo, no backtrack
10                  |(?1)    # o es un paréntesis equilibrado
11                )*
12             \)
13             [^()]*+ # no hay paréntesis
14           )$/x;
15
16  my $input = &lt;&gt;;
17  chomp($input);
18  if ($input =~ $regexp) {
19    say &quot;$&amp; is a balanced parenthesis&quot;;
20  }
21  else {
22    say &quot;does not match&quot;;
23  }</code></pre>
<p>Cuando se ejecuta produce una salida como:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5)*2
(2*(3+4)-5)*2 is a balanced parenthesis
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5))*2
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
2*(3+4
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
4*(2*(3+4)-5)*2
4*(2*(3+4)-5)*2 is a balanced parenthesis</code></pre>
<p>El uso de los operadores posesivos nos permite reescribir la solución al problema de encontrar los bloques maximales de un código dada en la sección [parrafo:bloquesanidados] de la siguiente manera:</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat blocksopti.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use v5.10;
  4  use strict;
  5  #use re &#39;debug&#39;;
  6  
  7  my $rb = qr{(?x)
  8      (
  9        \{               # llave abrir
 10           (?:
 11               [^{}]++   # no llaves
 12           |
 13               (?1)      # recursivo
 14               [^{}]*+   # no llaves
 15           )*+
 16         \}              # llave cerrar
 17      )
 18    };
 19  
 20  local $/ = undef;
 21  my $input = &lt;&gt;;
 22  my@blocks = $input =~ m{$rb}g;
 23  my $i = 0;
 24  say($i++.&quot;:\n$_\n===&quot;) for @blocks;</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat blocksopti&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;#!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synComment&quot;&gt;#use re &#39;debug&#39;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$rb&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?x)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;{&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # llave abrir&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^{}]++&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;   # no llaves&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         |&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;      # recursivo&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^{}]*+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;   # no llaves&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)*+&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;&amp;#92;}&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;              # llave cerrar&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  }&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;undef&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@blocks&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$rb&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}g&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$i&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; say(&lt;span class=&quot;synIdentifier&quot;&gt;$i&lt;/span&gt;++.&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;:&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;===&amp;quot;&lt;/span&gt;) &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@blocks&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<ul>
<li><p><span>http://www.regular-expressions.info/possessive.html</span> en <span>http://www.regular-expressions.info/tutorial.html</span></p></li>
<li><p>Nodo <em>Possessive Quantifiers in Perl 5.10 regexps</em> en</p></li>
<li><p>perldoc</p></li>
</ul>
<h3 id="perl-5.10-numeración-de-los-grupos-en-alternativas">Perl 5.10: Numeración de los Grupos en Alternativas</h3>
<p>A veces conviene tener una forma de acceso uniforme a la lista proporcionada por los paréntesis con memoria. Por ejemplo, la siguiente expresión regular reconoce el lenguaje de las horas en notaciones civil y militar:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; &#39;23:12&#39; =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print &quot;1-&gt;$1 2-&gt;$2\n&quot;
1-&gt;23 2-&gt;12

  DB&lt;2&gt; &#39;2312&#39; =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print &quot;3-&gt;$3 4-&gt;$4\n&quot;
3-&gt;23 4-&gt;12</code></pre>
<p>Parece inconveniente tener los resultados en variables distintas. El constructo <code>(?| ...)</code> hace que los paréntesis se enumeren relativos a las alternativas:</p>
<pre><code>  DB&lt;3&gt; &#39;2312&#39; =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print &quot;1-&gt;$1 2-&gt;$2\n&quot;
1-&gt;23 2-&gt;12

  DB&lt;4&gt; &#39;23:12&#39; =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print &quot;1-&gt;$1 2-&gt;$2\n&quot;
1-&gt;23 2-&gt;12</code></pre>
<p>Ahora en ambos casos <code>$1</code> y <code>$2</code> contienen las horas y minutos.</p>
<h3 id="subsection:codigoenregexp">Ejecución de Código dentro de una Expresión Regular</h3>
<p>Es posible introducir código Perl dentro de una expresión regular. Para ello se usa la notación <code>(?{code})</code>.</p>
<p>El siguiente texto esta tomado de :</p>
<blockquote>
<p>Normally, regexps are a part of Perl expressions. Code evaluation expressions turn that around by allowing arbitrary Perl code to be a part of a regexp. A code evaluation expression is denoted (?<span>code</span>), with code a string of Perl statements.</p>
<p>Be warned that this feature is considered experimental, and may be changed without notice.</p>
<p>Code expressions are zero-width assertions, and the value they return depends on their environment.</p>
<p>There are two possibilities: either the code expression is used as a conditional in a conditional expression <code>(?(condition)...)</code>, or it is not.</p>
<ul>
<li><blockquote>
<p>If the code expression is a conditional, the code is evaluated and the result (i.e., the result of the last statement) is used to determine truth or falsehood.</p>
</blockquote></li>
<li><blockquote>
<p>If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable <code>$^R</code> . The variable <code>$^R</code> can then be used in code expressions later in the regexp</p>
</blockquote></li>
</ul>
</blockquote>
<p>Las expresiones de código son : no consumen entrada. El resultado de la ejecución se salva en la variable especial <code>$^R</code>.</p>
<p>Veamos un ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = &quot;abcdef&quot;
  DB&lt;2&gt; $x =~ /abc(?{ &quot;Hi mom\n&quot; })def(?{ print $^R })$/
Hi mom
  DB&lt;3&gt; $x =~ /abc(?{ print &quot;Hi mom\n&quot;; 4 })def(?{ print &quot;$^R\n&quot; })/
Hi mom
4
  DB&lt;4&gt; $x =~ /abc(?{ print &quot;Hi mom\n&quot;; 4 })ddd(?{ print &quot;$^R\n&quot; })/ # does not match
  DB&lt;5&gt;                                 </code></pre>
<p>En el último ejemplo (línea <code>DB&lt;4&gt;</code>) ninguno de los <code>print</code> se ejecuta dado que no hay matching.</p>
<p>Tomado de :</p>
<blockquote>
<p>This zero-width assertion evaluates any embedded Perl code. It always succeeds, and its code is not interpolated. Currently, the rules to determine where the code ends are somewhat convoluted.</p>
</blockquote>
<p>Tomado de :</p>
<blockquote>
<p>… can be used with the special variable <code>$^N</code> to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $x = &quot;The brown fox jumps over the lazy dog&quot;
  DB&lt;2&gt; x $x =~ /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i
0  &#39;brown&#39;
1  &#39;fox&#39;
  DB&lt;3&gt; p &quot;color=$color animal=$animal\n&quot;
color=brown animal=fox
  DB&lt;4&gt; $x =~ /the (\S+)(?{ print (substr($_,0,pos($_))).&quot;\n&quot; }) (\S+)/i
The brown</code></pre>
<p>Inside the <code>(?{...})</code> block, <code>$_</code> refers to the string the regular expression is matching against. You can also use <code>pos()</code> to know what is the current position of matching within this string.</p>
</blockquote>
<p>Si se usa un cuantificador sobre un código empotrado, actúa como un bucle:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; $x = &quot;aaaa&quot;
  DB&lt;2&gt;  $x =~ /(a(?{ $c++ }))*/
  DB&lt;3&gt; p $c
4
  DB&lt;4&gt; $y = &quot;abcd&quot;
  DB&lt;5&gt; $y =~ /(?:(.)(?{ print &quot;-$1-\n&quot; }))*/
-a-
-b-
-c-
-d-</code></pre>
<p>Tomado (y modificado el ejemplo) de :</p>
<blockquote>
<p>…The code is properly scoped in the following sense: If the assertion is backtracked (compare ), all changes introduced after localization are undone, so that</p>
<pre><code>pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  use strict;

  our ($cnt, $res);

  sub echo {
 local our $pre = substr($_,0,pos($_));
 local our $post = (pos($_) &lt; length)? (substr($_,1+pos($_))) : &#39;&#39;;

 print(&quot;$pre(count = $cnt)$post\n&quot;);
  }

  $_ = &#39;a&#39; x 8;
  m&lt;
 (?{ $cnt = 0 }) # Initialize $cnt.
 (
   a
   (?{
     local $cnt = $cnt + 1; # Update $cnt, backtracking-safe.
     echo();
   })
 )*
 aaaa
 (?{ $res = $cnt }) # On success copy to non-localized
 # location.
  &gt;x;

  print &quot;FINAL RESULT: cnt = $cnt res =$res\n&quot;;</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;

  &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$res&lt;/span&gt;);

&lt;span class=&quot;synIdentifier&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; echo &lt;/span&gt;{
    &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$pre&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;synStatement&quot;&gt;pos&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;));
    &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$post&lt;/span&gt; = (&lt;span class=&quot;synStatement&quot;&gt;pos&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;) &amp;lt; &lt;span class=&quot;synStatement&quot;&gt;length&lt;/span&gt;)? (&lt;span class=&quot;synStatement&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;+&lt;span class=&quot;synStatement&quot;&gt;pos&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;))) : &lt;span class=&quot;synConstant&quot;&gt;&#39;&#39;&lt;/span&gt;;

    &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$pre&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;(count = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$post&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;);
  }

  &lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;a&#39;&lt;/span&gt; x &lt;span class=&quot;synConstant&quot;&gt;8&lt;/span&gt;;
  m&amp;lt;
    (?{ &lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; }) &lt;span class=&quot;synComment&quot;&gt;# Initialize $cnt.&lt;/span&gt;
    (
      a
      (?{
        &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt; + &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;synComment&quot;&gt;# Update $cnt, backtracking-safe.&lt;/span&gt;
        echo();
      })
    )*
    aaaa
    (?{ &lt;span class=&quot;synIdentifier&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt; }) &lt;span class=&quot;synComment&quot;&gt;# On success copy to non-localized&lt;/span&gt;
    &lt;span class=&quot;synComment&quot;&gt;# location.&lt;/span&gt;
  &amp;gt;x;

  &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;FINAL RESULT: cnt = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$cnt&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; res =&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$res&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>will set <code>$res = 4</code> . Note that after the match, <code>$cnt</code> returns to the globally introduced value, because the scopes that restrict local operators are unwound.</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.8.8 -w embededcodescope.pl
a(count = 1)aaaaaa
aa(count = 2)aaaaa
aaa(count = 3)aaaa
aaaa(count = 4)aaa
aaaaa(count = 5)aa
aaaaaa(count = 6)a
aaaaaaa(count = 7)
aaaaaaaa(count = 8)
FINAL RESULT: cnt = 0 res =4</code></pre>
</blockquote>
<ul>
<li><blockquote>
<p>Due to an unfortunate implementation issue, the Perl code contained in these blocks is treated as a compile time that can have seemingly bizarre consequences when used with inside of subroutines or loops. There are various workarounds for this, including simply using global variables instead. If you are using this construct and strange results occur then check for the use of lexically scoped variables.</p>
</blockquote></li>
<li><blockquote>
<p>For reasons of security, this construct is forbidden if the regular expression involves run-time interpolation of variables, unless the perilous <code>use re 'eval'</code> pragma has been used (see ), or the variables contain results of <code>qr//</code> operator (see <code>&quot;qr/STRING/imosx&quot;</code> in ).</p>
<p>This restriction is due to the wide-spread and remarkably convenient custom of using run-time determined strings as patterns. For example:</p>
<pre><code>   1. $re = &lt;&gt;;
   2. chomp $re;
   3. $string =~ /$re/;</code></pre>
<p>Before Perl knew how to execute interpolated code within a pattern, this operation was completely safe from a security point of view, although it could raise an exception from an illegal pattern. If you turn on the <code>use re 'eval'</code> , though, it is no longer secure, so you should only do so if you are also using checking. Better yet, use the carefully constrained evaluation within a compartment. See perlsec for details about both these mechanisms. (Véase )</p>
</blockquote></li>
<li><blockquote>
<p>Because Perl’s regex engine is currently <em>not re-entrant</em>, interpolated code may not invoke the regex engine either directly with <code>m//</code> or <code>s///</code>, or indirectly with functions such as .</p>
</blockquote></li>
</ul>
<p>Las acciones empotradas pueden utilizarse como mecanismo de depuración y de descubrimiento del comportamiento de nuestras expresiones regulares.</p>
<p>En el siguiente programa se produce una colisión entre los nombres <code>&lt;i&gt;</code> y <code>&lt;j&gt;</code> de los patrones que ocurren en el patrón <code>&lt;expr&gt;</code> y en el patrón principal:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $&quot; = &quot;, &quot;;
  7  
  8    my $parser = qr{
  9        ^ (?&lt;i&gt; (?&amp;expr)) (?&lt;j&gt; (?&amp;expr)) \z
 10          (?{
 11               say &quot;main \$+ hash:&quot;;
 12               say &quot; ($_ =&gt; $+{$_}) &quot; for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?&lt;expr&gt;
 17                (?&lt;i&gt; . )
 18                (?&lt;j&gt; . )
 19                  (?{
 20                      say &quot;expr \$+ hash:&quot;;
 21                      say &quot; ($_ =&gt; $+{$_}) &quot; for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = &lt;&gt;;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say &quot;matches: ($&amp;)&quot;;
 31    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$&amp;quot;&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;, &amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$parser&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      ^ &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;i&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;expr&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;j&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;expr&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             say &amp;quot;main &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; hash:&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             say &amp;quot; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =&amp;gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;synConstant&quot;&gt;&amp;quot; for sort keys %+;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         })&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      (?(DEFINE)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          (?&amp;lt;expr&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              (?&amp;lt;i&amp;gt; . )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              (?&amp;lt;j&amp;gt; . )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                (?{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                    say &amp;quot;&lt;/span&gt;expr \&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt; hash:&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                    say &amp;quot;&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt; =&amp;gt; &lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;}) &lt;span class=&quot;synConstant&quot;&gt;&amp;quot; for sort keys %+;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                })&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  }x;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = &amp;lt;&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  chomp(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  if (&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$parser&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;) {&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    say &amp;quot;&lt;/span&gt;matches: (&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;)&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  }&lt;/span&gt;
&lt;/pre&gt;</code></pre>
<p>La colisión hace que la salida sea esta:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./clashofnamedofssets.pl
abab
expr $+ hash:
 (i =&gt; a)
 (j =&gt; b)
expr $+ hash:
 (i =&gt; ab)
 (j =&gt; b)
main $+ hash:
 (i =&gt; ab)
 (j =&gt; ab)
matches: (abab)</code></pre>
<p>Si se evitan las colisiones, se evita la pérdida de información:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $&quot; = &quot;, &quot;;
  7  
  8    my $parser = qr{
  9        ^ (?&lt;i&gt; (?&amp;expr)) (?&lt;j&gt; (?&amp;expr)) \z
 10          (?{
 11               say &quot;main \$+ hash:&quot;;
 12               say &quot; ($_ =&gt; $+{$_}) &quot; for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?&lt;expr&gt;
 17                (?&lt;i_e&gt; . )
 18                (?&lt;j_e&gt; . )
 19                  (?{
 20                      say &quot;expr \$+ hash:&quot;;
 21                      say &quot; ($_ =&gt; $+{$_}) &quot; for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = &lt;&gt;;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say &quot;matches: ($&amp;)&quot;;
 31    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$&amp;quot;&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;, &amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$parser&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      ^ &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;i&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;expr&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;j&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;expr&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             say &amp;quot;main &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; hash:&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             say &amp;quot; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =&amp;gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;synConstant&quot;&gt;&amp;quot; for sort keys %+;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;         })&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      (?(DEFINE)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          (?&amp;lt;expr&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              (?&amp;lt;i_e&amp;gt; . )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              (?&amp;lt;j_e&amp;gt; . )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                (?{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                    say &amp;quot;&lt;/span&gt;expr \&lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt; hash:&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                    say &amp;quot;&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt; =&amp;gt; &lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;}) &lt;span class=&quot;synConstant&quot;&gt;&amp;quot; for sort keys %+;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                })&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  }x;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; = &amp;lt;&amp;gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  chomp(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  if (&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$parser&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;) {&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;    say &amp;quot;&lt;/span&gt;matches: (&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;)&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  }&lt;/span&gt;
&lt;/pre&gt;</code></pre>
<p>que al ejecutarse produce:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./namedoffsets.pl
abab
expr $+ hash:
 (i_e =&gt; a)
 (j_e =&gt; b)
expr $+ hash:
 (i =&gt; ab)
 (i_e =&gt; a)
 (j_e =&gt; b)
main $+ hash:
 (i =&gt; ab)
 (j =&gt; ab)
matches: (abab)</code></pre>
<h3 id="subsection:tiempodematching">Expresiones Regulares en tiempo de matching</h3>
<p>Los paréntesis especiales:</p>
<pre><code>                (??{ Código Perl })</code></pre>
<p>hacen que el <code>Código Perl</code> sea evaluado durante el tiempo de matching. El resultado de la evaluación se trata como una expresión regular. El match continuará intentando casar con la expresión regular retornada.</p>
<p>Los paréntesis en la expresión regular retornada no cuentan en el patrón exterior. Véase el siguiente ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ([ab])             # save &#39;a&#39; or &#39;b&#39; in \$1
   7                (??{ &quot;($^N)&quot;x3 })  # 3 more of the same as in \$1
   8              };
   9    say &quot;&lt;$&amp;&gt; lastpar = $#-&quot; if &#39;bbbb&#39; =~ $r;
  10    say &quot;&lt;$&amp;&gt; lastpar = $#-&quot; if &#39;aaaa&#39; =~ $r;
  11    say &quot;&lt;abab&gt; didn&#39;t match&quot; unless &#39;abab&#39; =~ $r;
  12    say &quot;&lt;aaab&gt; didn&#39;t match&quot; unless &#39;aaab&#39; =~ $r;</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?x)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                # ignore spaces&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([ab])&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;             # save &#39;a&#39; or &#39;b&#39; in &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(??&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ &amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;x3 }&lt;/span&gt;)  &lt;span class=&quot;synComment&quot;&gt;# 3 more of the same as in \$1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;             };
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; lastpar = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$#&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;-&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;bbbb&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; lastpar = &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$#&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;-&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;aaaa&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;abab&amp;gt; didn&#39;t match&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;abab&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;aaab&amp;gt; didn&#39;t match&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;aaab&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Como se ve, hemos accedido desde el código interior al último paréntesis usando <code>$^N</code>. Sigue una ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./postponedregexp.pl
&lt;bbbb&gt; lastpar = 1
&lt;aaaa&gt; lastpar = 1
&lt;abab&gt; didn&#39;t match
&lt;aaab&gt; didn&#39;t match</code></pre>
<p>Consideremos el problema de escribir una expresión regular que reconoce secuencias no vacías de dígitos tales que la longitud de la secuencia restante viene determinada por el primer dígito. Esta es una solución:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n intints.pl
   1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2  use v5.10;
   3  use strict;
   4  
   5  my $r = qr{(?x)                # ignore spaces
   6             (\d)                # a digit
   7             ( (??{
   8                 &quot;\\d{$^N}&quot;      # as many as the former
   9               })                # digit says
  10             )
  11            };
  12  say &quot;&lt;$&amp;&gt; &lt;$1&gt; &lt;$2&gt;&quot; if &#39;3428&#39; =~ $r;
  13  say &quot;&lt;$&amp;&gt; &lt;$1&gt; &lt;$2&gt;&quot; if &#39;228&#39; =~ $r;
  14  say &quot;&lt;$&amp;&gt; &lt;$1&gt; &lt;$2&gt;&quot; if &#39;14&#39; =~ $r;
  15  say &quot;24 does not match&quot; unless &#39;24&#39; =~ $r;
  16  say &quot;4324 does not match&quot; unless &#39;4324&#39; =~ $r;</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n intints.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?x)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                # ignore spaces&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\d)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                # a digit&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(??&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;               &amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;d{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N}&amp;quot;      # as many as the former&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;             })                # digit says&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;           )&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          };&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;say &amp;quot;&lt;/span&gt;&amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;&amp;gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; if &#39;3428&#39; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;say &amp;quot;&lt;/span&gt;&amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;&amp;gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; if &#39;228&#39; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;say &amp;quot;&lt;/span&gt;&amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&amp;gt; &amp;lt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;&amp;gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; if &#39;14&#39; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;say &amp;quot;24&lt;/span&gt; does &lt;span class=&quot;synStatement&quot;&gt;not&lt;/span&gt; match&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; unless &#39;24&#39; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;say &amp;quot;4324&lt;/span&gt; does &lt;span class=&quot;synStatement&quot;&gt;not&lt;/span&gt; match&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; unless &#39;4324&#39; =~ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;</code></pre>
<p>Cuando se ejecuta se obtiene:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./intints.pl
&lt;3428&gt; &lt;3&gt; &lt;428&gt;
&lt;228&gt; &lt;2&gt; &lt;28&gt;
&lt;14&gt; &lt;1&gt; &lt;4&gt;
24 does not match
4324 does not match</code></pre>
<p>Otro ejemplo: queremos escribir una expresión regular que reconozca secuencias de <code>$n</code> dígitos en las que no todos los dígitos se repiten. Donde quizá <code>$n</code> es capturado de un paréntesis anterior en la expresión regular. Para simplificar la ilustración de la técnica supongamos que <code>$n = 7</code>:</p>
<pre><code>pl@nereida:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; x join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9
0  &#39;(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})&#39;
  DB&lt;2&gt; x &#39;7777777&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/
  empty array
  DB&lt;3&gt; x &#39;7777778&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/
0  7777778
  DB&lt;4&gt; x &#39;4444444&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/
  empty array
  DB&lt;5&gt; x &#39;4422444&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/
0  4422444</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~$  &lt;span class=&quot;dbuser&quot;&gt;perl5.10.1 -wdE 0&lt;/span&gt;
main::(-e:1):   0
  DB&amp;lt;1&amp;gt;  &lt;span class=&quot;dbuser&quot;&gt;x join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9&lt;/span&gt;
0  &#39;(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})&#39;
  DB&amp;lt;2&amp;gt;  &lt;span class=&quot;dbuser&quot;&gt;x &#39;7777777&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/&lt;/span&gt;
  empty array
  DB&amp;lt;3&amp;gt;  &lt;span class=&quot;dbuser&quot;&gt;x &#39;7777778&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/&lt;/span&gt;
0  7777778
  DB&amp;lt;4&amp;gt;  &lt;span class=&quot;dbuser&quot;&gt;x &#39;4444444&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/&lt;/span&gt;
  empty array
  DB&amp;lt;5&amp;gt;  &lt;span class=&quot;dbuser&quot;&gt;x &#39;4422444&#39; =~ /(??{join &#39;&#39;, map { &quot;(?!&quot;.$_.&quot;{7})&quot; } 0..9})(\d{7})/&lt;/span&gt;
0  4422444
&lt;/pre&gt;</code></pre>
<p>[parrafo:palindromospostregexp]</p>
<p>Se trata en este ejercicio de generalizar la expresión regular introducida en la sección [parrafo:palabrapalindromos] para reconocer los palabra-palíndromos.</p>
<p>Se trata de encontrar una regexp que acepte que la lectura derecha e inversa de una frase en Español pueda diferir en la acentuación (como es el caso del clásico palíndromo <span><em>dábale arroz a la zorra el abad</em></span>). Una solución trivial es preprocesar la cadena eliminando los acentos. Supondremos sin embargo que se quiere trabajar sobre la cadena original. He aquí una solucion:</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat actionspanishpalin.pl 
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  use re &#39;eval&#39;;
  7  use Switch;
  8  
  9  sub f {
 10    my $char = shift;
 11  
 12    switch($char) {
 13      case [ qw{a á} ] { return &#39;[aá]&#39; }
 14      case [ qw{e é} ] { return &#39;[eé]&#39; }
 15      case [ qw{i í} ] { return &#39;[ií]&#39; }
 16      case [ qw{o ó} ] { return &#39;[oó]&#39; }
 17      case [ qw{u ú} ] { return &#39;[uú]&#39; }
 18      else             { return $char  };
 19    }
 20  }
 21  
 22  my $regexp = qr/^(\W* (?: 
 23                              (\w) (?-2)(??{ f($^N) })
 24                            | \w? 
 25                        ) \W*
 26                    )
 27                  $
 28                 /ix;
 29  
 30  my $input = &lt;&gt;; # Try: &#39;dábale arroz a la zorra el abad&#39;;
 31  chomp($input);
 32  if ($input =~ $regexp) {
 33    say &quot;$input is a palindrome&quot;;
 34  }
 35  else {
 36    say &quot;$input does not match&quot;;
 37  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat actionspanishpalin&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;#!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt; -CIOEioA
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use utf8&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;re &lt;span class=&quot;synConstant&quot;&gt;&#39;eval&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;Switch;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; f &lt;/span&gt;{
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$char&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;switch&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$char&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;     case [ &lt;span class=&quot;synConstant&quot;&gt;qw{a á}&lt;/span&gt; ] { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;[aá]&#39;&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;     case [ &lt;span class=&quot;synConstant&quot;&gt;qw{e é}&lt;/span&gt; ] { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;[eé]&#39;&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;     case [ &lt;span class=&quot;synConstant&quot;&gt;qw{i í}&lt;/span&gt; ] { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;[ií]&#39;&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;     case [ &lt;span class=&quot;synConstant&quot;&gt;qw{o ó}&lt;/span&gt; ] { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;[oó]&#39;&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;     case [ &lt;span class=&quot;synConstant&quot;&gt;qw{u ú}&lt;/span&gt; ] { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;[uú]&#39;&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt;             { &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$char&lt;/span&gt;  };
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\W*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\w)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;-2&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)(??&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ f&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; }&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                          | &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\w?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\W*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                $&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;               /ix&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;; &lt;span class=&quot;synComment&quot;&gt;# Try: &#39;dábale arroz a la zorra el abad&#39;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is a palindrome&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt; }
&lt;/pre&gt;</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
éoíúaáuioé
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dáed
dáed does not match</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./actionspanishpalin.pl &lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;dábale arroz a la zorra el abad&lt;/span&gt;
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$&lt;span class=&quot;dbuser&quot;&gt; ./actionspanishpalin.pl &lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;éoíúaáuioé&lt;/span&gt;
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./actionspanishpalin.pl &lt;/span&gt;
&lt;span class=&quot;dbuser&quot;&gt;dáed&lt;/span&gt;
dáed does not match
&lt;/pre&gt;</code></pre>
<p>Véase el nodo para la formulación del problema:</p>
<blockquote>
<p>Hiya monks,</p>
<p>Im having trouble getting my head around a regular expression to match sequences. I need to catch all exceptions where a mathematical expression is illegal...</p>
<p>There must be either a letter or a digit either side of an operator parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist variables must not be more than one letter Nothing other than <code>a-z,A-Z,0-9,+,-,*,/,(,)</code> can be used</p>
<p>Can anyone offer a hand on how best to tackle this problem?</p>
<p>many thanks</p>
</blockquote>
<p>La respuesta dada por usa <code>(?{{ ... })</code> para conseguir una conducta recursiva en versiones de perl anteriores a la 5.10:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n complexformula.pl
  1    #!/usr/bin/perl
  2    use strict;
  3    use warnings;
  4  
  5    sub is_valid_expr {
  6       use re &#39;eval&#39;; # to allow Eval-group at runtime
  7  
  8       local our ($skip, $term, $expr);
  9       $skip = qr! \s* !x;
 10       $term = qr! $skip [a-zA-Z]+              # A term is an identifier
 11                 | $skip [1-9][0-9]*            # or a number
 12                 | $skip \( (??{ $expr }) $skip # or an expression
 13                         \)
 14                 !x;
 15       $expr = qr! $term                         # A expr is a term
 16                   (?: $skip [-+*/] $term )*     # or a term + a term ...
 17                 !x;
 18  
 19       return $_[0] =~ / ^ $expr $skip \z /x;
 20    }
 21  
 22    print(is_valid_expr($_) ? &quot;$_ is valid\n&quot; : &quot;$_ is not valid\n&quot;) foreach (
 23     &#39;(a + 3)&#39;,
 24     &#39;(3 * 4)+(b + x)&#39;,
 25     &#39;(5 - a)*z&#39;,
 26     &#39;3 + 2&#39;,
 27  
 28     &#39;!3 + 2&#39;,
 29     &#39;3 + 2!&#39;,
 30  
 31     &#39;3 a&#39;,
 32     &#39;3 3&#39;,
 33     &#39;3 * * 3&#39;,
 34  
 35     &#39;2 - 3 * 4&#39;,
 36     &#39;2 - 3 + 4&#39;,
 37    );</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use warnings&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; is_valid_expr &lt;/span&gt;{
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;      &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;re &lt;span class=&quot;synConstant&quot;&gt;&#39;eval&#39;&lt;/span&gt;; &lt;span class=&quot;synComment&quot;&gt;# to allow Eval-group at runtime&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;      &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;      &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; = qr! \s* !x;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;      &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt; = qr! &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; [a-zA-Z]+              &lt;span class=&quot;synComment&quot;&gt;# A term is an identifier&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;                | &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; [&lt;span class=&quot;synConstant&quot;&gt;1-9&lt;/span&gt;][&lt;span class=&quot;synConstant&quot;&gt;0-9&lt;/span&gt;]*            &lt;span class=&quot;synComment&quot;&gt;# or a number&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;                | &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; \( (??{ &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt; }) &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; &lt;span class=&quot;synComment&quot;&gt;# or an expression&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;                        \)
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;                !x;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;      &lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt; = qr! &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt;                         &lt;span class=&quot;synComment&quot;&gt;# A expr is a term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;                  (?: &lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt; [-+*/] &lt;span class=&quot;synIdentifier&quot;&gt;$term&lt;/span&gt; )*     &lt;span class=&quot;synComment&quot;&gt;# or a term + a term ...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;                !x;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;      &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;] =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; ^ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$expr&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$skip&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt;(is_valid_expr(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;) ? &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is valid&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt; : &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is not valid&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;) &lt;span class=&quot;synStatement&quot;&gt;foreach&lt;/span&gt; (
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;(a + 3)&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;(3 * 4)+(b + x)&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;(5 - a)*z&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;!3 + 2&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;3 + 2!&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;3 a&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;3 3&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;3 * * 3&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 * 4&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt;    &lt;span class=&quot;synConstant&quot;&gt;&#39;2 - 3 + 4&#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt;   );
&lt;/pre&gt;</code></pre>
<p>Sigue el resultado de la ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid</code></pre>
<p>Estos son algunos puntos a tener en cuenta cuando se usan patrones postpuestos. Véase la entrada <code>(??{ code })</code> en :</p>
<blockquote>
<p>WARNING: This extended regular expression feature is considered experimental, and may be changed without notice. Code executed that has side effects may not perform identically from version to version due to the effect of future optimisations in the regex engine.</p>
<p>This is a . The code is evaluated at run time, at the moment this subexpression may match. The result of evaluation is considered as a regular expression and matched as if it were inserted instead of this construct.</p>
<p>The code <span><em>is not interpolated</em></span>.</p>
<p>As before, the rules to determine where the code ends are currently somewhat convoluted.</p>
<p>Because perl’s regex engine is not currently , delayed code may not invoke the regex engine either directly with <code>m//</code> or <code>s///</code>), or indirectly with functions such as .</p>
<p><span><em>Recursing</em></span> deeper than 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</p>
</blockquote>
<h3 id="subsection:regexpcondicionales">Expresiones Condicionales</h3>
<p>Citando a :</p>
<blockquote>
<p>A conditional expression is a form of if-then-else statement that allows one to choose which patterns are to be matched, based on some condition.</p>
<p>There are two types of conditional expression: <code>(?(condition)yes-regexp)</code> and <code>(?(condition)yes-regexp|no-regexp)</code>.</p>
<p><code>(?(condition)yes-regexp)</code> is like an <code>if () {}</code> statement in Perl. If the condition is true, the yes-regexp will be matched. If the condition is false, the yes-regexp will be skipped and Perl will move onto the next regexp element.</p>
<p>The second form is like an <code>if () {} else {}</code> statement in Perl. If the condition is true, the yes-regexp will be matched, otherwise the no-regexp will be matched.</p>
<p>The condition can have several forms.</p>
<ul>
<li><p>The first form is simply an integer in parentheses (integer). It is true if the corresponding backreference <code>\integer</code> matched earlier in the regexp. The same thing can be done with a name associated with a capture buffer, written as <code>(&lt;name&gt;)</code> or <code>('name')</code>.</p></li>
<li><p>The second form is a bare zero width assertion <code>(?...)</code>, either a lookahead, a lookbehind, or a code assertion.</p></li>
<li><p>The third set of forms provides tests that return true if the expression is executed within a recursion <code>(R)</code> or is being called from some capturing group, referenced either by number <code>(R1</code>, or by name <code>(R&amp;name)</code>.</p></li>
</ul>
</blockquote>
<p>Una expresión condicional puede adoptar diversas formas. La mas simple es un entero en paréntesis. Es cierta si la correspondiente referencia <code>\integer</code> casó (también se puede usar un nombre si se trata de un paréntesis con nombre).</p>
<p>En la expresión regular <code>/^(.)(..)?(?(2)a|b)/</code> si el segundo paréntesis casa, la cadena debe ir seguida de una <code>a</code>, si no casa deberá ir seguida de una <code>b</code>:</p>
<pre><code>  DB&lt;1&gt; x &#39;hola&#39; =~ /^(.)(..)?(?(2)a|b)/
0  &#39;h&#39;
1  &#39;ol&#39;
  DB&lt;2&gt; x &#39;ha&#39; =~ /^(.)(..)?(?(2)a|b)/
  empty array
  DB&lt;3&gt; x &#39;hb&#39; =~ /^(.)(..)?(?(2)a|b)/
0  &#39;h&#39;
1  undef</code></pre>
<p>La siguiente búsqueda casa con patrones de la forma <code>$x$x</code> o <code>$x$y$y$x</code>:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB&lt;1&gt; x &#39;aa&#39; =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  &#39;a&#39;
1  undef
  DB&lt;2&gt; x &#39;abba&#39; =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  &#39;a&#39;
1  &#39;b&#39;
  DB&lt;3&gt; x &#39;abbc&#39; =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
  empty array
  DB&lt;4&gt; x &#39;juanpedropedrojuan&#39; =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  &#39;juan&#39;
1  &#39;pedro&#39;</code></pre>
<p>Una expresión condicional también puede ser un código:</p>
<pre><code>  DB&lt;1&gt; $a = 0; print &quot;$&amp;&quot; if &#39;hola&#39; =~ m{(?(?{$a})hola|adios)} # No hay matching

  DB&lt;2&gt; $a = 1; print &quot;$&amp;&quot; if &#39;hola&#39; =~ m{(?(?{$a})hola|adios)}
hola</code></pre>
<p>La siguiente expresión regular utiliza un condicional para forzar a que si una cadena comienza por un paréntesis abrir termina con un paréntesis cerrar. Si la cadena no comienza por paréntesis abrir no debe existir un paréntesis final de cierre:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ^
   7                ( \( )?            # may be it comes an open par
   8                [^()]+             # no parenthesis
   9                (?(1)              # did we sart with par?
  10                  \)               # if yes then close par
  11                )
  12                $
  13              };
  14    say &quot;&lt;$&amp;&gt;&quot; if &#39;(abcd)&#39; =~ $r;
  15    say &quot;&lt;$&amp;&gt;&quot; if &#39;abc&#39; =~ $r;
  16    say &quot;&lt;(abc&gt; does not match&quot; unless &#39;(abc&#39; =~ $r;
  17    say &quot;&lt;abc)&gt; does not match&quot; unless &#39;abc)&#39; =~ $r;</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?x)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                # ignore spaces&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              ^&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;            # may be it comes an open par&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^()]+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;             # no parenthesis&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;              # did we sart with par&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;               # if yes then close par&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;              $&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;            }&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;(abcd)&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;abc&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;(abc&amp;gt; does not match&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;(abc&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;lt;abc)&amp;gt; does not match&amp;quot;&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&#39;abc)&#39;&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$r&lt;/span&gt;;
&lt;/pre&gt;</code></pre>
<p>Al ejecutar este programa se obtiene:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./conditionalregexp.pl
&lt;(abcd)&gt;
&lt;abc&gt;
&lt;(abc&gt; does not match
&lt;abc)&gt; does not match</code></pre>
<p>El siguiente ejemplo muestra el uso de la condición <code>(R)</code>, la cual comprueba si la expresión ha sido evaluada dentro de una recursión:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; x &#39;bbaaaabb&#39; =~ /(b(?(R)a+|(?0))b)/
0  &#39;bbaaaabb&#39;
  DB&lt;2&gt; x &#39;bb&#39; =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB&lt;3&gt; x &#39;bab&#39; =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB&lt;4&gt; x &#39;bbabb&#39; =~ /(b(?(R)a+|(?0))b)/
0  &#39;bbabb&#39;</code></pre>
<p>La sub-expresión regular <code>(?(R)a+|(?0))</code> dice: si esta siendo evaluada recursivamente admite <code>a+</code> si no, evalúa la regexp completa recursivamente.</p>
<p>Se trata en este ejercicio de generalizar la expresión regular introducida en la sección [parrafo:palabrapalindromos] para reconocer los palabra-palíndromos<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>. Se trata de encontrar una regexp que acepte que la lectura derecha e inversa de una frase en Español pueda diferir en la acentuación (como es el caso del clásico palíndromo <span><em>dábale arroz a la zorra el abad</em></span>). Una solución trivial es preprocesar la cadena eliminando los acentos. Supondremos sin embargo que se quiere trabajar sobre la cadena original. He aquí una solucion parcial (por consideraciones de legibilidad sólo se consideran las vocales <code>a</code> y <code>o</code>:</p>
<pre><code>  1  pl@nereida:~/Lperltesting$ cat spanishpalin.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  
  7  my $regexp = qr/^(?&lt;pal&gt;\W* (?: 
  8                              (?&lt;L&gt;(?&lt;a&gt;[áa])|(?&lt;e&gt;[ée])|\w) # letter
  9                              (?&amp;pal)                        # nested palindrome
 10                              (?(&lt;a&gt;)[áa]                    # if is an &quot;a&quot; group
 11                                    |(?:((?&lt;e&gt;)[ée]          # if is an &quot;e&quot; group
 12                                              |\g{L}         # exact match
 13                                        )                    # end if [ée]
 14                                     )                       # end group
 15                              )                              # end if [áa]
 16                            | \w?                            # non rec. case
 17                        ) \W*                                # punctuation symbols
 18                    )
 19                  $
 20                 /ix;
 21  
 22  my $input = &lt;&gt;; # Try: &#39;dábale arroz a la zorra el abad&#39;;
 23  chomp($input);
 24  if ($input =~ $regexp) {
 25    say &quot;$input is a palindrome&quot;;
 26  }
 27  else {
 28    say &quot;$input does not match&quot;;
 29  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; pl&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperltesting$ cat spanishpalin&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;pl&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;#!&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;usr/&lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt;/lib/perl/&lt;span class=&quot;synConstant&quot;&gt;5.10&lt;/span&gt;.&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;/bin//perl5.&lt;span class=&quot;synConstant&quot;&gt;10.1&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;-w&lt;/span&gt; -CIOEioA
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use utf8&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr/^&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;pal&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\W*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;L&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;a&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[áa])&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;e&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[ée])&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\w)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; # letter&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;pal&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                        # nested palindrome&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;a&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)[áa]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                    # if is an &amp;quot;a&amp;quot; group&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                  |&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?:((?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;e&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)[ée]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;          # if is an &amp;quot;e&amp;quot; group&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                            |&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\g&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{L}         # exact match&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                    # end if &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[ée]&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                                   &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                       # end group&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                            &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                              # end if &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[áa]&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                          | &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\w?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                            # non rec&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; case&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\W*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                                # punctuation symbols&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                  &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                $&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;               /ix&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;; &lt;span class=&quot;synComment&quot;&gt;# Try: &#39;dábale arroz a la zorra el abad&#39;;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; is a palindrome&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; }
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; }
&lt;/pre&gt;</code></pre>
<p>Ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./spanishpalin.pl
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
óuuo
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
éaáe
éaáe is a palindrome</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
&lt;span class=&quot;dbuser&quot;&gt;dábale arroz a la zorra el abad&lt;/span&gt;
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
&lt;span class=&quot;dbuser&quot;&gt;óuuo&lt;/span&gt;
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
&lt;span class=&quot;dbuser&quot;&gt;éaáe&lt;/span&gt;
éaáe is a palindrome
&lt;/pre&gt;</code></pre>
<p>Hemos usado la opción <code>-CIOEioA</code> para asegurarnos que los ficheros de entrada/saldia y error y la línea de comandos estan en modo UTF-8. (Véase la sección [section:unicode])</p>
<p>Esto es lo que dice la documentación de al respecto:</p>
<blockquote>
<p>The <code>-C</code> flag controls some of the Perl Unicode features.</p>
<p>As of 5.8.1, the <code>-C</code> can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</p>
<pre><code>  1   I 1 STDIN is assumed to be in UTF-8
  2   O 2 STDOUT will be in UTF-8
  3   E 4 STDERR will be in UTF-8
  4   S 7 I + O + E
  5   i 8 UTF-8 is the default PerlIO layer for input streams
  6   o 16 UTF-8 is the default PerlIO layer for output streams
  7   D 24 i + o
  8   A 32 the @ARGV elements are expected to be strings encoded
  9   in UTF-8
 10   L 64 normally the &quot;IOEioA&quot; are unconditional,
 11   the L makes them conditional on the locale environment
 12   variables (the LC_ALL, LC_TYPE, and LANG, in the order
 13   of decreasing precedence) -- if the variables indicate
 14   UTF-8, then the selected &quot;IOEioA&quot; are in effect
 15   a 256 Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
 16   debugging mode.
 </code></pre>
<p>For example, <code>-COE</code> and <code>-C6</code> will both turn on UTF-8-ness on both <code>STDOUT</code> and <code>STDERR</code>. Repeating letters is just redundant, not cumulative nor toggling.</p>
<p>The io options mean that any subsequent <code>open()</code> (or similar I/O operations) will have the <code>:utf8</code> PerlIO layer implicitly applied to them, in other words, <code>UTF-8</code> is expected from any input stream, and <code>UTF-8</code> is produced to any output stream. This is just the default, with explicit layers in <code>open()</code> and with <code>binmode()</code> one can manipulate streams as usual.</p>
<p><code>-C</code> on its own (not followed by any number or option list), or the empty string <code>&quot;&quot;</code> for the <code>PERL_UNICODE</code> environment variable, has the same effect as <code>-CSDL</code> . In other words, the standard I/O handles and the default<code>open()</code> layer are UTF-8-fied but only if the locale environment variables indicate a UTF-8 locale. This behaviour follows the implicit (and problematic) UTF-8 behaviour of Perl 5.8.0.</p>
<p>You can use <code>-C0</code> (or <code>0</code> for <code>PERL_UNICODE</code> ) to explicitly disable all the above Unicode features.</p>
</blockquote>
<p>El pragma <code>use utf8</code> hace que se utilice una semántica de carácteres (por ejemplo, la regexp <code>/./</code> casará con un carácter unicode), el pragma <code>use bytes</code> cambia de semántica de caracteres a semántica de bytes (la regexp <code>.</code> casará con un byte).</p>
<pre><code>
&lt;pre&gt;
lhp&lt;span class=&quot;synIdentifier&quot;&gt;@nereida&lt;/span&gt;:~&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Lperl&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/s&lt;/span&gt;rc/testing$ cat -n dot_utf8_2.pl
     &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/bin/perl -w&lt;/span&gt;
     &lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
     &lt;span class=&quot;synConstant&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;use utf8&lt;/span&gt;;
     &lt;span class=&quot;synConstant&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;charnames &lt;span class=&quot;synConstant&quot;&gt;qw{greek}&lt;/span&gt;;
     &lt;span class=&quot;synConstant&quot;&gt;5&lt;/span&gt;
     &lt;span class=&quot;synConstant&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;binmode&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;STDOUT&lt;/span&gt;, &lt;span class=&quot;synConstant&quot;&gt;&#39;:utf8&#39;&lt;/span&gt;);
     &lt;span class=&quot;synConstant&quot;&gt;7&lt;/span&gt;
     &lt;span class=&quot;synConstant&quot;&gt;8&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$x&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;αβγδεφ&#39;&lt;/span&gt;;
     &lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;
    &lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@w&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$x&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/g&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@w&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;synConstant&quot;&gt;13&lt;/span&gt;  {
    &lt;span class=&quot;synConstant&quot;&gt;14&lt;/span&gt;    &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;bytes;
    &lt;span class=&quot;synConstant&quot;&gt;15&lt;/span&gt;    &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@v&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;map&lt;/span&gt; { &lt;span class=&quot;synStatement&quot;&gt;ord&lt;/span&gt; } &lt;span class=&quot;synIdentifier&quot;&gt;$x&lt;/span&gt; =~&lt;span class=&quot;synStatement&quot;&gt; /&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(.)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/g&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;16&lt;/span&gt;    &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@v&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
    &lt;span class=&quot;synConstant&quot;&gt;17&lt;/span&gt;  }
&lt;/pre&gt;

Al ejcutar el programa obtenemos la salida:
&lt;pre&gt;
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;perl dot_utf8_2.pl&lt;/span&gt;
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134

&lt;/pre&gt;</code></pre>
<h3 id="verbos-que-controlan-el-retroceso">Verbos que controlan el retroceso</h3>
<p>Tomado de :</p>
<blockquote>
<p>The control verb <code>(*FAIL)</code> may be abbreviated as <code>(*F)</code>. If this is inserted in a regexp it will cause to fail, just like at some mismatch between the pattern and the string. Processing of the regexp continues like after any “normal” failure, so that the next position in the string or another alternative will be tried. As failing to match doesn’t preserve capture buffers or produce results, it may be necessary to use this in combination with embedded code.</p>
</blockquote>
<pre><code>pl@nereida:~/Lperltesting$ cat -n vowelcount.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
     2  use strict;
     3
     4  my $input = shift() || &lt;STDIN&gt;;
     5  my %count = ();
     6  $input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
     7  printf(&quot;&#39;%s&#39; =&gt; %3d\n&quot;, $_, $count{$_})  for (sort keys %count);</code></pre>
<p>Al ejecutarse con entrada <code>supercalifragilistico</code> produce la salida:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./vowelcount.pl
supercalifragilistico
&#39;a&#39; =&gt;   2
&#39;e&#39; =&gt;   1
&#39;i&#39; =&gt;   4
&#39;o&#39; =&gt;   1
&#39;u&#39; =&gt;   1</code></pre>
<p>¿Que queda en <code>$1</code> depués de ejecutado el matching <code>$input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;</code>?</p>
<p>Véase también:</p>
<ul>
<li><p>El nodo en <em>The Oldest Plays the Piano</em></p></li>
<li><p>Véase el ejercicio <span><em>Las tres hijas</em></span> en la sección [parrfo:lastreshijas]</p></li>
</ul>
<p>Tomado de :</p>
<blockquote>
<p>This pattern matches nothing and causes the end of successful matching at the point at which the <code>(*ACCEPT)</code> pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via <code>(??{})</code>, only the innermost pattern is ended immediately.</p>
<p>If the <code>(*ACCEPT)</code> is inside of capturing buffers then the buffers are marked as ended at the point at which the <code>(*ACCEPT)</code> was encountered. For instance:</p>
<pre><code>  DB&lt;1&gt; x &#39;AB&#39; =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  &#39;AB&#39;
1  &#39;B&#39;
2  undef
  DB&lt;2&gt; x &#39;ACDE&#39;  =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  &#39;ACD&#39;
1  &#39;C&#39;
2  &#39;E&#39;</code></pre>
</blockquote>
<blockquote>
<p>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern <code>A (*SKIP) B</code>, where <code>A</code> and <code>B</code> are complex patterns. Until the <code>(*SKIP)</code> verb is reached, <code>A</code> may backtrack as necessary to match. Once it is reached, matching continues in <code>B</code>, which may also backtrack as necessary; however, should <code>B</code> not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.</p>
<p>It also signifies that whatever text that was matched leading up to the <code>(*SKIP)</code> pattern being executed cannot be part of any match of this pattern. This effectively means that the regex engine <code>skips</code> forward to this position on failure and tries to match again, (assuming that there is sufficient room to match).</p>
<p>The name of the <code>(*SKIP:NAME)</code> pattern has special significance. If a <code>(*MARK:NAME)</code> was encountered while matching, then it is that position which is used as the “skip point”. If no <code>(*MARK)</code> of that name was encountered, then the <code>(*SKIP)</code> operator has no effect. When used without a name the “skip point” is where the match point was when executing the <code>(*SKIP)</code> pattern.</p>
</blockquote>
<p>Ejemplo:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n SKIP.pl
     1  #!/soft/perl5lib/bin/perl5.10.1 -w
     2  use strict;
     3  use v5.10;
     4
     5  say &quot;NO SKIP: /a+b?(*FAIL)/&quot;;
     6  our $count = 0;
     7  &#39;aaab&#39; =~ /a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
     8  say &quot;Count=$count\n&quot;;
     9
    10  say &quot;WITH SKIP: a+b?(*SKIP)(*FAIL)/&quot;;
    11  $count = 0;
    12  &#39;aaab&#39; =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    13  say &quot;WITH SKIP: Count=$count\n&quot;;
    14
    15  say &quot;WITH SKIP /a+(*SKIP)b?(*FAIL)/:&quot;;
    16  $count = 0;
    17  &#39;aaab&#39; =~ /a+(*SKIP)b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    18  say &quot;Count=$count\n&quot;;
    19
    20  say &quot;WITH SKIP /(*SKIP)a+b?(*FAIL): &quot;;
    21  $count = 0;
    22  &#39;aaab&#39; =~ /(*SKIP)a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    23  say &quot;Count=$count\n&quot;;</code></pre>
<p>Ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 SKIP.pl
NO SKIP: /a+b?(*FAIL)/
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9

WITH SKIP: a+b?(*SKIP)(*FAIL)/
aaab
WITH SKIP: Count=1

WITH SKIP /a+(*SKIP)b?(*FAIL)/:
aaab
aaa
Count=2

WITH SKIP /(*SKIP)a+b?(*FAIL):
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9</code></pre>
<p>Tomado de :</p>
<blockquote>
<p><code>(*MARK:NAME) (*:NAME)</code></p>
<p>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later <code>(*SKIP)</code> pattern will then skip forward to that point if backtracked into on failure. Any number of <code>(*MARK)</code> patterns are allowed, and the <code>NAME</code> portion is optional and may be duplicated.</p>
<p>In addition to interacting with the <code>(*SKIP)</code> pattern, <code>(*MARK:NAME)</code> can be used to <code>label</code> a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</p>
<p>When a match is successful, the <code>$REGMARK</code> variable will be set to the name of the most recently executed <code>(*MARK:NAME)</code> that was involved in the match.</p>
<p>This can be used to determine which branch of a pattern was matched without using a separate capture buffer for each branch, which in turn can result in a performance improvement.</p>
<p>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the <code>$REGERROR</code> variable will be set to the name of the most recently executed <code>(*MARK:NAME)</code>.</p>
</blockquote>
<pre><code>pl@nereida:~/Lperltesting$ cat -n mark.pl
 1  use v5.10;
 2  use strict;
 3
 4  our $REGMARK;
 5
 6  $_ = shift;
 7  say $REGMARK if /(?:x(*MARK:mx)|y(*MARK:my)|z(*MARK:mz))/;
 8  say $REGMARK if /(?:x(*:xx)|y(*:yy)|z(*:zz))/;</code></pre>
<p>Cuando se ejecuta produce:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl y
my
yy
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl z
mz
zz</code></pre>
<p>Se quiere poner un espacio en blanco después de la aparición de cada coma:</p>
<pre><code>s/,/, /g;</code></pre>
<p>pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre dos dígitos. Además se pide que si hay ya un espacio después de la coma, no se duplique. Sigue una solución que usa marcas:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB&lt;1&gt; $a = &#39;ab,cd, ef,12,34,efg,56,78,df, ef,&#39;
  DB&lt;2&gt; x ($b = $a) =~ s/\d,\d(*:d)|,(?!\s)/($REGMARK eq &#39;d&#39;)? $&amp; : &#39;, &#39;/ge
0  8
  DB&lt;3&gt; p &quot;&lt;$b&gt;&quot;
&lt;ab, cd, ef, 12,34, efg, 56,78, df, ef, &gt;</code></pre>
<h2 id="section:otroslenguajes">Expresiones Regulares en Otros Lenguajes</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p>El siguiente ejemplo muestra un programa estilo <code>grep</code>: solicita una expresión regular para aplicarla luego a una serie de entradas leídas desde la entrada estandar.</p>
<pre><code>casiano@nereida:~/projects/PA/regexp$ cat -n Application.java
 1  /**
 2   * javac Application.java
 3   * java Application
 4   */
 5
 6  import java.io.*;
 7  import java.util.regex.Pattern;
 8  import java.util.regex.Matcher;
 9
10  public class Application {
11
12      public static void main(String[] args){
13          String regexp = &quot;&quot;;
14          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
15          try {
16              System.out.print(&quot;Enter your regex: &quot;);
17              regexp = br.readLine();
18          } catch (IOException e) { System.exit(1); };
19          while (true) {
20
21              String input = &quot;&quot;;
22              try {
23                System.out.print(&quot;Enter input string to search: &quot;);
24                input = br.readLine();
25              } catch (IOException e) { System.exit(1); };
26
27              Pattern pattern = Pattern.compile(regexp);
28              Matcher matcher = pattern.matcher(input);
29
30              boolean found = false;
31              while (matcher.find()) {
32                  System.out.println(&quot;I found the text &quot;
33                                     + matcher.group()
34                                     + &quot; starting at index &quot;
35                                     + matcher.start()
36                                     + &quot; and ending at index &quot;
37                                     +matcher.end()
38                  );
39                  found = true;
40              }
41              if(!found){
42                  System.out.println(&quot;No match found.&quot;);
43              }
44          }
45      }
46  }</code></pre>
<p>Ejecución:</p>
<pre><code>casiano@nereida:~/Ljavatesting$ java Application
Enter your regex: (\d+).(\d+)
Enter input string to search: a4b5d6c7efg
I found the text 4b5 starting at index 1 and ending at index 4
I found the text 6c7 starting at index 5 and ending at index 8
Enter input string to search: abc
No match found.
Enter input string to search:</code></pre>
<p>Véase también <span>http://java.sun.com/docs/books/tutorial/essential/regex/</span></p>
<p>Esta es una versión en <code>bash</code> del conversor de temperaturas visto en las secciones anteriores:</p>
<pre><code>pl@nereida:~/src/bash$ cat -n f2c
     1  #!/bin/bash
     2  echo &quot;Enter a temperature (i.e. 32F, 100C):&quot;;
     3  read input;
     4
     5  if [ -z &quot;$(echo $input | grep -i &#39;^[-+]\?[0-9]\+\(\.[0-9]*\)\?\ *[CF]$&#39;)&quot; ]
     6  then
     7    echo &quot;Expecting a temperature, so don&#39;t understand \&quot;$input\&quot;.&quot; 1&gt;&amp;2;
     8  else
     9    input=$(echo $input | tr -d &#39; &#39;);
    10    InputNum=${input:0:${#input}-1};
    11    Type=${input: -1}
    12
    13    if [ $Type = &quot;c&quot; -o $Type = &quot;C&quot; ]
    14    then
    15     celsius=$InputNum;
    16     fahrenheit=$(echo &quot;scale=2; ($celsius * 9/5)+32&quot; | bc -l);
    17    else
    18     fahrenheit=$InputNum;
    19     celsius=$(echo &quot;scale=2; ($fahrenheit -32)*5/9&quot; | bc -l);
    20    fi
    21
    22    echo &quot;$celsius C = $fahrenheit F&quot;;
    23  fi</code></pre>
<pre><code>pl@nereida:~/src/regexpr$ cat -n pcregrep.c
 1  #include &lt;stdio.h&gt;
 2  #include &lt;stdlib.h&gt;
 3  #include &lt;string.h&gt;
 4  #include &lt;assert.h&gt;
 5  #include &lt;pcre.h&gt;
 6
 7  char enter_reverse_mode[] = &quot;\33[7m&quot;;
 8  char exit_reverse_mode[] = &quot;\33[0m&quot;;
 9
10  int main(int argc, char **argv)
11  {
12    const char *pattern;
13    const char *errstr;
14    int erroffset;
15    pcre *expr;
16    char line[512];
17    assert(argc == 2); /* XXX fixme */
18    pattern = argv[1];
19    if (!(expr = pcre_compile(pattern, 0, &amp;errstr, &amp;erroffset, 0))) {
20      fprintf(stderr, &quot;%s: %s\n&quot;, pattern, errstr);
21      return EXIT_FAILURE;
22    }
23    while (fgets(line, sizeof line, stdin)) {
24      size_t len = strcspn(line, &quot;\n&quot;);
25      int matches[2];
26      int offset = 0;
27      int flags = 0;
28      line[len] = &#39;\0&#39;;
29      while (0 &lt; pcre_exec(expr, 0, line, len, offset, flags, matches, 2)) {
30        printf(&quot;%.*s%s%.*s%s&quot;,
31          matches[0] - offset, line + offset,
32          enter_reverse_mode,
33          matches[1] - matches[0], line + matches[0],
34          exit_reverse_mode);
35        offset = matches[1];
36        flags |= PCRE_NOTBOL;
37      }
38      printf(&quot;%s\n&quot;, line + offset);
39    }
40    return EXIT_SUCCESS;
41  }</code></pre>
<p>Compilación:</p>
<pre><code>pl@nereida:~/src/regexpr$ gcc -lpcre pcregrep.c -o pcregrep</code></pre>
<p>Cuando se ejecuta espera un patrón en la línea de comandos y pasa a leer desde la entrada estandar. Las cadenas que casan se muestran resaltadas:</p>
<pre><code>pl@nereida:~/src/regexpr$ ./pcregrep &#39;\d+&#39;
435 otro 23</code></pre>
<p><span>otro</span></p>
<pre><code>hola
hola</code></pre>
<pre><code>pl@nereida:~/src/python$ cat -n c2f.py
 1  #!/usr/local/bin/python
 2  import re
 3
 4  temp = raw_input( &#39; Introduzca una temperatura (i.e. 32F, 100C): &#39; )
 5  pattern = re.compile( &quot;^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$&quot;, re.IGNORECASE )
 6  mo = pattern.match( temp )
 7
 8  if mo:
 9    inputNum = float(mo.group( 1 ))
10    type = mo.group( 3 )
11    celsius = 0.0
12    fahrenheit = 0.0
13    if ( type == &quot;C&quot; or type == &quot;c&quot; ) :
14      celsius = inputNum
15      fahrenheit = ( celsius * 9/5 ) + 32
16    else :
17      fahrenheit = inputNum
18      celsius = ( fahrenheit - 32 ) * 5/9
19    print &quot; &quot;, &#39;%.2f&#39;%(celsius), &quot; C = &quot;, &#39;%.2f&#39;%(fahrenheit), &quot; F\n&quot;
20  else :
21    print &quot; Se experaba una temperatura, no se entiende&quot;, temp, &quot;\n&quot;</code></pre>
<pre><code>pl@nereida:~/src/ruby$ cat -n f2c_b
 1  #!/usr/bin/ruby
 2
 3  # Primero leemos una temperatura
 4  class Temperature_calculator
 5    def initialize temp
 6    comp = Regexp.new(&#39;^([-+]?\d+(\.\d*)?)\s*([CFcf])$&#39;)
 7    if temp =~ comp
 8    begin
 9      cifra = Float($1)
10      @C,@F = ( $3 == &quot;F&quot; or $3 == &quot;f&quot;)? [(cifra -32) * 5/9, cifra] : [cifra , cifra * 9/5 + 32]
11    end
12    else
13      raise(&quot;Entrada incorrecta&quot;)
14    end
15  end
16
17    def show
18      puts &quot;Temperatura en Celsius: #{@C}, temperatura en Fahrenheit: #{@F}&quot;
19    end
20  end
21
22  temperatura = Temperature_calculator.new(readline.chop)
23  temperatura.show</code></pre>
<pre><code>&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;&lt;!--
function demoMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  if (document.demoMatch.subject.value.match(re)) {
    alert(&quot;Successful match&quot;);
  } else {
    alert(&quot;No match&quot;);
  }
}

function demoShowMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  var m = re.exec(document.demoMatch.subject.value);
  if (m == null) {
    alert(&quot;No match&quot;);
  } else {
    var s = &quot;Match at position &quot; + m.index + &quot;:\n&quot;;
    for (i = 0; i &lt; m.length; i++) {
      s = s + m[i] + &quot;\n&quot;;
    }
    alert(s);
  }
}

function demoReplaceClick() {
  var re = new RegExp(document.demoMatch.regex.value, &quot;g&quot;);
  document.demoMatch.result.value = 
    document.demoMatch.subject.value.replace(re, 
      document.demoMatch.replacement.value);
}
// --&gt;
&lt;/SCRIPT&gt;

&lt;FORM ID=&quot;demoMatch&quot; NAME=&quot;demoMatch&quot; METHOD=POST ACTION=&quot;javascript:void(0)&quot;&gt;
&lt;P&gt;Regexp: &lt;INPUT TYPE=TEXT NAME=&quot;regex&quot; VALUE=&quot;\bt[a-z]+\b&quot; SIZE=50&gt;&lt;/P&gt;
&lt;P&gt;Subject string: &lt;INPUT TYPE=TEXT NAME=&quot;subject&quot; 
   VALUE=&quot;This is a test of the JavaScript RegExp object&quot; SIZE=50&gt;&lt;/P&gt;
&lt;P&gt;&lt;INPUT TYPE=SUBMIT VALUE=&quot;Test Match&quot; ONCLICK=&quot;demoMatchClick()&quot;&gt;
&lt;INPUT TYPE=SUBMIT VALUE=&quot;Show Match&quot; ONCLICK=&quot;demoShowMatchClick()&quot;&gt;&lt;/P&gt;

&lt;P&gt;Replacement text: &lt;INPUT TYPE=TEXT NAME=&quot;replacement&quot; VALUE=&quot;replaced&quot; SIZE=50&gt;&lt;/P&gt;
&lt;P&gt;Result: &lt;INPUT TYPE=TEXT NAME=&quot;result&quot; 
   VALUE=&quot;click the button to see the result&quot; SIZE=50&gt;&lt;/P&gt;
&lt;P&gt;&lt;INPUT TYPE=SUBMIT VALUE=&quot;Replace&quot; ONCLICK=&quot;demoReplaceClick()&quot;&gt;&lt;/P&gt;
&lt;/FORM&gt;</code></pre>
<h2 id="casos-de-estudio">Casos de Estudio</h2>
<h3 id="section:numeros">Secuencias de números de tamaño fijo</h3>
<p>El siguiente problema y sus soluciones se describen en el libro de J.E.F. Friedl <span class="citation"></span>. Supongamos que tenemos un texto conteniendo códigos que son números de tamaño fijo, digamos seis dígitos, todos pegados, sin separadores entre ellos, como sigue:</p>
<p>012345678901<span><strong>123334</strong></span>234567890123<span><strong>125934</strong></span>890123345126</p>
<p>El problema es encontrar los códigos que comienzan por <span>12</span>. En negrita se han resaltado las soluciones. Son soluciones sólo aquellas que, comienzan por <code>12</code> en una posición múltiplo de seis. Una solución es:</p>
<pre><code>@nums = grep {m/^12/} m/\d{6}/g;</code></pre>
<p>que genera una lista con los números y luego selecciona los que comienzan por <code>12</code>. Otra solución es:</p>
<pre><code>@nums = grep { defined } m/(12\d{4})|\d{6}/g;</code></pre>
<p>que aprovecha que la expresión regular devolverá una lista vacía cuando el número no empieza por <code>12</code>:</p>
<pre><code>DB&lt;1&gt; $x = &#39;012345678901123334234567890123125934890123345126&#39;
DB&lt;2&gt; x  ($x =~ m/(12\d{4})|\d{6}/g)
0  undef
1  undef
2  123334
3  undef
4  undef
5  125934
6  undef
7  undef</code></pre>
<p>Obsérvese que se esta utilizando también que el operador <code>|</code> no es <em>greedy</em>.</p>
<p>¿Se puede resolver el problema usando sólamente una expresión regular? Obsérvese que esta solución “casi funciona”:</p>
<pre><code> DB&lt;3&gt; x @nums = $x =~ m/(?:\d{6})*?(12\d{4})/g;
0  123334
1  125934
2  123345</code></pre>
<p>recoge la secuencia mas corta de grupos de seis dígitos que no casan, seguida de una secuencia que casa. El problema que tiene esta solución es al final, cuando se han casado todas las soluciones, entonces la búsqueda exhaustiva hará que nos muestre soluciones que no comienzan en posiciones múltiplo de seis. Por eso encuentra <code>123345</code>:</p>
<p>012345678901<span><strong>123334</strong></span>234567890123<span><strong>125934</strong></span>890<span><strong>123345</strong></span>126</p>
<p>Por eso, Friedl propone esta solución:</p>
<pre><code>@nums = m/(?:\d{6})*?(12\d{4})(?:(?!12)\d{6})*/g;</code></pre>
<p>Se asume que existe al menos un éxito en la entrada inicial. Que es un extraordinario ejemplo de como el uso de paréntesis de agrupamiento simplifica y mejora la legibilidad de la solución. Es fantástico también el uso del operador de predicción negativo.</p>
<p>El ancla <code>\G</code> ha sido concebida para su uso con la opción <code>/g</code>. Casa con el punto en la cadena en el que terminó el último emparejamiento. Cuando se trata del primer intento o no se está usando <code>/g</code>, usar <code>\G</code> es lo mismo que usar <code>\A</code>.</p>
<p>Mediante el uso de este ancla es posible formular la siguiente solución al problema planteado:</p>
<pre><code>pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
DB&lt;1&gt; $_ = &#39;012345678901123334234567890123125934890123345126&#39;
DB&lt;2&gt; x m/\G(?:\d{6})*?(12\d{4})/g
0  123334
1  125934</code></pre>
<p>Si lo que se quiere es sustituir las secuencias deseadas es poisble hacerlo con la siguiente expresión regular:</p>
<pre><code>casiano@nereida:~/docs/curriculums/CV_MEC$ perl -wde 0
DB&lt;1&gt; x $x = &#39;012345678901123334234567890123125934890123345126&#39;
0  012345678901123334234567890123125934890123345126
DB&lt;2&gt; x  ($y = $x) =~ s/(12\d{4})|\d{6}/$1? &quot;-$1-&quot;:$&amp; /ge
0  8
DB&lt;3&gt; p $y
012345678901-123334-234567890123-125934-890123345126</code></pre>
<h3 id="section:repetidas">Palabras Repetidas</h3>
<p>Su jefe le pide una herramienta que compruebe la aparición de duplicaciones consecutivas en un texto texto (como esta esta y la anterior anterior). La solución debe cumplir las siguientes especificaciones:</p>
<ul>
<li><p>Aceptar cualquier número de ficheros. Resaltar las apariciones de duplicaciones. Cada línea del informe debe estar precedida del nombre del fichero.</p></li>
<li><p>Funcionar no sólo cuando la duplicación ocurre en la misma línea.</p></li>
<li><p>Funcionar independientemente del <em>case</em> y de los blancos usados en medio de ambas palabras.</p></li>
<li><p>Las palabras en cuestión pueden estar separadas por <em>tags</em> <code>HTML</code>.</p></li>
</ul>
<pre><code>  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Term::ANSIScreen qw/:constants/;
  4  
  5  my $bold = BOLD();
  6  my $clear = CLEAR();
  7  my $line = 1;
  8  
  9  # read paragraph
 10  local $/ = &quot;.\n&quot;;
 11  while (my $par = &lt;&gt;) {
 12    next unless $par =~ s{
 13          \b                 # start word ...
 14          ([a-z]+)           # grab word in $1 and \1
 15          (                  # save the tags and spaces in $2
 16          (\s|&lt;[^&gt;]+&gt;)+      # spaces or HTML tags 
 17          )   
 18          (\1\b)             # repeated word in $4
 19    }!$bold$1$clear$2$bold$4$clear!igx;
 20  
 21    $par =~ s/^/&quot;$ARGV(&quot;.$line++.&quot;): &quot;/meg;   # insert filename and line number
 22  
 23    print $par;
 24  }</code></pre>
<pre><code>
&lt;pre&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;Term::ANSIScreen &lt;span class=&quot;synConstant&quot;&gt;qw/:constants/&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$bold&lt;/span&gt; = BOLD();
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$clear&lt;/span&gt; = CLEAR();
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; &lt;span class=&quot;synComment&quot;&gt;# read paragraph&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;.&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$par&lt;/span&gt; = &amp;lt;&amp;gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$par&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;s{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\b&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                 # start word &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([a-z]+)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;           # grab word in &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; and &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;                  # save the tags and spaces in &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$2&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\s&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;|&amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[^&amp;gt;]+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)+&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;      # spaces or HTML tags &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;   &lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(\1\b)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;             # repeated word in &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$4&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}&lt;/span&gt;!&lt;span class=&quot;synIdentifier&quot;&gt;$bold$1$clear$2$bold$4$clear&lt;/span&gt;!igx;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$par&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;s/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$ARGV&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;(&amp;quot;.&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;++.&amp;quot;): &amp;quot;&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/meg&lt;/span&gt;;   &lt;span class=&quot;synComment&quot;&gt;# insert filename and line number&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$par&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; }
&lt;/pre&gt;</code></pre>
<pre><code>Sigue un ejemplo de uso:
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n t.t
     1  one one
     2  nothing rep
     3  is two three
     4  three four
     5
pl@nereida:~/Lperltesting$ ./repeatedwords2.pl t.t
t.t(1): &lt;font color=&quot;blue&quot;&gt;one one&lt;/font&gt;
t.t(2): nothing rep
t.t(3): is two &lt;font color=&quot;blue&quot;&gt;three&lt;/font&gt;
t.t(4): &lt;font color=&quot;blue&quot;&gt;three&lt;/font&gt; four
t.t(5):
&lt;/pre&gt;</code></pre>
<h3 id="section:csv">Análisis de cadenas con datos separados por comas</h3>
<p>Supongamos que tenemos cierto texto en <code>$text</code> proveniente de un fichero <code>CSV</code> (<em>Comma Separated Values</em>). Esto es el fichero contiene líneas con el formato:</p>
<pre><code>&quot;earth&quot;,1,&quot;moon&quot;,9.374</code></pre>
<p>Esta línea representa cinco campos. Es razonable querer guardar esta información en un <em>array</em>, digamos <code>@field</code>, de manera que <code>$field[0] == 'earth'</code>, <code>$field[1] == '1'</code>, etc. Esto no sólo implica descomponer la cadena en campos sino también quitar las comillas de los campos entrecomillados. La primera solución que se nos ocurre es hacer uso de la función <code>split</code>:</p>
<pre><code>@fields = split(/,/,$text);</code></pre>
<p>Pero esta solución deja las comillas dobles en los campos entrecomillados. Peor aún, los campos entrecomillados pueden contener comas, en cuyo caso la división proporcionada por <code>split</code> sería errónea.</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 use Text::ParseWords;
   3 
   4 sub parse_csv {
   5   my $text = shift;
   6   my @fields = (); # initialize @fields to be empty
   7 
   8   while ($text =~ 
   9     m/&quot;(([^&quot;\\]|\\.)*)&quot;,? # quoted fields
  10       | 
  11       ([^,]+),?           # $3 = non quoted fields
  12       | 
  13       ,                   # allows empty fields
  14     /gx 
  15     )
  16   {
  17     push(@fields, defined($1)? $1:$3); # add the just matched field
  18   }
  19   push(@fields, undef) if $text =~ m/,$/; #account for an empty last field
  20   return @fields;
  21 }
  22        
  23 $test = &#39;&quot;earth&quot;,1,&quot;a1, a2&quot;,&quot;moon&quot;,9.374&#39;;
  24 print &quot;string = \&#39;$test\&#39;\n&quot;;
  25 print &quot;Using parse_csv\n:&quot;;
  26 @fields = parse_csv($test);
  27 foreach $i (@fields) {
  28   print &quot;$i\n&quot;;
  29 }
  30 
  31 print &quot;Using Text::ParseWords\n:&quot;;
  32 #  @words = &amp;quotewords($delim, $keep, @lines);  
  33 #The $keep argument is a boolean flag.  If true, then the
  34 #tokens are split on the specified delimiter, but all other
  35 #characters (quotes, backslashes, etc.) are kept in the
  36 #tokens.  If $keep is false then the &amp;*quotewords()
  37 #functions remove all quotes and backslashes that are not
  38 #themselves backslash-escaped or inside of single quotes
  39 #(i.e., &amp;quotewords() tries to interpret these characters
  40 #just like the Bourne shell). 
  41 
  42 @fields = quotewords(&#39;,&#39;,0,$test);
  43 foreach $i (@fields) {
  44   print &quot;$i\n&quot;;
  45 }</code></pre>
<p>Las subrutinas en Perl reciben sus argumentos en el <em>array</em> <code>@_</code>. Si la lista de argumentos contiene listas, estas son “aplanadas” en una única lista. Si, como es el caso, la subrutina ha sido declarada antes de la llamada, los argumentos pueden escribirse sin paréntesis que les rodeen:</p>
<pre><code>@fields = parse_csv $test;</code></pre>
<p>Otro modo de llamar una subrutina es usando el prefijo <code>&amp;</code>, pero sin proporcionar lista de argumentos.</p>
<pre><code>@fields = &amp;parse_csv;</code></pre>
<p>En este caso se le pasa a la rutina el valor actual del <em>array</em> <code>@_</code>.</p>
<p>Los operadores <code>push</code> (usado en la línea 17) y <code>pop</code> trabajan sobre el final del <em>array</em>. De manera análoga los operadores <code>shift</code> y <code>unshift</code> lo hacen sobre el comienzo. El operador ternario <code>?</code> trabaja de manera análoga como lo hace en C.</p>
<p>El código del <code>push</code> podría sustituirse por este otro:</p>
<pre><code>push(@fields, $+);</code></pre>
<p>Puesto que la variable <code>$+</code> contiene la cadena que ha casado con el último paréntesis que haya casado en el ultimo “matching”.</p>
<p>La segunda parte del código muestra que existe un módulo en Perl, el módulo <code>Text::Parsewords</code> que proporciona la rutina <code>quotewords</code> que hace la misma función que nuestra subrutina.</p>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>&gt; csv.pl
string = &#39;&quot;earth&quot;,1,&quot;a1, a2&quot;,&quot;moon&quot;,9.374&#39;
Using parse_csv
:earth
1
a1, a2
moon
9.374
Using Text::ParseWords
:earth
1
a1, a2
moon
9.374    </code></pre>
<h3 id="las-expresiones-regulares-como-exploradores-de-un-árbol-de-soluciones">Las Expresiones Regulares como Exploradores de un Árbol de Soluciones</h3>
<p>El siguiente programa evalúa si un número es primo o no:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n isprime.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  my $num = shift;
 5  die &quot;Usage: $0 integer\n&quot; unless (defined($num) &amp;&amp; $num =~ /^\d+$/);
 6
 7  if ((&quot;1&quot; x $num) =~ /^(11+)\1+$/) {
 8    my $factor = length($1);
 9    print &quot;$num is $factor x &quot;.$num/$factor.&quot;\n&quot;;
10  }
11  else {
12    print &quot;$num is prime\n&quot;;
13  }</code></pre>
<p>Siguen varias ejecuciones:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./isprime.pl 35.32
Usage: ./isprime.pl integer
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 147
147 is 49 x 3
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 49
49 is 7 x 7
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime</code></pre>
<p>Según dice la entrada  en la wikipedia:</p>
<blockquote>
<p>In mathematics, a Diophantine equation is an indeterminate polynomial equation that allows the variables to be integers only.</p>
</blockquote>
<p>La siguiente sesión con el depurador muestra como se puede resolver una ecuación lineal diofántica con coeficientes positivos usando una expresión regular:</p>
<pre><code>  DB&lt;1&gt; # Resolvamos 3x + 2y + 5z = 40
DB&lt;2&gt; x (&#39;a&#39;x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;
1  &#39;aa&#39;
2  &#39;aaaaa&#39;
DB&lt;3&gt; x map { length }  (&#39;a&#39;x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  33
1  2
2  5
DB&lt;4&gt; @c = (3, 2, 5)
DB&lt;5&gt; x map { length($_) / $c[$i++] }  (&#39;a&#39;x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  11
1  1
2  1
DB&lt;6&gt; p 3*11+2*1+5*1
40</code></pre>
<p>Usando el verbo <code>(*FAIL)</code> es posible obtener todas las soluciones:</p>
<pre><code>main::(-e:1):   0
DB&lt;1&gt;  sub equ { my @c = @_; print &quot;\t3*$c[0]+2*$c[1]+5*$c[2] = &quot;,3*$c[0]+2*$c[1]+5*$c[2],&quot;\n&quot; }
DB&lt;2&gt; sub f { my @c = ((length($1)/3), (length($2)/2), (length($3)/5)); equ(@c); }
DB&lt;3&gt; x (&#39;a&#39;x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$(?{ f() })(*FAIL)/x
        3*11+2*1+5*1 = 40
        3*9+2*4+5*1 = 40
        3*8+2*3+5*2 = 40
        3*7+2*7+5*1 = 40
        3*7+2*2+5*3 = 40
        3*6+2*6+5*2 = 40
        3*6+2*1+5*4 = 40
        3*5+2*10+5*1 = 40
        3*5+2*5+5*3 = 40
        3*4+2*9+5*2 = 40
        3*4+2*4+5*4 = 40
        3*3+2*13+5*1 = 40
        3*3+2*8+5*3 = 40
        3*3+2*3+5*5 = 40
        3*2+2*12+5*2 = 40
        3*2+2*7+5*4 = 40
        3*2+2*2+5*6 = 40
        3*1+2*16+5*1 = 40
        3*1+2*11+5*3 = 40
        3*1+2*6+5*5 = 40
        3*1+2*1+5*7 = 40
  empty array
DB&lt;4&gt;                                </code></pre>
<p>El siguiente programa recibe en línea de comandos los coeficientes y término inependeinte de una ecuación lineal diofántica con coeficientes positivos y muestra todas las soluciones. El algoritmo primero crea una cadena conteniendo el código Perl que contiene la expresión regular adecuada para pasar luego a evaluarlo:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n diophantinesolvergen.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3  use strict;
 4
 5  # Writes a Perl solver for
 6  # a1 x1 + a2 x2 + ... + an xn = b
 7  # a_i and b integers &gt; 0
 8  #
 9
10  my $b = pop;
11  my @a = @ARGV;
12  my $debug = 1;
13
14  my $b1 = &#39;1&#39;x$b;
15  my @a1 = map { &#39;1&#39;x$_ } @a;
16  my @index = map { &#39;length($&#39;.$_.&quot;)/&quot;.$a[$_-1] } 1..(@a);
17  my $aux = join &quot;,&quot;, @index;
18
19  my $regexp = &#39;^&#39;;
20  $regexp .= &quot;((?:$_)+)&quot; for @a1;
21
22  $regexp .= &#39;$(?{ f() })(*FAIL)&#39;;
23
24  my $solver = &lt;&lt;&quot;SOLVER&quot;;
25  my \@stack;
26  sub f {
27    my \@s = ($aux);
28    push \@stack, [ \@s ];
29  }
30
31  q{$b1} =~ m{$regexp}x;
32
33  return \@stack;
34  SOLVER
35
36  print &quot;Solver:\n--------\n$solver\n--------\n&quot; if $debug;
37
38  my @stack = eval $solver;
39
40  say(&quot;@$_&quot;) for @stack</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./diophantinesolvergen.pl 3 2 5 40
Solver:
--------
my @stack;
sub f {
  my @s = (length($1)/3,length($2)/2,length($3)/5);
  push @stack, [ @s ];
}

q{1111111111111111111111111111111111111111} =~ m{^((?:111)+)((?:11)+)((?:11111)+)$(?{ f() })(*FAIL)}x;

return @stack;

--------
11 1 1
9 4 1
8 3 2
7 7 1
7 2 3
6 6 2
6 1 4
5 10 1
5 5 3
4 9 2
4 4 4
3 13 1
3 8 3
3 3 5
2 12 2
2 7 4
2 2 6
1 16 1
1 11 3
1 6 5
1 1 7</code></pre>
<p>[parrfo:lastreshijas]</p>
<p>En la páginas de Retos Matemáticos de</p>
<p>puede encontrarse el siguiente problema:</p>
<p>Dos matemáticos se vieron en la calle después de muchos años sin coincidir.</p>
<ul>
<li><p>¡Hola!, ¿qué tal?, ¿te casaste?, y... ¿cuántos hijos tienes?</p></li>
<li><p>Pues tengo tres hijas.</p></li>
<li><p>¿y qué años tienen?</p></li>
<li><p>¡A ver si lo adivinas!: el producto de las edades de las tres es 36, y su suma es el número del portal que ves enfrente...</p></li>
<li><p>¡Me falta un dato!</p></li>
<li><p>¡Ah, sí!, ¡la mayor toca el piano!</p></li>
</ul>
<p>¿Qué edad tendrán las tres hijas?</p>
<p>¿Podemos ayudarnos de una expresión regular para resolver el problema? Al ejecutar el siguiente programa:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n playspiano.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
 2  use v5.10;
 3  use strict;
 4  use List::Util qw{sum};
 5
 6  local our %u;
 7  sub f {
 8    my @a = @_;
 9    @a = sort { $b &lt;=&gt; $a } (length($a[1]), length($a[0])/length($a[1]), 36/length($a[0]) );
10
11    local $&quot; = &quot;, &quot;;
12    say &quot;(@a)\t &quot;.sum(@a) unless exists($u{&quot;@a&quot;});
13    $u{&quot;@a&quot;} = undef;
14  }
15
16  say &quot;SOL\t\tNUMBER&quot;;
17  my @a =  (&#39;1&#39;x36) =~
18           /^((1+)\2+)(\1+)$
19                     (?{ f($1, $2, $3)
20                      })
21             (*FAIL)
22           /x;</code></pre>
<p>obtenemos la salida:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./playspiano.pl
SOL             NUMBER
(9, 2, 2)        13
(6, 3, 2)        11
(4, 3, 3)        10
(18, 2, 1)       21
(12, 3, 1)       16
(9, 4, 1)        14
(6, 6, 1)        13</code></pre>
<p>Explique el funcionamiento del programa. A la vista de la salida ¿Cuáles eran las edades de las hijas?</p>
<p>Para una definición del problema vea la sección en los apuntes de LHP</p>
<p>¿Sería capaz de resolver usando expresiones regulares el problema de la mochila 0-1?</p>
<p>¡Si lo logra merece el premio a la solución mas freak que se haya encontrado para dicho problema!</p>
<p>Véase también:</p>
<ul>
<li><p>Véase el nodo en <em>The Oldest Plays the Piano</em></p></li>
<li></li>
</ul>
<h3 id="número-de-substituciones-realizadas">Número de substituciones realizadas</h3>
<p>El operador de substitución devuelve el número de substituciones realizadas, que puede ser mayor que uno si se usa la opción <code>/g</code>. En cualquier otro caso retorna el valor falso.</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 undef($/);
   3 $paragraph = &lt;STDIN&gt;;
   4 $count = 0;
   5 $count = ($paragraph =~ s/Mister\b/Mr./ig);
   6 print &quot;$paragraph&quot;;
   7 print &quot;\n$count\n&quot;;</code></pre>
<p>El resultado de la ejecución es el siguiente:</p>
<pre><code>&gt; numsust.pl
Dear Mister Bean,
Is a pleasure for me and Mister Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mister Goofy.
 
Yours sincerely
  Mister Mickey Mouse
Dear Mr. Bean,
Is a pleasure for me and Mr. Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mr. Goofy.
 
Yours sincerely
  Mr. Mickey Mouse
 
4   </code></pre>
<h3 id="expandiendo-y-comprimiendo-tabs">Expandiendo y comprimiendo tabs</h3>
<p>Este programa convierte los tabs en el número apropiado de blancos.</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  
   4  my @string = &lt;&gt;;
   5  
   6  for (@string) {
   7    while (s/\t+/&#39; &#39; x (length($&amp;)*8 - length($`)%8)/e) {}
   8    print $_;
   9  }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt; &lt;span class=&quot;synPreProc&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@string&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;@string&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;synStatement&quot;&gt;s/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\t+&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39; &#39; x (length(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)*8 - length(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$`&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)%8)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/e&lt;/span&gt;) {}
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt; }
&lt;/pre&gt;</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -nt tabs.in
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ ./expandtabs.pl tabs.in | cat -tn
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;cat -nt tabs.in&lt;/span&gt;
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ &lt;span class=&quot;dbuser&quot;&gt;./expandtabs.pl tabs.in | cat -tn&lt;/span&gt;
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
&lt;/pre&gt;</code></pre>
<p>¿Funciona igual si se cambia el bucle <code>while</code> por una opción <code>/g</code>?</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my @string = &lt;&gt;;
   5  
   6    for (@string) {
   7      s/\t+/&#39; &#39; x (length($&amp;)*8 - length($`)%8)/ge;
   8      print $_;
   9    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/perl -w&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@string&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;@string&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;s/&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\t+&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&#39; &#39; x (length(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)*8 - length(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$`&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)%8)&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;/ge&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>¿Porqué?</p>
<h3 id="modificación-de-múltiples-ficheros-one-liner">Modificación de Múltiples Ficheros: one liner</h3>
<p>Aunque no es la forma de uso habitual, Perl puede ser utilizado en “modo sed” para modificar el texto en múltiples ficheros:</p>
<p><code>perl  -e 's/nereida\.deioc\.ull\.es/miranda.deioc.ull.es/gi'  -p  -i.bak  *.html</code></p>
<p>Este programa sustituye la palabra original (g)lobalmente e i)gnorando el “case”) en todos los ficheros <code>*.html</code> y para cada uno de ellos crea una copia de seguridad <code>*.html.bak</code>.</p>
<p>Otro ejemplo: la sustitución que sigue ocurre en todos los ficheros <code>info.txt</code> en todos los subdirectorios de los subdirectorios que comiencen por <code>alu</code>:</p>
<pre><code>perl -e &#39;s/\|hyperpage//gi&#39; -p -i.bak  alu*/*/info.txt</code></pre>
<p>Las de comandos significan lo siguiente:</p>
<ul>
<li><p>puede usarse para definir el script en la línea de comandos. Multiples -e te permiten escribir un multi-script. Cuando se usa -e, perl no busca por un fichero de script entre la lista de argumentos.</p></li>
<li><p>La opción hace que perl incluya un bucle alrededor de tu “script” al estilo sed:</p>
<pre><code>while (&lt;&gt;) {
        ...             # your script goes here
} continue {
        print;
}</code></pre></li>
<li><p>Nótese que las líneas se imprimen automáticamente. Para suprimir la impresión usa la opción</p></li>
<li><p>] La opción Expresa que los ficheros procesados serán modificados. Se renombra el fichero de entrada <code>file.in</code> a <code>file.in.ext</code>, abriendo el de salida con el mismo nombre del fichero de entrada <code>file.in</code>. Se selecciona dicho fichero como de salida por defecto para las sentencias <code>print</code>. Si se proporciona una extensión se hace una copia de seguridad. Si no, no se hace copia de seguridad.</p></li>
</ul>
<p>En general las opciones pueden ponerse en la primera línea del “script”, donde se indica el intérprete. Asi pues, decir</p>
<p><code>perl -p -i.bak -e &quot;s/foo/bar/;&quot;</code></p>
<p>es equivalente a usar el “script”:</p>
<pre><code>#!/usr/bin/perl -pi.bak
s/foo/bar/;</code></pre>
<h2 id="section:tr">tr y split</h2>
<p>El operador de traducción permite la conversión de unos caracteres por otros. Tiene la sintáxis:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><code>tr/SEARCHLIST/REPLACEMENTLIST/cds</code></td>
</tr>
<tr class="even">
<td align="left"><code>y/SEARCHLIST/REPLACEMENTLIST/cds</code></td>
</tr>
</tbody>
</table>
<p>El operador permite el reemplazo carácter a carácter, por ejemplo:</p>
<pre><code>$ perl -de 0
  DB&lt;1&gt; $a = &#39;fiboncacci&#39;
  DB&lt;2&gt; $a =~ tr/aeiou/AEIOU/
  DB&lt;3&gt; print $a
fIbOncAccI
  DB&lt;4&gt; $a =~ y/fbnc/FBNC/
  DB&lt;5&gt; print $a
FIBONCACCI</code></pre>
<p>El operador devuelve el número de carácteres reeemplazados o suprimidos.</p>
<pre><code>$cnt = $sky =~ tr/*/*/; # count the stars in $sky</code></pre>
<p>Si se especifica el modificador <code>/d</code>, cualquier carácter en <code>SEARCHLIST</code> que no figure en <code>REPLACEMENTLIST</code> es eliminado.</p>
<pre><code>  DB&lt;6&gt; print $a
FIBONCACCI
  DB&lt;7&gt; $a =~ y/OA//d
  DB&lt;8&gt; print $a
FIBNCCCI</code></pre>
<p>Si se especifica el modificador <code>/s</code>, las secuencias de carácteres consecutivos que serían traducidas al mismo carácter son comprimidas a una sola:</p>
<pre><code>  DB&lt;1&gt; $b = &#39;aaghhh!&#39;
  DB&lt;2&gt; $b =~ tr/ah//s
  DB&lt;3&gt; p $b
agh!</code></pre>
<p>Observa que si la cadena <code>REPLACEMENTLIST</code> es vacía, no se introduce ninguna modificación.</p>
<p>Si se especifica el modificador <code>/c</code>, se complementa <code>SEARCHLIST</code>; esto es, se buscan los caracteres que no están en <code>SEARCHLIST</code>.</p>
<pre><code>tr/a-zA-Z/ /cs; # change non-alphas to single space</code></pre>
<p>Cuando se dan múltiples traducciones para un mismo carácter, solo la primera es utilizada:</p>
<pre><code>tr/AAA/XYZ/</code></pre>
<p>traducirá <code>A</code> por <code>X</code>.</p>
<p>El siguiente <em>script</em> busca una expresión regular en el fichero de <code>passwords</code> e imprime los <em>login</em> de los usuarios que casan con dicha cadena. Para evitar posibles confusiones con las vocales acentuadas se usa el operador <code>tr</code>.</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 $search = shift(@ARGV) or die(&quot;you must provide a regexpr\n&quot;);
   3 $search =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   4 open(FILE,&quot;/etc/passwd&quot;);
   5 while ($line = &lt;FILE&gt;) {
   6   $line =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   7   if ($line =~ /$search/io) {
   8     @fields = split(&quot;:&quot;,$line);
   9     $login = $fields[0];
  10     if ($line !~ /^#/) {
  11       print &quot;$login\n&quot;;
  12     }
  13     else {
  14       print &quot;#$login\n&quot;;
  15     }
  16   }
  17 }
  18   </code></pre>
<p>Ejecución (suponemos que el nombre del fichero anterior es <code>split.pl</code>):</p>
<pre><code>&gt; split.pl Rodriguez
##direccion
call
casiano
alu5
alu6
##doctorado
paco
falmeida
##ihiu07 </code></pre>
<p>Para familiarizarte con este operador, codifica y prueba el siguiente código:</p>
<pre><code>   1 #!/usr/bin/perl -w
   2 $searchlist = shift @ARGV;
   3 $replacelist = shift @ARGV;
   4 $option = &quot;&quot;;
   5 $option = shift @ARGV if @ARGV;
   6 
   7 while (&lt;&gt;) {
   8   $num = eval &quot;tr/$searchlist/$replacelist/$option&quot;;
   9   die $@ if $@;
  10   print &quot;$num: $_&quot;;
  11 }</code></pre>
<p>Perl construye la tabla de traducción en “tiempo de compilación”. Por ello ni <code>SEARCHLIST</code> ni <code>REPLACEMENTLIST</code> son susceptibles de ser interpolados. Esto significa que si queremos usar variables tenemos que recurrir a la función <code>eval</code>.</p>
<p>La expresión pasada como parámetro a <code>eval</code> en la línea 8 es analizada y ejecutada como si se tratara de un pequeño programa Perl. Cualquier asignación a variables permanece después del <code>eval</code>, asi como cualquier definición de subrutina. El código dentro de <code>eval</code> se trata como si fuera un bloque, de manera que cualesquiera variables locales (declaradas con <code>my</code>) desaparecen al final del bloque.</p>
<p>La variable <code>$@</code> contiene el mensaje de error asociado con la última ejecución del comando <code>eval</code>. Si es nula es que el último comando se ejecuto correctamente. Aqui tienes un ejemplo de llamada:</p>
<pre><code>&gt; tr.pl &#39;a-z&#39; &#39;A-Z&#39; s
jose hernandez
13: JOSE HERNANDEZ
joosee hernnandez
16: JOSE HERNANDEZ </code></pre>
<h2 id="section:pack"><span>Pack</span> y <span>Unpack</span></h2>
<p>El operador <code>pack</code> trabaja de forma parecida a <code>sprintf</code>. Su primer argumento es una cadena, seguida de una lista de valores a formatear y devuelve una cadena:</p>
<pre><code>pack(&quot;CCC&quot;, 65, 66, 67, 68) # empaquetamos A B C D</code></pre>
<p>el inverso es el operador <code>unpack</code></p>
<pre><code>unpack(&quot;CCC&quot;, &quot;ABCD&quot;)</code></pre>
<p>La cadena de formato es una lista de especificadores que indican el tipo del dato que se va a empaquetar/desempaquetar. Cada especificador puede opcionalmente seguirse de un contador de repetición que indica el número de elementos a formatear. Si se pone un asterisco (<code>*</code>) se indica que la especificación se aplica a todos los elementos restantes de la lista.</p>
<table>
<tbody>
<tr class="odd">
<td align="left">Formato</td>
<td align="left">Descripción</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">Una cadena completada con blancos</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">a</td>
<td align="left">Una cadena completada con ceros</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">B</td>
<td align="left">Una cadena binaria en orden descendente</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">b</td>
<td align="left">Una cadena binaria en orden ascendente</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">H</td>
<td align="left">Una cadena hexadecimal, los nibble altos primero</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">h</td>
<td align="left">Una cadena hexadecimal, los nibble bajos primero</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Ejemplo de uso del formato <code>A</code>:</p>
<pre><code>DB&lt;1&gt; $a = pack &quot;A2A3&quot;, &quot;Pea&quot;,&quot;rl&quot;
DB&lt;2&gt; p $a
Perl
DB&lt;3&gt; @b = unpack &quot;A2A3&quot;, &quot;Perl&quot;
DB&lt;4&gt; p &quot;@b&quot;
Pe rl</code></pre>
<p>La variable <code>@b</code> tiene ahora dos cadenas. Una es <code>Pe</code> la otra es <code>rl</code>. Veamos un ejemplo con el formato <code>B</code>:</p>
<pre><code>p ord(&#39;A&#39;)
65
DB&lt;22&gt; $x = pack &quot;B8&quot;, &quot;01000001&quot;
DB&lt;23&gt; p $x
A
DB&lt;24&gt; @y = unpack &quot;B8&quot;, &quot;A&quot;
DB&lt;25&gt; p &quot;@y&quot;
01000001
DB&lt;26&gt; $x = pack &quot;b8&quot;, &quot;10000010&quot;
DB&lt;27&gt; p $x</code></pre>
<p>[practica:invitaciones]</p>
<p>En el capítulo 6 (sección 6.4.2.2) del libro se define un lenguaje para componer textos para enviar invitaciones.</p>
<p>Para escribir una invitación en ese lenguaje escribiríamos algo así:</p>
<pre><code>pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  &lt;?xml version=&quot;1.0&quot;?&gt;
 2  &lt;!DOCTYPE invitation SYSTEM &quot;invitation.dtd&quot;&gt;
 3  &lt;invitation&gt;
 4  &lt;!-- ++++ The header part of the document ++++ --&gt;
 5  &lt;front&gt;
 6  &lt;to&gt;Anna, Bernard, Didier, Johanna&lt;/to&gt;
 7  &lt;date&gt;Next Friday Evening at 8 pm&lt;/date&gt;
 8  &lt;where&gt;The Web Cafe&lt;/where&gt;
 9  &lt;why&gt;My first XML baby&lt;/why&gt;
10  &lt;/front&gt;
11  &lt;!-- +++++ The main part of the document +++++ --&gt;
12  &lt;body&gt;
13  &lt;par&gt;
14  I would like to invite you all to celebrate
15  the birth of &lt;emph&gt;Invitation&lt;/emph&gt;, my
16  first XML document child.
17  &lt;/par&gt;
18  &lt;par&gt;
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  &lt;/par&gt;
22  &lt;par&gt;
23  I &lt;emph&gt;really&lt;/emph&gt; look forward to see you soon!
24  &lt;/par&gt;
25  &lt;/body&gt;
26  &lt;!-- +++ The closing part of the document ++++ --&gt;
27  &lt;back&gt;
28  &lt;signature&gt;Michel&lt;/signature&gt;
29  &lt;/back&gt;
30  &lt;/invitation&gt;</code></pre>
<p>La sintáxis del lenguaje queda reflejada en la siguiente () que aparece en la sección 6.4.3 del libro de Goosens:</p>
<pre><code>pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.dtd
 1  &lt;!-- invitation DTD   --&gt;
 2  &lt;!-- May 26th 1998 mg --&gt;
 3  &lt;!ELEMENT invitation (front, body, back) &gt;
 4  &lt;!ELEMENT front      (to, date, where, why?) &gt;
 5  &lt;!ELEMENT date       (#PCDATA) &gt;
 6  &lt;!ELEMENT to         (#PCDATA) &gt;
 7  &lt;!ELEMENT where      (#PCDATA) &gt;
 8  &lt;!ELEMENT why        (#PCDATA) &gt;
 9  &lt;!ELEMENT body       (par+) &gt;
10  &lt;!ELEMENT par        (#PCDATA|emph)* &gt;
11  &lt;!ELEMENT emph       (#PCDATA) &gt;
12  &lt;!ELEMENT back       (signature) &gt;
13  &lt;!ELEMENT signature  (#PCDATA) &gt;</code></pre>
<p>El objetivo de esta práctica es escribir un programa Perl que usando las extensiones para expresiones regulares presentes en la versión 5.10 reconozca el lenguaje anterior.</p>
<p>Véase también:</p>
<ul>
<li></li>
<li><p>(véanse los subdirectorios correspondietnes a los capítulos 6 y 7)</p></li>
</ul>
<h2 id="analisis-sintáctico-con-expresiones-regulares-perl">Analisis Sintáctico con Expresiones Regulares Perl</h2>
<h3 id="introducción-al-anaĺisis-sintáctico-con-expresiones-regulares">Introducción al Anaĺisis Sintáctico con Expresiones Regulares</h3>
<p>Como se ha comentado en la sección [subsection:regexp510lenrec] Perl 5.10 permite el reconocimiento de expresiones definidas mediante gramáticas recursivas, siempre que estas puedan ser analizadas por un analizador recursivo descendente. Sin embargo, las expresiones regulares Perl 5.10 hace difícil construir una representación del árbol de análisis sintáctico abstracto. Además, la necesidad de explicitar en la regexp los blancos existentes entre los símbolos hace que la descripción sea menos robusta y menos legible.</p>
<p>El siguiente ejemplo muestra una expresión regular que traduce expresiones de diferencias en infijo a postfijo.</p>
<p>Se usa una variable <code>$tran</code> para calcular la traducción de la subexpresión vista hasta el momento.</p>
<p>La gramática original que consideramos es recursiva a izquierdas:</p>
<pre><code> exp -&gt;   exp &#39;-&#39; digits
        | digits</code></pre>
<p>aplicando las técnicas explicadas en [subsection:eliminaleftrec] y en el nodo de perlmonks transformamos la gramática en:</p>
<pre><code>exp -&gt;   digits rest
rest -&gt;   &#39;-&#39; rest
        | # empty</code></pre>
<p>Sigue el código:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    # Infix to postfix translator using 5.10 regexp
  5    # original grammar:
  6    #  exp -&gt;   exp &#39;-&#39; digits
  7    #         | digits
  8    #
  9    # Applying left-recursion elimination we have:
 10    #  exp -&gt;   digits rest
 11    #  rest -&gt;   &#39;-&#39; rest
 12    #          | # empty
 13    #
 14    my $input;
 15    local our $tran = &#39;&#39;;
 16  
 17    my $regexp = qr{
 18        (?&amp;exp)
 19  
 20        (?(DEFINE)
 21            (?&lt;exp&gt;    ((?&amp;digits)) \s* (?{ $tran .= &quot;$^N &quot;; say &quot;tran=$tran&quot;; }) (?&amp;rest)
 22                          (?{
 23                             say &quot;exp -&gt; digits($^N) rest&quot;;
 24                          })
 25            )
 26  
 27            (?&lt;rest&gt;     \s* - ((?&amp;digits)) (?{ $tran .= &quot;$^N - &quot;; say &quot;tran=$tran&quot;; }) (?&amp;rest)
 28                            (?{
 29                               say &quot;rest -&gt; - digits($^N) rest&quot;;
 30                            })
 31                      |  # empty
 32                            (?{
 33                               say &quot;rest -&gt; empty&quot;;
 34                            })
 35            )
 36  
 37            (?&lt;digits&gt;  \s* (\d+)
 38            )
 39        )
 40    }xms;
 41  
 42    $input = &lt;&gt;;
 43    chomp($input);
 44    if ($input =~ $regexp) {
 45      say &quot;matches: $&amp;\ntran=$tran&quot;;
 46    }
 47    else {
 48      say &quot;does not match&quot;;
 49    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Infix to postfix translator using 5.10 regexp&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# original grammar:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp -&amp;gt;   exp &#39;-&#39; digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#         | digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Applying left-recursion elimination we have:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp -&amp;gt;   digits rest&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  rest -&amp;gt;   &#39;-&#39; rest&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;exp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;DEFINE&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;exp&amp;gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;((?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;digits&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\s*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N &amp;quot;; say &amp;quot;tran=&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;; }&lt;/span&gt;) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rest&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;                         (?{
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;                            say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;exp -&amp;gt; digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rest&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;rest&amp;gt;&lt;/span&gt;     \s* - ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;)) (?{ &lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt; .= &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N - &amp;quot;&lt;/span&gt;; say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;tran=&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;; }) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rest&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;                           (?{
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;                              say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rest -&amp;gt; - digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rest&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt;                           })
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;                     |  &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;                           (?{
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;                              say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rest -&amp;gt; empty&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt;                           })
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;digits&amp;gt;&lt;/span&gt;  \s* (\d+)
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt;       )
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt;   }xms;
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   44&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   45&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;matches: &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;tran=&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$tran&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   46&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   47&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   48&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   49&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>La variable <code>$^N</code> contiene el valor que casó con el último paréntesis. Al ejecutar el código anterior obtenemos:</p>
<p>Véase la ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./infixtopostfix.pl
ab 5 - 3 -2 cd;
tran= 5
tran= 5  3 -
tran= 5  3 - 2 -
rest -&gt; empty
rest -&gt; - digits(2) rest
rest -&gt; - digits( 3) rest
exp -&gt; digits( 5) rest
matches:  5 - 3 -2
tran= 5  3 - 2 -</code></pre>
<p>Como se ve, el recorrido primero profundo se traduce en la reconstrucción de una derivación a derechas.</p>
<p>Es difícil extender el ejemplo anterior a lenguajes mas complejos debido a la limitación de que sólo se dispone de acceso al último paréntesis vía <code>$^N</code>. En muchos casos es necesario poder acceder a paréntesis/atributos anteriores.</p>
<p>El siguiente código considera el caso de expresiones con sumas, restas, multiplicaciones y divisiones. Utiliza la variable <code>op</code> y una acción intermedia (líneas 51-53) para almacenar el segundo paréntesis necesitado:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp -&gt;   exp [-+] term
 8    #         | term
 9    #  term -&gt;   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  -&gt;   term re
15    #  re   -&gt;   [+-] term re
16    #          | # empty
17    #  term -&gt;   digits rt
18    #  rt   -&gt;   [*/] rt
19    #          | # empty
20  
21  
22    my $input;
23    my @stack;
24  
25    local our $op = &#39;&#39;;
26    my $regexp = qr{
27        (?&amp;exp)
28  
29        (?(DEFINE)
30            (?&lt;exp&gt;    (?&amp;term) (?&amp;re)
31                         (?{ say &quot;exp -&gt; term re&quot; })
32            )
33  
34            (?&lt;re&gt;     \s* ([+-]) (?&amp;term) \s* (?{ push @stack, $^N }) (?&amp;re)
35                         (?{ say &quot;re -&gt; [+-] term re&quot; })
36                     | # empty
37                         (?{ say &quot;re -&gt; empty&quot; })
38            )
39  
40            (?&lt;term&gt;   ((?&amp;digits))
41                          (?{ # intermediate action
42                              push @stack, $^N
43                          })
44                       (?&amp;rt)
45                          (?{
46                              say &quot;term-&gt; digits($^N) rt&quot;;
47                          })
48            )
49  
50            (?&lt;rt&gt;     \s*([*/])
51                               (?{ # intermediate action
52                                  local $op = $^N;
53                               })
54                       ((?&amp;digits)) \s*
55                               (?{  # intermediate action
56                                    push @stack, $^N, $op
57                                })
58                       (?&amp;rt) # end of &lt;rt&gt; definition
59                               (?{
60                                    say &quot;rt -&gt; [*/] digits($^N) rt&quot;
61                                })
62                      |  # empty
63                         (?{ say &quot;rt -&gt; empty&quot; })
64            )
65  
66            (?&lt;digits&gt;  \s* \d+
67            )
68        )
69    }xms;
70  
71    $input = &lt;&gt;;
72    chomp($input);
73    if ($input =~ $regexp) {
74      say &quot;matches: $&amp;\nStack=(@stack)&quot;;
75    }
76    else {
77      say &quot;does not match&quot;;
78    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Infix to postfix translator using 5.10 regexp&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Original grammar:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp -&amp;gt;   exp [-+] term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#         | term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   term [*/] digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Applying left-recursion elimination we have:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp  -&amp;gt;   term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  re   -&amp;gt;   [+-] term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   digits rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  rt   -&amp;gt;   [*/] rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;our&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$op&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;&#39;&#39;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;exp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;DEFINE&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;exp&amp;gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;term&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;re&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ say &amp;quot;exp -&amp;gt; term re&amp;quot; }&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;re&amp;gt;&lt;/span&gt;     \s* ([+-]) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;term&lt;/span&gt;) \s* (?{ &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N }) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;re&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; [+-] term re&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt;                    | &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;term&amp;gt;&lt;/span&gt;   ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;))
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt;                         (?{ &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt;                             &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   44&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   45&lt;/span&gt;                         (?{
&lt;span class=&quot;synLinenum&quot;&gt;   46&lt;/span&gt;                             say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;term-&amp;gt; digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rt&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   47&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   48&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   49&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   50&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;rt&amp;gt;&lt;/span&gt;     \s*([*/])
&lt;span class=&quot;synLinenum&quot;&gt;   51&lt;/span&gt;                              (?{ &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   52&lt;/span&gt;                                 &lt;span class=&quot;synStatement&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$op&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N;
&lt;span class=&quot;synLinenum&quot;&gt;   53&lt;/span&gt;                              })
&lt;span class=&quot;synLinenum&quot;&gt;   54&lt;/span&gt;                      ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;)) \s*
&lt;span class=&quot;synLinenum&quot;&gt;   55&lt;/span&gt;                              (?{  &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   56&lt;/span&gt;                                   &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N, &lt;span class=&quot;synIdentifier&quot;&gt;$op&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   57&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   58&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;) &lt;span class=&quot;synComment&quot;&gt;# end of &amp;lt;rt&amp;gt; definition&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   59&lt;/span&gt;                              (?{
&lt;span class=&quot;synLinenum&quot;&gt;   60&lt;/span&gt;                                   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; [*/] digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rt&amp;quot;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   61&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   62&lt;/span&gt;                     |  &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   63&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   64&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   65&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   66&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;digits&amp;gt;&lt;/span&gt;  \s* \d+
&lt;span class=&quot;synLinenum&quot;&gt;   67&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   68&lt;/span&gt;       )
&lt;span class=&quot;synLinenum&quot;&gt;   69&lt;/span&gt;   }xms;
&lt;span class=&quot;synLinenum&quot;&gt;   70&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   71&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   72&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   73&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   74&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;matches: &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Stack=(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   75&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   76&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   77&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   78&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Sigue una ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./calc510withactions3.pl
5-8/4/2-1
rt -&gt; empty
term-&gt; digits(5) rt
rt -&gt; empty
rt -&gt; [*/] digits(2) rt
rt -&gt; [*/] digits(4) rt
term-&gt; digits(8) rt
rt -&gt; empty
term-&gt; digits(1) rt
re -&gt; empty
re -&gt; [+-] term re
re -&gt; [+-] term re
exp -&gt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)</code></pre>
<p>Sigue una solución alternativa que obvia la necesidad de introducir incómodas acciones intermedias. Utilizamos las variables <code>@-</code> y <code>@+</code>:</p>
<blockquote>
<p>Since Perl 5.6.1 the special variables <code>@-</code> and <code>@+</code> can functionally replace <code>$`</code>, <code>$&amp;</code> and <code>$'</code>. These arrays contain pointers to the beginning and end of each match (see for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</p>
</blockquote>
<p>Véanse los párrafos en las páginas , ) y para mas información sobre <code>@-</code> y <code>@+</code>.</p>
<p>Nótese la función <code>rc</code> en las líneas 21-28. <code>rc(1)</code> nos retorna lo que casó con el último paréntesis, <code>rc(2)</code> lo que casó con el penúltimo, etc.</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp -&gt;   exp [-+] term
 8    #         | term
 9    #  term -&gt;   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  -&gt;   term re
15    #  re   -&gt;   [+-] term re
16    #          | # empty
17    #  term -&gt;   digits rt
18    #  rt   -&gt;   [*/] rt
19    #          | # empty
20  
21    sub rc {
22      my $ofs = - shift;
23  
24      # Number of parenthesis that matched
25      my $np = @-;
26      #      string, ofsset, length
27      substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
28    }
29  
30    my $input;
31    my @stack;
32  
33    my $regexp = qr{
34        (?&amp;exp)
35  
36        (?(DEFINE)
37            (?&lt;exp&gt;    (?&amp;term) (?&amp;re)
38                         (?{ say &quot;exp -&gt; term re&quot; })
39            )
40  
41            (?&lt;re&gt;     \s* ([+-]) (?&amp;term) \s* (?{ push @stack, rc(1) }) (?&amp;re)
42                         (?{ say &quot;re -&gt; [+-] term re&quot; })
43                     | # empty
44                         (?{ say &quot;re -&gt; empty&quot; })
45            )
46  
47            (?&lt;term&gt;   ((?&amp;digits))
48                          (?{ # intermediate action
49                              push @stack, rc(1)
50                          })
51                       (?&amp;rt)
52                          (?{
53                              say &quot;term-&gt; digits(&quot;.rc(1).&quot;) rt&quot;;
54                          })
55            )
56  
57            (?&lt;rt&gt;     \s*([*/]) ((?&amp;digits)) \s*
58                               (?{  # intermediate action
59                                    push @stack, rc(1), rc(2)
60                                })
61                       (?&amp;rt) # end of &lt;rt&gt; definition
62                               (?{
63                                    say &quot;rt -&gt; [*/] digits(&quot;.rc(1).&quot;) rt&quot;
64                                })
65                      |  # empty
66                         (?{ say &quot;rt -&gt; empty&quot; })
67            )
68  
69            (?&lt;digits&gt;  \s* \d+
70            )
71        )
72    }xms;
73  
74    $input = &lt;&gt;;
75    chomp($input);
76    if ($input =~ $regexp) {
77      say &quot;matches: $&amp;\nStack=(@stack)&quot;;
78    }
79    else {
80      say &quot;does not match&quot;;
81    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Infix to postfix translator using 5.10 regexp&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Original grammar:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp -&amp;gt;   exp [-+] term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#         | term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   term [*/] digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Applying left-recursion elimination we have:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp  -&amp;gt;   term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  re   -&amp;gt;   [+-] term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   digits rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  rt   -&amp;gt;   [*/] rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt; rc &lt;/span&gt;{
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$ofs&lt;/span&gt; = - &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt;     &lt;span class=&quot;synComment&quot;&gt;# Number of parenthesis that matched&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$np&lt;/span&gt; = @-;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt;     &lt;span class=&quot;synComment&quot;&gt;# $_ contains the string being matched&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$_&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$-&lt;/span&gt;[&lt;span class=&quot;synIdentifier&quot;&gt;$ofs&lt;/span&gt;], &lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;[&lt;span class=&quot;synIdentifier&quot;&gt;$np&lt;/span&gt;+&lt;span class=&quot;synIdentifier&quot;&gt;$ofs&lt;/span&gt;] - &lt;span class=&quot;synIdentifier&quot;&gt;$-&lt;/span&gt;[&lt;span class=&quot;synIdentifier&quot;&gt;$ofs&lt;/span&gt;])
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;exp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;DEFINE&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;exp&amp;gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;term&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;re&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ say &amp;quot;exp -&amp;gt; term re&amp;quot; }&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;re&amp;gt;&lt;/span&gt;     \s* ([+-]) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;term&lt;/span&gt;) \s* (?{ &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, rc(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;) }) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;re&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; [+-] term re&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt;                    | &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   44&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   45&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   46&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   47&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;term&amp;gt;&lt;/span&gt;   ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;))
&lt;span class=&quot;synLinenum&quot;&gt;   48&lt;/span&gt;                         (?{ &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   49&lt;/span&gt;                             &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, rc(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   50&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   51&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   52&lt;/span&gt;                         (?{
&lt;span class=&quot;synLinenum&quot;&gt;   53&lt;/span&gt;                             say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;term-&amp;gt; digits(&amp;quot;&lt;/span&gt;.rc(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;) rt&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   54&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   55&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   56&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   57&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;rt&amp;gt;&lt;/span&gt;     \s*([*/]) ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;)) \s*
&lt;span class=&quot;synLinenum&quot;&gt;   58&lt;/span&gt;                              (?{  &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   59&lt;/span&gt;                                   &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, rc(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;), rc(&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   60&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   61&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;) &lt;span class=&quot;synComment&quot;&gt;# end of &amp;lt;rt&amp;gt; definition&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   62&lt;/span&gt;                              (?{
&lt;span class=&quot;synLinenum&quot;&gt;   63&lt;/span&gt;                                   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; [*/] digits(&amp;quot;&lt;/span&gt;.rc(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;) rt&amp;quot;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   64&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   65&lt;/span&gt;                     |  &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   66&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   67&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   68&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   69&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;digits&amp;gt;&lt;/span&gt;  \s* \d+
&lt;span class=&quot;synLinenum&quot;&gt;   70&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   71&lt;/span&gt;       )
&lt;span class=&quot;synLinenum&quot;&gt;   72&lt;/span&gt;   }xms;
&lt;span class=&quot;synLinenum&quot;&gt;   73&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   74&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   75&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   76&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   77&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;matches: &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Stack=(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   78&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   79&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   80&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   81&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Ahora accedemos a los atributos asociados con los dos paréntesis, en la regla de <code>&lt;rt&gt;</code> usando la función <code>rc</code>:</p>
<pre><code>         (?&lt;rt&gt;     \s*([*/]) ((?&amp;digits)) \s*
                            (?{  # intermediate action
                                 push @stack, rc(1), rc(2)
                             })</code></pre>
<p>Sigue una ejecución del programa:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./calc510withactions4.pl
5-8/4/2-1
rt -&gt; empty
term-&gt; digits(5) rt
rt -&gt; empty
rt -&gt; [*/] digits(2) rt
rt -&gt; [*/] digits(4) rt
term-&gt; digits(8) rt
rt -&gt; empty
term-&gt; digits(1) rt
re -&gt; empty
re -&gt; [+-] term re
re -&gt; [+-] term re
exp -&gt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
pl@nereida:~/Lperltesting$</code></pre>
<p>Una nueva solución: dar nombre a los paréntesis y acceder a los mismos:</p>
<pre><code>47          (?&lt;rt&gt;     \s*(?&lt;op&gt;[*/]) (?&lt;num&gt;(?&amp;digits)) \s*
48                             (?{  # intermediate action
49                                  push @stack, $+{num}, $+{op}
50                              })</code></pre>
<p>Sigue el código completo:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp -&gt;   exp [-+] term
 8    #         | term
 9    #  term -&gt;   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  -&gt;   term re
15    #  re   -&gt;   [+-] term re
16    #          | # empty
17    #  term -&gt;   digits rt
18    #  rt   -&gt;   [*/] rt
19    #          | # empty
20  
21    my @stack;
22  
23    my $regexp = qr{
24        (?&amp;exp)
25  
26        (?(DEFINE)
27            (?&lt;exp&gt;    (?&amp;term) (?&amp;re)
28                         (?{ say &quot;exp -&gt; term re&quot; })
29            )
30  
31            (?&lt;re&gt;     \s* ([+-]) (?&amp;term) \s* (?{ push @stack, $^N }) (?&amp;re)
32                         (?{ say &quot;re -&gt; [+-] term re&quot; })
33                     | # empty
34                         (?{ say &quot;re -&gt; empty&quot; })
35            )
36  
37            (?&lt;term&gt;   ((?&amp;digits))
38                          (?{ # intermediate action
39                              push @stack, $^N
40                          })
41                       (?&amp;rt)
42                          (?{
43                              say &quot;term-&gt; digits($^N) rt&quot;;
44                          })
45            )
46  
47            (?&lt;rt&gt;     \s*(?&lt;op&gt;[*/]) (?&lt;num&gt;(?&amp;digits)) \s*
48                               (?{  # intermediate action
49                                    push @stack, $+{num}, $+{op}
50                                })
51                       (?&amp;rt) # end of &lt;rt&gt; definition
52                               (?{
53                                    say &quot;rt -&gt; [*/] digits($^N) rt&quot;
54                                })
55                      |  # empty
56                         (?{ say &quot;rt -&gt; empty&quot; })
57            )
58  
59            (?&lt;digits&gt;  \s* \d+
60            )
61        )
62    }xms;
63  
64    my $input = &lt;&gt;;
65    chomp($input);
66    if ($input =~ $regexp) {
67      say &quot;matches: $&amp;\nStack=(@stack)&quot;;
68    }
69    else {
70      say &quot;does not match&quot;;
71    }</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;v5.&lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Infix to postfix translator using 5.10 regexp&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Original grammar:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp -&amp;gt;   exp [-+] term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#         | term&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   term [*/] digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | digits&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;# Applying left-recursion elimination we have:&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  exp  -&amp;gt;   term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  re   -&amp;gt;   [+-] term re&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  term -&amp;gt;   digits rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#  rt   -&amp;gt;   [*/] rt&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#          | # empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;exp&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;DEFINE&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;          &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;exp&amp;gt;    &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;term&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;amp;re&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                       &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ say &amp;quot;exp -&amp;gt; term re&amp;quot; }&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;re&amp;gt;&lt;/span&gt;     \s* ([+-]) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;term&lt;/span&gt;) \s* (?{ &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N }) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;re&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; [+-] term re&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt;                    | &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;re -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;term&amp;gt;&lt;/span&gt;   ((?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;))
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt;                         (?{ &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt;                             &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;N
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;)
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt;                         (?{
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt;                             say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;term-&amp;gt; digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rt&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   44&lt;/span&gt;                         })
&lt;span class=&quot;synLinenum&quot;&gt;   45&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   46&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   47&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;rt&amp;gt;&lt;/span&gt;     \s*(?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;op&amp;gt;&lt;/span&gt;[*/]) (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;num&amp;gt;&lt;/span&gt;(?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;digits&lt;/span&gt;)) \s*
&lt;span class=&quot;synLinenum&quot;&gt;   48&lt;/span&gt;                              (?{  &lt;span class=&quot;synComment&quot;&gt;# intermediate action&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   49&lt;/span&gt;                                   &lt;span class=&quot;synStatement&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;, &lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{num}, &lt;span class=&quot;synIdentifier&quot;&gt;$+&lt;/span&gt;{op}
&lt;span class=&quot;synLinenum&quot;&gt;   50&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   51&lt;/span&gt;                      (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;rt&lt;/span&gt;) &lt;span class=&quot;synComment&quot;&gt;# end of &amp;lt;rt&amp;gt; definition&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   52&lt;/span&gt;                              (?{
&lt;span class=&quot;synLinenum&quot;&gt;   53&lt;/span&gt;                                   say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; [*/] digits(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$^&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;N) rt&amp;quot;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   54&lt;/span&gt;                               })
&lt;span class=&quot;synLinenum&quot;&gt;   55&lt;/span&gt;                     |  &lt;span class=&quot;synComment&quot;&gt;# empty&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   56&lt;/span&gt;                        (?{ say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;rt -&amp;gt; empty&amp;quot;&lt;/span&gt; })
&lt;span class=&quot;synLinenum&quot;&gt;   57&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   58&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   59&lt;/span&gt;           (?&lt;span class=&quot;synIdentifier&quot;&gt;&amp;lt;digits&amp;gt;&lt;/span&gt;  \s* \d+
&lt;span class=&quot;synLinenum&quot;&gt;   60&lt;/span&gt;           )
&lt;span class=&quot;synLinenum&quot;&gt;   61&lt;/span&gt;       )
&lt;span class=&quot;synLinenum&quot;&gt;   62&lt;/span&gt;   }xms;
&lt;span class=&quot;synLinenum&quot;&gt;   63&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   64&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   65&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   66&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synIdentifier&quot;&gt;$regexp&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   67&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;matches: &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$&amp;amp;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;Stack=(&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;@stack&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;)&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   68&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   69&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   70&lt;/span&gt;     say &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   71&lt;/span&gt;   }
&lt;/pre&gt;</code></pre>
<p>Ejecución:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./calc510withnamedpar.pl
5-8/4/2-1
rt -&gt; empty
term-&gt; digits(5) rt
rt -&gt; empty
rt -&gt; [*/] digits(2) rt
rt -&gt; [*/] digits(4) rt
term-&gt; digits(8) rt
rt -&gt; empty
term-&gt; digits(1) rt
re -&gt; empty
re -&gt; [+-] term re
re -&gt; [+-] term re
exp -&gt; term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)</code></pre>
<ul>
<li><p>El nodo <span><em>Backreference variables in code embedded inside Perl 5.10 regexps</em></span> en</p></li>
<li><p>El nodo <span><em>Strange behavior of @- and @+ in perl5.10 regexps</em></span> en</p></li>
</ul>
<h3 id="construyendo-el-ast-con-expresiones-regulares-5.10">Construyendo el AST con Expresiones Regulares 5.10</h3>
<p>Construiremos en esta sección un traductor de infijo a postfijo utilizando una aproximación general: construiremos una representación del Abstract Syntax Tree o AST (véase la sección [section:aat] Árbol de Análisis Abstracto para una definición detallada de que es un árbol sintáctico).</p>
<p>Como la aplicación es un poco mas compleja la hemos dividido en varios ficheros. Esta es la estructura:</p>
<pre><code>.
|-- ASTandtrans3.pl    # programa principal
|-- BinaryOp.pm        # clases para el manejo de los nodos del AST
|-- testreegxpparen.pl # prueba para Regexp::Paren
`-- Regexp
    `-- Paren.pm       # módulo de extensión de $^N</code></pre>
<p>La salida del programa puede ser dividida en tres partes. La primera muestra una antiderivación a derechas inversa:</p>
<pre><code>pl@nereida:~/Lperltesting$ ./ASTandtrans3.pl
2*(3-4)
factor -&gt; NUM(2)
factor -&gt; NUM(3)
rt -&gt; empty
term-&gt; factor rt
factor -&gt; NUM(4)
rt -&gt; empty
term-&gt; factor rt
re -&gt; empty
re -&gt; [+-] term re
exp -&gt; term re
factor -&gt; ( exp )
rt -&gt; empty
rt -&gt; [*/] factor rt
term-&gt; factor rt
re -&gt; empty
exp -&gt; term re
matches: 2*(3-4)</code></pre>
<p>Que leída de abajo a arriba nos da una derivación a derechas de la cadena <code>2*(3-4)</code>:</p>
<pre><code>exp =&gt; term re =&gt; term =&gt; factor rt =&gt; 
factor [*/](*) factor rt =&gt; factor [*/](*) factor =&gt; 
factor [*/](*) ( exp ) =&gt; factor [*/](*) ( term re ) =&gt;  
factor [*/](*) ( term [+-](-) term re ) =&gt;  
factor [*/](*) ( term [+-](-) term ) =&gt; 
factor [*/](*) ( term [+-](-) factor rt ) =&gt;
factor [*/](*) ( term [+-](-) factor ) =&gt; 
factor [*/](*) ( term [+-](-) NUM(4) ) =&gt;
factor [*/](*) ( factor rt [+-](-) NUM(4) ) =&gt; 
factor [*/](*) ( factor [+-](-) NUM(4) ) =&gt;
factor [*/](*) ( NUM(3) [+-](-) NUM(4) )  =&gt; 
NUM(2) [*/](*) ( NUM(3) [+-](-) NUM(4) )</code></pre>
<p>La segunda parte nos muestra la representación del AST para la entrada dada (<code>2*(3-4)</code>):</p>
<p><span>|p<span>5cm</span>|p<span>4cm</span>|</span></p>
<pre><code>AST:
$VAR1 = bless( {
  &#39;left&#39; =&gt; bless( { &#39;val&#39; =&gt; &#39;2&#39; }, &#39;NUM&#39; ),
  &#39;right&#39; =&gt; bless( {
    &#39;left&#39; =&gt; bless( { &#39;val&#39; =&gt; &#39;3&#39; }, &#39;NUM&#39; ),
    &#39;right&#39; =&gt; bless( { &#39;val&#39; =&gt; &#39;4&#39; }, &#39;NUM&#39; ),
    &#39;op&#39; =&gt; &#39;-&#39;
  }, &#39;ADD&#39; ),
  &#39;op&#39; =&gt; &#39;*&#39;
}, &#39;MULT&#39; );</code></pre>
<p>&amp;</p>
<pre><code>&lt;img src=&quot;ast234.png&quot; alt=&quot;MUL(2,ADD(3,4))&quot; height=200&gt;</code></pre>
<p>La última parte de la salida nos muestra la traducción a postfijo de la expresión en infijo suministrada en la entrada (<code>2*(3-4)</code>):</p>
<pre><code>2 3 4 - *</code></pre>
<p>La gramática original que consideramos es recursiva a izquierdas:</p>
<pre><code> exp    -&gt;   exp [-+] term
           | term
 term   -&gt;   term [*/] factor
           | factor
 factor -&gt;  \( exp \)
           | \d+</code></pre>
<p>aplicando las técnicas explicadas en [subsection:eliminarecesquem] es posible transformar la gramática en una no recursiva por la izquierda:</p>
<pre><code> exp       -&gt;   term restoexp
 restoexp  -&gt;   [-+] term restoexp
              | # vacío
 term      -&gt;   term restoterm
 restoterm -&gt;   [*/] factor restoterm
              | # vacío
 factor    -&gt;   \( exp \)
              | \d+</code></pre>
<p>Ahora bien, no basta con transformar la gramática en una equivalente. Lo que tenemos como punto de partida no es una gramática sino un (véase la sección [section:esquemas]) que construye el AST asociado con la expresión. Nuestro esquema de traducción conceptual es algo así:</p>
<pre><code> exp    -&gt;   exp ([-+]) term       { ADD-&gt;new(left =&gt; $exp, right =&gt; $term, op =&gt; $1) }
           | term                  { $term }
 term   -&gt;   term ([*/]) factor    { MULT-&gt;new(left =&gt; $exp, right =&gt; $term, op =&gt; $1) } 
           | factor                { $factor }
 factor -&gt;  \( exp \)              { $exp }
           | (\d+)                 { NUM-&gt;new(val =&gt; $1) }</code></pre>
<p>Lo que queremos conseguir un conjunto de acciones semánticas asociadas para gramática no recursiva que sea equivalente a este.</p>
<p>Este es el programa resultante una vez aplicadas las transformaciones. La implementación de la asociación entre símbolos y atributos la realizamos manualmente mediante una pila de atributos:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n ./ASTandtrans3.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3  use strict;
 4  use Regexp::Paren qw{g};
 5  use BinaryOp;
 6
 7  use Data::Dumper;
 8  $Data::Dumper::Indent = 1;
 9
10  # Builds AST
11  my @stack;
12  my $regexp = qr{
13      (?&amp;exp)
14
15      (?(DEFINE)
16          (?&lt;exp&gt;    (?&amp;term) (?&amp;re)
17                       (?{ say &quot;exp -&gt; term re&quot; })
18          )
19
20          (?&lt;re&gt;     \s* ([+-]) (?&amp;term)
21                        (?{  # intermediate action
22                            local our ($ch1, $term) = splice @stack, -2;
23
24                            push @stack, ADD-&gt;new( {left =&gt; $ch1, right =&gt; $term, op =&gt; g(1)});
25                        })
26                     (?&amp;re)
27                       (?{ say &quot;re -&gt; [+-] term re&quot; })
28                   | # empty
29                       (?{ say &quot;re -&gt; empty&quot; })
30          )
31
32          (?&lt;term&gt;   ((?&amp;factor)) (?&amp;rt)
33                        (?{
34                            say &quot;term-&gt; factor rt&quot;;
35                        })
36          )
37
38          (?&lt;rt&gt;     \s*([*/]) (?&amp;factor)
39                         (?{  # intermediate action
40                              local our ($ch1, $ch2) = splice @stack, -2;
41
42                              push @stack, MULT-&gt;new({left =&gt; $ch1, right =&gt; $ch2, op =&gt; g(1)});
43                          })
44                     (?&amp;rt) # end of &lt;rt&gt; definition
45                         (?{
46                              say &quot;rt -&gt; [*/] factor rt&quot;
47                          })
48                   | # empty
49                         (?{ say &quot;rt -&gt; empty&quot; })
50          )
51
52          (?&lt;factor&gt; \s* (\d+)
53                          (?{
54                             say &quot;factor -&gt; NUM($^N)&quot;;
55                             push @stack, bless { &#39;val&#39; =&gt; g(1) }, &#39;NUM&#39;;
56                          })
57                     | \s* \( (?&amp;exp) \s* \)
58                          (?{ say &quot;factor -&gt; ( exp )&quot; })
59          )
60      )
61  }xms;
62
63  my $input = &lt;&gt;;
64  chomp($input);
65  if ($input =~ $regexp) {
66    say &quot;matches: $&amp;&quot;;
67    my $ast = pop @stack;
68    say &quot;AST:\n&quot;, Dumper $ast;
69
70    say $ast-&gt;translate;
71  }
72  else {
73    say &quot;does not match&quot;;
74  }</code></pre>
<p>Cada nodo del AST es un objeto. La clase del nodo nos dice que tipo de nodo es. Así los nodos de la clase <code>MULT</code> agrupan a los nódos de multiplicación y división. Los nodos de la clase <code>ADD</code> agrupan a los nódos de suma y resta. El procedimiento general es asociar un método <code>translate</code> con cada clase de nodo. De esta forma se logra el polimorfismo necesario: cada clase de nodo sabe como traducirse y el método <code>translate</code> de cada clase puede escribirse como</p>
<ul>
<li><p>Obtener los resultados de llamar a <code>$child-&gt;translate</code> para cada uno de los nodos hijos <code>$child</code>. Por ejemplo, si el nodo fuera un nodo <code>IF_ELSE</code> de un hipotético lenguaje de programación, se llamaría a los métodos <code>translate</code> sobre sus tres hijos <code>boolexpr</code>, <code>ifstatement</code> y <code>elsestatement</code>.</p></li>
<li><p>Combinar los resultados para producir la traducción adecuada del nodo actual.</p></li>
</ul>
<p>Es esta combinación la que mas puede cambiar según el tipo de nodo. Así, en el caso de el nodo <code>IF_ELSE</code> el seudocódigo para la traducción sería algo parecido a esto:</p>
<pre><code>my $self = shift;
my $etiqueta1 = generar_nueva_etiqueta;
my $etiqueta2 = generar_nueva_etiqueta;

my $boolexpr      = $self-&gt;boolexpr-&gt;translate;
my $ifstatement   = $self-&gt;ifstatement-&gt;translate,  
my $elsestatement = $self-&gt;elsestatement-&gt;translate, 
return &lt;&lt; &quot;ENDTRANS&quot;;
    $boolexpr
    JUMPZERO $etiqueta1:
    $ifstatement
    JUMP     $etiqueta2:
  $etiqueta1:
    $elsestatement
  $etiqueta2:
ENDTRANS</code></pre>
<p>Siguiendo estas observaciones el código de <code>BinaryOp.pm</code> queda así:</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n BinaryOp.pm
 1  package BinaryOp;
 2  use strict;
 3  use base qw(Class::Accessor);
 4
 5  BinaryOp-&gt;mk_accessors(qw{left right op});
 6
 7  sub translate {
 8    my $self = shift;
 9
10    return $self-&gt;left-&gt;translate.&quot; &quot;.$self-&gt;right-&gt;translate.&quot; &quot;.$self-&gt;op;
11  }
12
13  package ADD;
14  use base qw{BinaryOp};
15
16  package MULT;
17  use base qw{BinaryOp};
18
19  package NUM;
20
21  sub translate {
22    my $self = shift;
23
24    return $self-&gt;{val};
25  }
26
27  1;</code></pre>
<p>Véase también:</p>
<ul>
<li></li>
</ul>
<p>En esta solución utilizamos las variables <code>@-</code> y <code>@+</code> para construir una función que nos permite acceder a lo que casó con los últimos paréntesis con memoria:</p>
<blockquote>
<p>Since Perl 5.6.1 the special variables <code>@-</code> and <code>@+</code> can functionally replace <code>$`</code>, <code>$&amp;</code> and <code>$'</code>. These arrays contain pointers to the beginning and end of each match (see for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</p>
</blockquote>
<p>Véanse los párrafos en las páginas , ) y para mas información sobre <code>@-</code> y <code>@+</code>.</p>
<p><code>g(1)</code> nos retorna lo que casó con el último paréntesis, <code>g(2)</code> lo que casó con el penúltimo, etc.</p>
<pre><code>pl@nereida:~/Lperltesting$ cat -n Regexp/Paren.pm
 1  package Regexp::Paren;
 2  use strict;
 3
 4  use base qw{Exporter};
 5
 6  our @EXPORT_OK = qw{g};
 7
 8  sub g {
 9    die &quot;Error in &#39;Regexp::Paren::g&#39;. Not used inside (?{ code }) construct\n&quot; unless defined($_);
10    my $ofs = - shift;
11
12    # Number of parenthesis that matched
13    my $np = @-;
14    die &quot;Error. Illegal &#39;Regexp::Paren::g&#39; ref inside (?{ code }) construct\n&quot; unless ($np &gt; - $ofs &amp;&amp; $ofs &lt; 0);
15    # $_ contains the string being matched
16    substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
17  }
18
19  1;
20
21  =head1 NAME
22
23  Regexp::Paren - Extends $^N inside (?{ ... }) constructs
24
25  =head1 SYNOPSIS
26
27    use Regexp::Paren qw{g};
28
29    &#39;abcde&#39; =~ qr{(.)(.)(.)
30                         (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot;\n&quot; })                   # c b a
31                 (.)     (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot;\n&quot; })          # d c b a
32                 (.)     (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot; &quot;.g(5).&quot;\n&quot; }) # e d c b a
33                }x;
34
35    print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot; &quot;.g(5).&quot;\n&quot;; # error!
36
37  =head1 DESCRIPTION
38
39  Inside a C&lt;(?{ ... })&gt; construct, C&lt;g(1)&gt; refers to what matched the last parenthesis
40  (like C&lt;$^N&gt;), C&lt;g(2)&gt; refers to the string that matched with the parenthesis before
41  the last, C&lt;g(3)&gt; refers to the string that matched with the parenthesis at distance 3,
42  etc.
43
44  =head1 SEE ALSO
45
46  =over 2
47
48  =item * L&lt;perlre&gt;
49
50  =item * L&lt;perlretut&gt;
51
52  =item * PerlMonks node I&lt;Strange behavior o&gt; C&lt;@-&gt; I&lt;and&gt; C&lt;@+&gt; I&lt;in perl5.10 regexps&gt; L&lt;http://www.perlmonks.org/?node_id=794736&gt;
53
54  =item * PerlMonks node I&lt;Backreference variables in code embedded inside Perl 5.10 regexps&gt; L&lt;http://www.perlmonks.org/?node_id=794424&gt;
55
56  =back
57
58  =head1 AUTHOR
59
60  Casiano Rodriguez-Leon (casiano@ull.es)
61
62  =head1 ACKNOWLEDGMENTS
63
64  This work has been supported by CEE (FEDER) and the Spanish Ministry of
65  I&lt;Educacion y Ciencia&gt; through I&lt;Plan Nacional I+D+I&gt; number TIN2005-08818-C04-04
66  (ULL::OPLINK project L&lt;http://www.oplink.ull.es/&gt;).
67  Support from Gobierno de Canarias was through GC02210601
68  (I&lt;Grupos Consolidados&gt;).
69  The University of La Laguna has also supported my work in many ways
70  and for many years.
71
72  =head1 LICENCE AND COPYRIGHT
73
74  Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
75
76  These modules are free software; you can redistribute it and/or
77  modify it under the same terms as Perl itself. See L&lt;perlartistic&gt;.
78
79  This program is distributed in the hope that it will be useful,
80  but WITHOUT ANY WARRANTY; without even the implied warranty of
81  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre>
<p>Al ejecutar <code>perldoc Regexp::Paren</code> podemos ver la documentación incluida (véase la documentación en y así como la sección para mas detalles):</p>
<p><span>|p<span>22cm</span>|</span></p>
<pre><code>NAME
    Regexp::Paren - Extends $^N inside (?{ ... }) constructs

SYNOPSIS
      use Regexp::Paren qw{g};

      &#39;abcde&#39; =~ qr{(.)(.)(.)
                           (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot;\n&quot; })                   # c b a
                   (.)     (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot;\n&quot; })          # d c b a
                   (.)     (?{ print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot; &quot;.g(5).&quot;\n&quot; }) # e d c b a
                  }x;

      print g(1).&quot; &quot;.g(2).&quot; &quot;.g(3).&quot; &quot;.g(4).&quot; &quot;.g(5).&quot;\n&quot;; # error!

DESCRIPTION
    Inside a &quot;(?{ ... })&quot; construct, g(1) refers to what matched the last
    parenthesis (like $^N), g(2) refers to the string that matched with the
    parenthesis before the last, g(3) refers to the string that matched with
    the parenthesis at distance 3, etc.

SEE ALSO
    * perlre
    * perlretut
    * PerlMonks node *Strange behavior o* &quot;@-&quot; *and* &quot;@+&quot; *in perl5.10
      regexps* &lt;http://www.perlmonks.org/?node_id=794736&gt;
    * PerlMonks node *Backreference variables in code embedded inside Perl
      5.10 regexps* &lt;http://www.perlmonks.org/?node_id=794424&gt;

AUTHOR
    Casiano Rodriguez-Leon (casiano@ull.es)

ACKNOWLEDGMENTS
    This work has been supported by CEE (FEDER) and the Spanish Ministry of
    *Educacion y Ciencia* through *Plan Nacional I+D+I* number
    TIN2005-08818-C04-04 (ULL::OPLINK project &lt;http://www.oplink.ull.es/&gt;).
    Support from Gobierno de Canarias was through GC02210601 (*Grupos
    Consolidados*). The University of La Laguna has also supported my work
    in many ways and for many years.

LICENCE AND COPYRIGHT
    Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights</code></pre>
<p><br /></p>
<p>Esta práctica es continuación de la práctica <span><em>un lenguaje para componer invitaciones</em></span> especificada en la sección [practica:invitaciones].</p>
<p>El objetivo es traducir la entrada escrita en el lenguaje de invitaciones a HTML. La traducción del ejemplo anterior debería ser parecida a esta:</p>
<p><span>|p<span>12cm</span>|p<span>12cm</span>|</span></p>
<pre><code>pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  &lt;?xml version=&quot;1.0&quot;?&gt;
 2  &lt;!DOCTYPE invitation SYSTEM &quot;invitation.dtd&quot;&gt;
 3  &lt;invitation&gt;
 4  &lt;!-- ++++ The header part of the document ++++ --&gt;
 5  &lt;front&gt;
 6  &lt;to&gt;Anna, Bernard, Didier, Johanna&lt;/to&gt;
 7  &lt;date&gt;Next Friday Evening at 8 pm&lt;/date&gt;
 8  &lt;where&gt;The Web Cafe&lt;/where&gt;
 9  &lt;why&gt;My first XML baby&lt;/why&gt;
10  &lt;/front&gt;
11  &lt;!-- +++++ The main part of the document +++++ --&gt;
12  &lt;body&gt;
13  &lt;par&gt;
14  I would like to invite you all to celebrate
15  the birth of &lt;emph&gt;Invitation&lt;/emph&gt;, my
16  first XML document child.
17  &lt;/par&gt;
18  &lt;par&gt;
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  &lt;/par&gt;
22  &lt;par&gt;
23  I &lt;emph&gt;really&lt;/emph&gt; look forward to see you soon!
24  &lt;/par&gt;
25  &lt;/body&gt;
26  &lt;!-- +++ The closing part of the document ++++ --&gt;
27  &lt;back&gt;
28  &lt;signature&gt;Michel&lt;/signature&gt;
29  &lt;/back&gt;
30  &lt;/invitation&gt;</code></pre>
<p>&amp;</p>
<pre><code>pl@nereida:~/Lpl0910/Practicas/161009/src$ cat invcss.html.save
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Invitation (sgmlpl/CSS formatting) &lt;/TITLE&gt;
&lt;LINK href=&quot;invit.css&quot; rel=&quot;style-sheet&quot; type=&quot;text/css&quot;&gt;
&lt;!-- 24 August 1998 mg --&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;INVITATION&lt;/H1&gt;
&lt;P&gt;&lt;TABLE&gt;
&lt;TBODY&gt;
&lt;TR&gt;&lt;TD class=&quot;front&quot;&gt;To: &lt;/TD&gt;
&lt;TD&gt;Anna, Bernard, Didier, Johanna&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;&lt;TD class=&quot;front&quot;&gt;When: &lt;/TD&gt;
&lt;TD&gt;Next Friday Evening at 8 pm&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;&lt;TD class=&quot;front&quot;&gt;Venue: &lt;/TD&gt;
&lt;TD&gt;The Web Cafe&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;&lt;TD class=&quot;front&quot;&gt;Occasion: &lt;/TD&gt;
&lt;TD&gt;My first XML baby&lt;/TD&gt;&lt;/TR&gt;
&lt;/TBODY&gt;
&lt;/TABLE&gt;
&lt;P&gt;
I would like to invite you all to celebrate
the birth of &lt;EM&gt;Invitation&lt;/EM&gt;, my
first XML document child.
&lt;/P&gt;
&lt;P&gt;
Please do your best to come and join me next Friday
evening. And, do not forget to bring your friends.
&lt;/P&gt;
&lt;P&gt;
I &lt;EM&gt;really&lt;/EM&gt; look forward to see you soon!
&lt;/P&gt;
&lt;P CLASS=&quot;signature&quot;&gt;Michel&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<p><br /></p>
<p>Para ver el resultado en su navegador visite el fichero</p>
<p>Su programa deberá producir un Abstract Syntax Tree. Los nodos serán objetos. Cada clase (<code>FRONT</code>, <code>TO</code>, etc.) deberá de disponer de un método <code>translate</code>.</p>
<p>Para simplificar el proceso de traducción a <code>HTML</code> se sugiere utilizar una hoja de estilo parecida a la siguiente (tomada de la seción 7.4.4 del citado libro de Goosens):</p>
<pre><code>pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invit.css
 1  /* CSS stylesheet for invitation1 in HTML */
 2  BODY {margin-top: 1em;     /* global page parameters */
 3        margin-bottom: 1em;
 4        margin-left: 1em;
 5        margin-right: 1em;
 6        font-family: serif;
 7        line-height: 1.1;
 8        color: black;
 9  }
10  H1   {text-align: center;  /* for global title   */
11        font-size: x-large;
12  }
13  P    {text-align: justify; /* paragraphs in body */
14        margin-top: 1em;
15  }
16  TABLE { border-width: 0pt }
17  TBODY { border-width: 0pt }
18  TD[class=&quot;front&quot;] {        /* table data in front matter */
19        text-align: left;
20        font-weight: bold;
21  }
22  TD.front {        /* table data in front matter */
23        text-align: left;
24        font-weight: bold;
25  }
26  EM   {font-style: italic;  /* emphasis in body   */
27  }
28  P.signature {     /* signature          */
29        text-align: right;
30        font-weight: bold;
31  }</code></pre>
<p>Véase también:</p>
<ul>
<li></li>
<li><p>(véanse los subdirectorios correspondietnes a los capítulos 6 y 7)</p></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="análisis-sintáctico-con-regexpgrammars">Análisis Sintáctico con <span>Regexp::Grammars</span></h2>
<p>El módulo escrito por extiende las expresiones regulares Perl con la capacidad de generar representaciones del árbol de análisis sintáctico abstracto y obviando la necesidad de explicitar los blancos. El módulo necesita para funcionar una versión de Perl superior o igual a la 5.10.</p>
<h3 id="introducción-1">Introducción</h3>
<p>La documentación de establece cual es el problema que aborda el módulo:</p>
<blockquote>
<p>…Perl5.10 makes possible to use regexes to recognize complex, hierarchical–and even recursive–textual structures. The problem is that Perl 5.10 doesn’t provide any support for extracting that hierarchical data into nested data structures. In other words, using Perl 5.10 you can match complex data, but not parse it into an internally useful form.</p>
<p>An additional problem when using Perl 5.10 regexes to match complex data formats is that you have to make sure you remember to insert whitespace- matching constructs (such as <code>\s*</code>) at every possible position where the data might contain ignorable whitespace. This reduces the readability of such patterns, and increases the chance of errors (typically caused by overlooking a location where whitespace might appear).</p>
<p>The module solves both those problems.</p>
<p>If you import the module into a particular lexical scope, it preprocesses any regex in that scope, so as to implement a number of extensions to the standard Perl 5.10 regex syntax. These extensions simplify the task of defining and calling subrules within a grammar, and allow those subrule calls to capture and retain the components of they match in a proper hierarchical manner.</p>
</blockquote>
<p>Las expresiones regulares aumentan las regexp Perl 5.10. La sintáxis se expande y se modifica:</p>
<blockquote>
<p>A specification consists of a pattern (which may include both standard Perl 5.10 regex syntax, as well as special directives), followed by one or more rule or token definitions.</p>
</blockquote>
<p>Sigue un ejemplo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (&lt;pp&gt;)
    10
    11        &lt;rule: pp&gt;   \( (?: [^()]*+ | &lt;escape&gt; | &lt;pp&gt; )* \)
    12
    13        &lt;token: escape&gt; \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = &lt;&gt;) {
    19      while ($input =~ m{$rbb}g) {
    20          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    21          say Dumper \%/;
    22      }
    23  }</code></pre>
<blockquote>
<p>Note that there is no need to explicitly place <code>\s*</code> subpatterns throughout the rules; that is taken care of automatically.</p>
<p>…</p>
<p>The initial pattern (<code>(&lt;pp&gt;)</code>) acts like the <em>top</em> rule of the grammar, and must be matched completely for the grammar to match.</p>
<p>The rules and tokens are declarations only and they are not directly matched. Instead, they act like subroutines, and are invoked by name from the initial pattern (or from within a rule or token).</p>
<p>Each rule or token extends from the directive that introduces it up to either the next rule or token directive, or (in the case of the final rule or token) to the end of the grammar.</p>
</blockquote>
<p>Al ejecutar el programa anterior con entrada <code>(2*(3+5))*4+(2-3)</code> produce:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: &lt;(2*(3+5))&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;(2*(3+5))&#39;,
          &#39;pp&#39; =&gt; {
                    &#39;&#39; =&gt; &#39;(2*(3+5))&#39;,
                    &#39;pp&#39; =&gt; &#39;(3+5)&#39;
                  }
        };

matches: &lt;(2-3)&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;(2-3)&#39;,
          &#39;pp&#39; =&gt; &#39;(2-3)&#39;
        };</code></pre>
<blockquote>
<p>Each rule calls the subrules specified within it, and then return a hash containing whatever result each of those subrules returned, with each result indexed by the subrule’s name.</p>
<p>In this way, each level of the hierarchical regex can generate hashes recording everything its own subrules matched, so when the entire pattern matches, it produces a tree of nested hashes that represent the structured data the pattern matched.</p>
<p>…</p>
<p>In addition each result-hash has one extra key: the empty string. The value for this key is whatever string the entire subrule call matched.</p>
</blockquote>
<blockquote>
<p>The difference between a token and a rule is that a token treats any whitespace within it exactly as a normal Perl regular expression would. That is, a sequence of whitespace in a token is ignored if the <code>/x</code> modifier is in effect, or else matches the same literal sequence of whitespace characters (if <code>/x</code> is not in effect).</p>
</blockquote>
<p>En el ejemplo anterior el comportamiento es el mismo si se reescribe la regla para el token <code>escape</code> como:</p>
<pre><code>    13        &lt;rule: escape&gt; \\.</code></pre>
<p>En este otro ejemplo mostramos que la diferencia entre token y rule es significativa:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        &lt;s&gt;
    10
    11        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
    12
    13        &lt;rule: c&gt;  c d
    14
    15        &lt;token: a&gt;  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = &lt;&gt;) {
    21      if ($input =~ m{$rbb}) {
    22          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    23          say Dumper \%/;
    24      }
    25      else {
    26          say &quot;Does not match&quot;;
    27      }
    28  }</code></pre>
<p>Al ejecutar este programa vemos la diferencia en la interpretación de los blancos:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: &lt;ab c d&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;ab c d&#39;,
          &#39;s&#39; =&gt; {
                   &#39;&#39; =&gt; &#39;ab c d&#39;,
                   &#39;c&#39; =&gt; &#39;c d&#39;,
                   &#39;a&#39; =&gt; &#39;ab&#39;
                 }
        };

a b c d
Does not match
ab cd
matches: &lt;ab cd&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;ab cd&#39;,
          &#39;s&#39; =&gt; {
                   &#39;&#39; =&gt; &#39;ab cd&#39;,
                   &#39;c&#39; =&gt; &#39;cd&#39;,
                   &#39;a&#39; =&gt; &#39;ab&#39;
                 }
        };</code></pre>
<p>Obsérvese como la entrada <code>a b c d</code> es rechazada mientras que la entrada <code>ab c d</code> es aceptada.</p>
<blockquote>
<p>In a rule, any sequence of whitespace (except those at the very start and the very end of the rule) is treated as matching the implicit subrule <code>&lt;.ws&gt;</code>, which is automatically predefined to match optional whitespace (i.e. <code>\s*</code>).</p>
<p>You can explicitly define a <code>&lt;ws&gt;</code> token to change that default behaviour. For example, you could alter the definition of whitespace to include Perlish comments, by adding an explicit <code>&lt;token: ws&gt;</code>:</p>
<pre><code>                      &lt;token: ws&gt;
                         (?: \s+ | #[^\n]* )*</code></pre>
<p>But be careful not to define <code>&lt;ws&gt;</code> as a rule, as this will lead to all kinds of infinitely recursive unpleasantness.</p>
</blockquote>
<p>El siguiente ejemplo ilustra como redefinir <code>&lt;ws&gt;</code>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings &#39;uninitialized&#39;;
 9      qr{
10        &lt;s&gt;
11
12        &lt;token: ws&gt; (?: \s+ | /\* .*? \*/)*+
13
14        &lt;rule: s&gt; &lt;a&gt; &lt;c&gt;
15
16        &lt;rule: c&gt;  c d
17
18        &lt;token: a&gt;  a b
19
20      }xs;
21  };
22
23  while (my $input = &lt;&gt;) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say &quot;Does not match&quot;;
29      }
30  }</code></pre>
<p>Ahora podemos introducir comentarios en la entrada:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          &#39;&#39; =&gt; &#39;ab /* 1 */ c d&#39;,
          &#39;s&#39; =&gt; {
                   &#39;&#39; =&gt; &#39;ab /* 1 */ c d&#39;,
                   &#39;c&#39; =&gt; &#39;c d&#39;,
                   &#39;a&#39; =&gt; &#39;ab&#39;
                 }
        };</code></pre>
<blockquote>
<p>To invoke a rule to match at any point, just enclose the rule’s name in angle brackets (like in ). There must be no space between the opening bracket and the rulename. For example:</p>
<pre><code>           qr{
               file:             # Match literal sequence &#39;f&#39; &#39;i&#39; &#39;l&#39; &#39;e&#39; &#39;:&#39;
               &lt;name&gt;            # Call &lt;rule: name&gt;
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it&#39;s okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;</code></pre>
<p>If you need to match a literal pattern that would otherwise look like a subrule call, just backslash-escape the leading angle:</p>
<pre><code>           qr{
               file:             # Match literal sequence &#39;f&#39; &#39;i&#39; &#39;l&#39; &#39;e&#39; &#39;:&#39;
               \&lt;name&gt;           # Match literal sequence &#39;&lt;&#39; &#39;n&#39; &#39;a&#39; &#39;m&#39; &#39;e&#39; &#39;&gt;&#39;
               &lt;options&gt;?        # Call &lt;rule: options&gt; (it&#39;s okay if it fails)

               &lt;rule: name&gt;
                   # etc.
           }x;</code></pre>
</blockquote>
<p>El siguiente programa ilustra algunos puntos discutidos en la cita anterior:</p>
<pre><code>casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (&lt;pp&gt;)
10
11        &lt;rule: pp&gt;   \( (?: &lt;b  &gt; | \&lt; | &lt; escape&gt; | &lt;pp&gt; )* \)
12
13        &lt;token: b  &gt; b
14
15        &lt;token: escape&gt; \\.
16
17      }xs;
18  };
19
20  while (my $input = &lt;&gt;) {
21      while ($input =~ m{$rbb}g) {
22          say(&quot;matches: &lt;$&amp;&gt;&quot;);
23          say Dumper \%/;
24      }
25  }</code></pre>
<p>Obsérvense los blancos en <code>&lt; escape&gt;</code> y en <code>&lt;token: b  &gt; b</code>. Pese a ello el programa funciona:</p>
<pre><code>casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: &lt;(\(\))&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;(\\(\\))&#39;,
          &#39;pp&#39; =&gt; {
                    &#39;&#39; =&gt; &#39;(\\(\\))&#39;,
                    &#39;escape&#39; =&gt; &#39;\\)&#39;
                  }
        };

(b)
matches: &lt;(b)&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;(b)&#39;,
          &#39;pp&#39; =&gt; {
                    &#39;&#39; =&gt; &#39;(b)&#39;,
                    &#39;b&#39; =&gt; &#39;b&#39;
                  }
        };

(&lt;)
matches: &lt;(&lt;)&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;(&lt;)&#39;,
          &#39;pp&#39; =&gt; &#39;(&lt;)&#39;
        };

(c)

casiano@millo:</code></pre>
<blockquote>
<p>…Note, however, that if the result-hash at any level contains only the empty-string key (i.e. the subrule did not call any sub-subrules or save any of their nested result-hashes), then the hash is <span><em>unpacked</em></span> and just the matched substring itself if returned.</p>
<p>For example, if <code>&lt;rule: sentence&gt;</code> had been defined:</p>
<pre><code>    &lt;rule: sentence&gt;
        I see dead people</code></pre>
<p>then a successful call to the rule would only add:</p>
<pre><code>    sentence =&gt; &#39;I see dead people&#39;</code></pre>
<p>to the current result-hash.</p>
<p>This is a useful feature because it prevents a series of nested subrule calls from producing very unwieldy data structures. For example, without this automatic unpacking, even the simple earlier example:</p>
<pre><code>    &lt;rule: sentence&gt;
        &lt;noun&gt; &lt;verb&gt; &lt;object&gt;</code></pre>
<p>would produce something needlessly complex, such as:</p>
<pre><code>    sentence =&gt; {
        &quot;&quot;     =&gt; &#39;I saw a dog&#39;,
        noun   =&gt; {
            &quot;&quot; =&gt; &#39;I&#39;,
        },
        verb   =&gt; {
            &quot;&quot; =&gt; &#39;saw&#39;,
        },
        object =&gt; {
            &quot;&quot;      =&gt; &#39;a dog&#39;,
            article =&gt; {
                &quot;&quot; =&gt; &#39;a&#39;,
            },
            noun    =&gt; {
                &quot;&quot; =&gt; &#39;dog&#39;,
            },
        },
    }</code></pre>
</blockquote>
<p>El siguiente ejemplo ilustra este punto:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        &lt;s&gt;
10
11        &lt;rule: s&gt; &lt;noun&gt; &lt;verb&gt; &lt;object&gt;
12
13        &lt;token: noun&gt; he | she | Peter | Jane
14
15        &lt;token: verb&gt; saw | sees
16
17        &lt;token: object&gt; a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = &lt;&gt;) {
23      while ($input =~ m{$rbb}g) {
24          say(&quot;matches: &lt;$&amp;&gt;&quot;);
25          say Dumper \%/;
26      }
27  }</code></pre>
<p>Sigue una ejecución del programa anterior:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: &lt;he saw a dog&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;he saw a dog&#39;,
          &#39;s&#39; =&gt; {
                   &#39;&#39; =&gt; &#39;he saw a dog&#39;,
                   &#39;object&#39; =&gt; &#39;a dog&#39;,
                   &#39;verb&#39; =&gt; &#39;saw&#39;,
                   &#39;noun&#39; =&gt; &#39;he&#39;
                 }
        };

Jane sees a cat
matches: &lt;Jane sees a cat&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;Jane sees a cat&#39;,
          &#39;s&#39; =&gt; {
                   &#39;&#39; =&gt; &#39;Jane sees a cat&#39;,
                   &#39;object&#39; =&gt; &#39;a cat&#39;,
                   &#39;verb&#39; =&gt; &#39;sees&#39;,
                   &#39;noun&#39; =&gt; &#39;Jane&#39;
                 }
        };</code></pre>
<p>Cuando se usa como parte de un programa que utiliza otras regexes hay que evitar que procese las mismas. reescribe las expresiones regulares durante la fase de preproceso. Esta por ello presenta las mismas limitaciones que cualquier otra forma de ’source filtering’ (véase ). Por ello es una buena idea declarar la gramática en un bloque <code>do</code> restringiendo de esta forma el ámbito de acción del módulo.</p>
<pre><code> 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };</code></pre>
<h3 id="objetos">Objetos</h3>
<blockquote>
<p>When a grammar has parsed successfully, the <code>%/</code> variable will contain a series of nested hashes (and possibly arrays) representing the hierarchical structure of the parsed data.</p>
<p>Typically, the next step is to walk that tree, extracting or converting or otherwise processing that information. If the tree has nodes of many different types, it can be difficult to build a recursive subroutine that can navigate it easily.</p>
<p>A much cleaner solution is possible if the nodes of the tree are proper objects. In that case, you just define a <code>trasnlate()</code> method for each of the classes, and have every node call that method on each of its children. The chain of <code>translate()</code> calls would cascade down the nodes of the tree, each one invoking the appropriate <code>translate()</code> method according to the type of node encountered.</p>
<p>The only problem is that, by default, returns a tree of plain-old hashes, not <code>Class::Whatever</code> objects. Fortunately, it’s easy to request that the result hashes be automatically blessed into the appropriate classes, using the <code>&lt;objrule:...&gt;</code> and <code>&lt;objtoken:...&gt;</code> directives.</p>
<p>These directives are identical to the <code>&lt;rule:...&gt;</code> and <code>&lt;token:...&gt;</code> directives (respectively), except that the rule or token they create will also bless the hash it normally returns, converting it to an object of a class whose name is the same as the rule or token itself.</p>
<p>For example:</p>
<pre><code>    &lt;objrule: Element&gt;
        # ...Defines a rule that can be called as &lt;Element&gt;
        # ...and which returns a hash-based Element object</code></pre>
<p>The <code>IDENTIFIER</code> of the rule or token may also be fully qualified. In such cases, the rule or token is defined using only the final <em>short name</em>, but the result object is blessed using the fully qualified <em>long name</em>. For example:</p>
<pre><code>    &lt;objrule: LaTeX::Element&gt; 
        # ...Defines a rule that can be called as &lt;Element&gt;
        # ...and which returns a hash-based LaTeX::Element object</code></pre>
<p>This can be useful to ensure that returned objects don’t collide with other namespaces in your program.</p>
<p>Note that you can freely mix object-returning and plain-old-hash-returning rules and tokens within a single grammar, though you have to be careful not to subsequently try to call a method on any of the unblessed nodes.</p>
</blockquote>
<h3 id="renombrando-los-resultados-de-una-subregla">Renombrando los resultados de una subregla</h3>
<p>No siempre el nombre de la regla es el mas apropiado para ser el nombre del resultado:</p>
<blockquote>
<p>It is not always convenient to have subrule results stored under the same name as the rule itself. Rule names should be optimized for understanding the behaviour of the parser, whereas result names should be optimized for understanding the structure of the data. Often those two goals are identical, but not always; sometimes rule names need to describe what the data looks like, while result names need to describe what the data means.</p>
</blockquote>
<blockquote>
<p>For example, sometimes you need to call the same rule twice, to match two syntactically identical components whose positions give then semantically distinct meanings:</p>
<pre><code>    &lt;rule: copy_cmd&gt;
        copy &lt;file&gt; &lt;file&gt;</code></pre>
<p>The problem here is that, if the second call to <code>&lt;file&gt;</code> succeeds, its result-hash will be stored under the key <code>file</code>, clobbering the data that was returned from the first call to <code>&lt;file&gt;</code>.</p>
</blockquote>
<blockquote>
<p>To avoid such problems, allows you to alias any subrule call, so that it is still invoked by the original name, but its result-hash is stored under a different key. The syntax for that is: <code>&lt;alias=rulename&gt;</code>. For example:</p>
<pre><code>    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt; &lt;to=file&gt;</code></pre>
<p>Here, <code>&lt;rule: file&gt;</code> is called twice, with the first result-hash being stored under the key <code>from</code>, and the second result-hash being stored under the key <code>to</code>.</p>
<p>Note, however, that the alias before the <code>=</code> must be a proper identifier (i.e. a letter or underscore, followed by letters, digits, and/or underscores). Aliases that start with an underscore and aliases named <code>MATCH</code> have special meaning.</p>
</blockquote>
<blockquote>
<p>Aliases can also be useful for normalizing data that may appear in different formats and sequences. For example:</p>
<pre><code>    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;</code></pre>
<p>Here, regardless of which order the old and new files are specified, the result-hash always gets:</p>
<pre><code>    copy_cmd =&gt; {
        from =&gt; &#39;oldfile&#39;,
          to =&gt; &#39;newfile&#39;,
    }</code></pre>
</blockquote>
<p>El siguiente programa ilustra los comentarios de la documentación:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n copygrammar.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        &lt;copy_cmd&gt;
    10
    11        &lt;rule: copy_cmd&gt;
    12              copy &lt;from=file&gt; &lt;to=file&gt;
    13          |   &lt;from=file&gt; -&gt;   &lt;to=file&gt;
    14          |   &lt;to=file&gt;   &lt;- &lt;from=file&gt;
    15
    16        &lt;token: file&gt; [\w./\\]+
    17      }x;
    18  };
    19
    20  while (my $input = &lt;&gt;) {
    21      while ($input =~ m{$rbb}g) {
    22          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    23          say Dumper \%/;
    24      }
    25  }</code></pre>
<p>Cuando lo ejecutamos obtenemos:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 copygrammar.pl
copy a b
matches: &lt;copy a b&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;copy a b&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;copy a b&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;
                        }
        };

b &lt;- a
matches: &lt;b &lt;- a&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;b &lt;- a&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;b &lt;- a&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;
                        }
        };

a -&gt; b
matches: &lt;a -&gt; b&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;a -&gt; b&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;a -&gt; b&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;
                        }
        };</code></pre>
<h3 id="listas">Listas</h3>
<blockquote>
<p>If a subrule call is quantified with a repetition specifier:</p>
<pre><code>           &lt;rule: file_sequence&gt;
               &lt;file&gt;+</code></pre>
<p>then each repeated match overwrites the corresponding entry in the surrounding rule’s result-hash, so only the result of the final repetition will be retained. That is, if the above example matched the string <code>foo.pl bar.py baz.php</code>, then the result-hash would contain:</p>
<pre><code>           file_sequence {
               &quot;&quot;   =&gt; &#39;foo.pl bar.py baz.php&#39;,
               file =&gt; &#39;baz.php&#39;,
           }</code></pre>
</blockquote>
<p>Existe un caveat con el uso de los operadores de repetición y el manejo de los blancos. Véase el siguiente programa:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;numbers&gt;
11
12        &lt;rule: numbers&gt;
13          (&lt;number&gt;)+
14
15        &lt;token: number&gt; \s*\d+
16      }xms;
17  };
18
19  while (my $input = &lt;&gt;) {
20      if ($input =~ m{$rbb}) {
21          say(&quot;matches: &lt;$&amp;&gt;&quot;);
22          say Dumper \%/;
23      }
24  }</code></pre>
<p>Obsérvese el uso explícito de espacios <code>\s*\d+</code> en la definición de <code>number</code>.</p>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: &lt;1 2 3 4&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;1 2 3 4&#39;,
          &#39;numbers&#39; =&gt; {
                         &#39;&#39; =&gt; &#39;1 2 3 4&#39;,
                         &#39;number&#39; =&gt; &#39; 4&#39;
                       }
        };</code></pre>
<p>Si se eliminan los blancos de la definición de <code>number</code>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          (&lt;number&gt;)+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    22          say Dumper \%/;
    23      }
    24  }</code></pre>
<p>se obtiene una conducta que puede sorprender:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: &lt;12&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;12&#39;,
          &#39;numbers&#39; =&gt; {
                         &#39;&#39; =&gt; &#39;12&#39;,
                         &#39;number&#39; =&gt; &#39;12&#39;
                       }
        };</code></pre>
<p>La explicación está en la documentación: véase la sección :</p>
<blockquote>
<p><code>&lt;rule: IDENTIFIER&gt;</code></p>
<p>Define a rule whose name is specified by the supplied identifier.</p>
<p>Everything following the <code>&lt;rule:...&gt;</code> directive (up to the next <code>&lt;rule:...&gt;</code> or <code>&lt;token:...&gt;</code> directive) is treated as part of the rule being defined.</p>
<p><em>Any whitespace in the rule is replaced by a call to the</em> <code>&lt;.ws&gt;</code> subrule (which defaults to matching <code>\s*</code>, but may be explicitly redefined).</p>
</blockquote>
<p>También podríamos haber resuelto el problema introduciendo un blanco explícito dentro del cierre positivo:</p>
<pre><code>      &lt;rule: numbers&gt;
        (&lt;number&gt; )+

      &lt;token: number&gt; \d+</code></pre>
<blockquote>
<p>Usually, that’s not the desired outcome, so provides another mechanism by which to call a subrule; one that saves all repetitions of its results.</p>
<p>A regular subrule call consists of the rule’s name surrounded by angle brackets. If, instead, you surround the rule’s name with <code>&lt;[...]&gt;</code> (angle and square brackets) like so:</p>
<pre><code>           &lt;rule: file_sequence&gt;
               &lt;[file]&gt;+</code></pre>
<p>then the rule is invoked in exactly the same way, but the result of that submatch is pushed onto an array nested inside the appropriate result-hash entry. In other words, if the above example matched the same <code>foo.pl bar.py baz.php</code> string, the result-hash would contain:</p>
<pre><code>           file_sequence {
               &quot;&quot;   =&gt; &#39;foo.pl bar.py baz.php&#39;,
               file =&gt; [ &#39;foo.pl&#39;, &#39;bar.py&#39;, &#39;baz.php&#39; ],
           }</code></pre>
</blockquote>
<p>Teniendo en cuenta lo dicho anteriormente sobre los blancos dentro de los cuantificadores, es necesario introducir blancos dentro del operador de repetición:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        &lt;numbers&gt;
    11
    12        &lt;rule: numbers&gt;
    13          (?:  &lt;[number]&gt; )+
    14
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    22          say Dumper \%/;
    23      }
    24  }</code></pre>
<p>Al ejecutar este programa obtenemos:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: &lt;1 2 3 4
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;1 2 3 4
&#39;,
          &#39;numbers&#39; =&gt; {
                         &#39;&#39; =&gt; &#39;1 2 3 4
&#39;,
                         &#39;number&#39; =&gt; [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39; ]
                       }
        };</code></pre>
<blockquote>
<p>This <em>listifying subrule call</em> can also be useful for non-repeated subrule calls, if the same subrule is invoked in several places in a grammar. For example if a cmdline option could be given either one or two values, you might parse it:</p>
<pre><code>    &lt;rule: size_option&gt;   
        -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?</code></pre>
<p>The result-hash entry for <code>size</code> would then always contain an array, with either one or two elements, depending on the input being parsed.</p>
</blockquote>
<p>Sigue un ejemplo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size]&gt; (?: x &lt;[size]&gt; )?
16
17        &lt;token: size&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say(&quot;matches: &lt;$&amp;&gt;&quot;);
24          say Dumper \%/;
25      }
26  }</code></pre>
<p>Veamos su comportamiento con diferentes entradas:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: &lt;ls -size 4
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;ls -size 4
&#39;,
          &#39;command&#39; =&gt; {
                         &#39;size_option&#39; =&gt; {
                                            &#39;&#39; =&gt; &#39;-size 4
&#39;,
                                            &#39;size&#39; =&gt; [ &#39;4&#39; ]
                                          },
                         &#39;&#39; =&gt; &#39;ls -size 4
&#39;
                       }
        };

ls -size 2x8
matches: &lt;ls -size 2x8
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;ls -size 2x8
&#39;,
          &#39;command&#39; =&gt; {
                         &#39;size_option&#39; =&gt; {
                                            &#39;&#39; =&gt; &#39;-size 2x8
&#39;,
                                            &#39;size&#39; =&gt; [ &#39;2&#39;, &#39;8&#39; ]
                                          },
                         &#39;&#39; =&gt; &#39;ls -size 2x8
&#39;
                       }
        };</code></pre>
<blockquote>
<p>Listifying subrules can also be given aliases, just like ordinary subrules. The alias is always specified inside the square brackets:</p>
<pre><code>    &lt;rule: size_option&gt;   
        -size &lt;[size=pos_integer]&gt; (?: x &lt;[size=pos_integer]&gt; )?</code></pre>
<p>Here, the sizes are parsed using the <code>pos_integer</code> rule, but saved in the result-hash in an array under the key <code>size</code>.</p>
</blockquote>
<p>Sigue un ejemplo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        &lt;command&gt;
11
12        &lt;rule: command&gt; ls &lt;size_option&gt;
13
14        &lt;rule: size_option&gt;
15            -size &lt;[size=int]&gt; (?: x &lt;[size=int]&gt; )?
16
17        &lt;token: int&gt; \d+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say(&quot;matches: &lt;$&amp;&gt;&quot;);
24          say Dumper \%/;
25      }
26  }</code></pre>
<p>Veamos el resultado de una ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: &lt;ls -size 2x4
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;ls -size 2x4
&#39;,
          &#39;command&#39; =&gt; {
                         &#39;size_option&#39; =&gt; {
                                            &#39;&#39; =&gt; &#39;-size 2x4
&#39;,
                                            &#39;size&#39; =&gt; [
                                                        &#39;2&#39;,
                                                        &#39;4&#39;
                                                      ]
                                          },
                         &#39;&#39; =&gt; &#39;ls -size 2x4
&#39;
                       }
        };</code></pre>
<p>En este ejemplo aparece <code>&lt;number&gt;+</code> sin corchetes ni paréntesis:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        &lt;numbers&gt;
    11  
    12        &lt;rule: numbers&gt; 
    13          &lt;number&gt;+
    14  
    15        &lt;token: number&gt; \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = &lt;&gt;) {
    20      if ($input =~ m{$rbb}) {
    21          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    22          say Dumper \%/;
    23      }
    24  }</code></pre>
<p>Este programa produce un mensaje de advertencia:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule &lt;number&gt;+ will only capture its final match
       | (Did you mean &lt;[number]&gt;+ instead?)
       | </code></pre>
<p>Si se quiere evitar el mensaje y se está dispuesto a asumir la pérdida de los valores asociados con los elementos de la lista se deberán poner el operando entre paréntesis (con o sin memoria).</p>
<p>Esto es lo que dice la documentación sobre este warning:</p>
<blockquote>
<p><code>Repeated subrule &lt;rule&gt; will only capture its final match</code></p>
<p>You specified a subrule call with a repetition qualifier, such as:</p>
<pre><code>        &lt;ListElem&gt;*</code></pre>
<p>or:</p>
<pre><code>        &lt;ListElem&gt;+</code></pre>
<p>Because each subrule call saves its result in a hash entry of the same name, each repeated match will overwrite the previous ones, so only the last match will ultimately be saved. If you want to save all the matches, you need to tell to save the sequence of results as a nested array within the hash entry, like so:</p>
<pre><code>        &lt;[ListElem]&gt;*</code></pre>
<p>or:</p>
<pre><code>        &lt;[ListElem]&gt;+</code></pre>
<p>If you really did intend to throw away every result but the final one, you can silence the warning by placing the subrule call inside any kind of parentheses. For example:</p>
<pre><code>        (&lt;ListElem&gt;)*</code></pre>
<p>or:</p>
<pre><code>        (?: &lt;ListElem&gt; )+</code></pre>
</blockquote>
<h3 id="pseudo-sub-reglas">Pseudo sub-reglas</h3>
<blockquote>
<p>Aliases can also be given to standard Perl subpatterns, as well as to code blocks within a regex. The syntax for subpatterns is:</p>
<pre><code>    &lt;ALIAS= (SUBPATTERN) &gt;</code></pre>
<p>In other words, the syntax is exactly like an aliased subrule call, except that the rule name is replaced with a set of parentheses containing the subpattern. Any parentheses–capturing or non-capturing–will do.</p>
<p>The effect of aliasing a standard subpattern is to cause whatever that subpattern matches to be saved in the result-hash, using the alias as its key. For example:</p>
<pre><code>    &lt;rule: file_command&gt;

        &lt;cmd=(mv|cp|ln)&gt;  &lt;from=file&gt;  &lt;to=file&gt;</code></pre>
<p>Here, the <code>&lt;cmd=(mv|cp|ln)&gt;</code> is treated exactly like a regular <code>(mv|cp|ln)</code>, but whatever substring it matches is saved in the result-hash under the key <code>'cmd'</code>.</p>
</blockquote>
<p>Sigue un ejemplo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n subpattern.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10          &lt;file_command&gt;
11
12          &lt;rule: file_command&gt;
13
14          &lt;cmd=(mv|cp|ln)&gt;  &lt;from=([\w./]+)&gt;  &lt;to=([\w./]+)&gt;
15
16      }x;
17  };
18
19  while (my $input = &lt;&gt;) {
20      while ($input =~ m{$rbb}g) {
21          say(&quot;matches: &lt;$&amp;&gt;&quot;);
22          say Dumper \%/;
23      }
24  }</code></pre>
<p>y una ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 subpattern.pl
mv a b
matches: &lt;mv a b&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;mv a b&#39;,
          &#39;file_command&#39; =&gt; {
                              &#39;&#39; =&gt; &#39;mv a b&#39;,
                              &#39;to&#39; =&gt; &#39;b&#39;,
                              &#39;cmd&#39; =&gt; &#39;mv&#39;,
                              &#39;from&#39; =&gt; &#39;a&#39;
                            }
        };

cp c d
matches: &lt;cp c d&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;cp c d&#39;,
          &#39;file_command&#39; =&gt; {
                              &#39;&#39; =&gt; &#39;cp c d&#39;,
                              &#39;to&#39; =&gt; &#39;d&#39;,
                              &#39;cmd&#39; =&gt; &#39;cp&#39;,
                              &#39;from&#39; =&gt; &#39;c&#39;
                            }
        }</code></pre>
<blockquote>
<p>The syntax for aliasing code blocks is:</p>
<pre><code>    &lt;ALIAS= (?{ your($code-&gt;here) }) &gt;</code></pre>
<p>Note, however, that the code block must be specified in the standard Perl 5.10 regex notation: <code>(?{...})</code>. A common mistake is to write:</p>
<pre><code>    &lt;ALIAS= { your($code-&gt;here } &gt;</code></pre>
<p>instead, which will attempt to interpolate <code>$code</code> before the regex is even compiled, as such variables are only <em>protected</em> from interpolation inside a <code>(?{...})</code>.</p>
<p>When correctly specified, this construct executes the code in the block and saves the result of that execution in the result-hash, using the alias as its key. Aliased code blocks are useful for adding semantic information based on which branch of a rule is executed. For example, consider the <code>copy_cmd</code> alternatives shown earlier:</p>
<pre><code>    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;</code></pre>
<p>Using aliased code blocks, you could add an extra field to the result- hash to describe which form of the command was detected, like so:</p>
<pre><code>    &lt;rule: copy_cmd&gt;
        copy &lt;from=file&gt;        &lt;to=file&gt;  &lt;type=(?{ &#39;std&#39; })&gt; 
      | dup    &lt;to=file&gt;  as  &lt;from=file&gt;  &lt;type=(?{ &#39;rev&#39; })&gt; 
      |      &lt;from=file&gt;  -&gt;    &lt;to=file&gt;  &lt;type=(?{ &#39;fwd&#39; })&gt; 
      |        &lt;to=file&gt;  &lt;-  &lt;from=file&gt;  &lt;type=(?{ &#39;bwd&#39; })&gt; </code></pre>
<p>Now, if the rule matched, the result-hash would contain something like:</p>
<pre><code>    copy_cmd =&gt; {
        from =&gt; &#39;oldfile&#39;,
          to =&gt; &#39;newfile&#39;,
        type =&gt; &#39;fwd&#39;,
    }</code></pre>
</blockquote>
<p>El siguiente ejemplo ilustra lo dicho en la documentación. En la línea 15 hemos introducido una regla para el control de errores<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedcodeblock2.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        &lt;copy_cmd&gt;
10
11        &lt;rule: copy_cmd&gt;
12              copy (&lt;from=file&gt;) (&lt;to=file&gt;) &lt;type=(?{ &#39;std&#39; })&gt;
13          |   &lt;from=file&gt; -&gt;   &lt;to=file&gt; &lt;type=(?{ &#39;fwd&#39; })&gt;
14          |   &lt;to=file&gt;   &lt;- &lt;from=file&gt; &lt;type=(?{ &#39;bwd&#39; })&gt;
15          |   .+ (?{ die &quot;Syntax error!\n&quot; })
16
17        &lt;token: file&gt; [\w./\\]+
18      }x;
19  };
20
21  while (my $input = &lt;&gt;) {
22      while ($input =~ m{$rbb}g) {
23          say(&quot;matches: &lt;$&amp;&gt;&quot;);
24          say Dumper \%/;
25      }
26  }</code></pre>
<p>La ejecución muestra el comportamiento del programa con tres entradas válidas y una errónea:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedcodeblock2.pl
copy a b
matches: &lt;copy a b
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;copy a b
&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;copy a b
&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;,
                          &#39;type&#39; =&gt; &#39;std&#39;
                        }
        };

b &lt;- a
matches: &lt;b &lt;- a
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;b &lt;- a
&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;b &lt;- a
&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;,
                          &#39;type&#39; =&gt; &#39;bwd&#39;
                        }
        };

a -&gt; b
matches: &lt;a -&gt; b
&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;a -&gt; b
&#39;,
          &#39;copy_cmd&#39; =&gt; {
                          &#39;&#39; =&gt; &#39;a -&gt; b
&#39;,
                          &#39;to&#39; =&gt; &#39;b&#39;,
                          &#39;from&#39; =&gt; &#39;a&#39;,
                          &#39;type&#39; =&gt; &#39;fwd&#39;
                        }
        };

cp a b
Syntax error!</code></pre>
<blockquote>
<p>Note that, in addition to the semantics described above, aliased subpatterns and code blocks also become visible to integrated debugger (see ).</p>
</blockquote>
<h3 id="llamadas-a-subreglas-desmemoriadas">Llamadas a subreglas desmemoriadas</h3>
<blockquote>
<p>By default, every subrule call saves its result into the result-hash, either under its own name, or under an alias.</p>
<p>However, sometimes you may want to refactor some literal part of a rule into one or more subrules, without having those submatches added to the result-hash. The syntax for calling a subrule, but ignoring its return value is:</p>
<pre><code>    &lt;.SUBRULE&gt;</code></pre>
<p>(which is stolen directly from Perl 6).</p>
<p>For example, you may prefer to rewrite a rule such as:</p>
<pre><code>    &lt;rule: paren_pair&gt; 

        \( 
            (?: &lt;escape&gt; | &lt;paren_pair&gt; | &lt;brace_pair&gt; | [^()] )*
        \)</code></pre>
<p>without any literal matching, like so:</p>
<pre><code>    &lt;rule: paren_pair&gt; 

        &lt;.left_paren&gt;
            (?: &lt;escape&gt; | &lt;paren_pair&gt; | &lt;brace_pair&gt; | &lt;.non_paren&gt; )*
        &lt;.right_paren&gt;
    
    &lt;token: left_paren&gt;   \(
    &lt;token: right_paren&gt;  \)
    &lt;token: non_paren&gt;    [^()]</code></pre>
<p>Moreover, as the individual components inside the parentheses probably aren’t being captured for any useful purpose either, you could further optimize that to:</p>
<pre><code>    &lt;rule: paren_pair&gt; 

        &lt;.left_paren&gt;
            (?: &lt;.escape&gt; | &lt;.paren_pair&gt; | &lt;.brace_pair&gt; | &lt;.non_paren&gt; )*
        &lt;.right_paren&gt;</code></pre>
<p>Note that you can also use the dot modifier on an aliased subpattern:</p>
<pre><code>    &lt;.Alias= (SUBPATTERN) &gt;</code></pre>
<p>This seemingly contradictory behaviour (of giving a subpattern a name, then deliberately ignoring that name) actually does make sense in one situation. Providing the alias makes the subpattern visible to the debugger, while using the dot stops it from affecting the result-hash. See <em>Debugging non-grammars</em> for an example of this usage.</p>
</blockquote>
<p>Por ejemplo, queremos reconocer listas de números separados por comas. Supongamos también que queremos darle un nombre a la expresión regular de separación. Quizá, aunque no es el caso, porque la expresión regular de separación sea suficientemente compleja. Si no usamos la notación <em>punto</em> la coma aparecerá en la estructura:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n numberscomma.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        &lt;numbers&gt;
    12
    13        &lt;objrule: numbers&gt;
    14          &lt;[number]&gt; (&lt;comma&gt; &lt;[number]&gt;)*
    15
    16        &lt;objtoken: number&gt; \s*\d+
    17        &lt;token: comma&gt;  \s*,
    18      }xms;
    19  };
    20
    21  while (my $input = &lt;&gt;) {
    22      if ($input =~ m{$rbb}) {
    23          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    24          say Dumper \%/;
    25      }
    26  }</code></pre>
<p>En efecto, aparece la clave <code>comma</code>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma.pl
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
  &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
  &#39;numbers&#39; =&gt; bless( {
    &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
    &#39;number&#39; =&gt; [
      bless( { &#39;&#39; =&gt; &#39;2&#39; }, &#39;number&#39; ),
      bless( { &#39;&#39; =&gt; &#39;3&#39; }, &#39;number&#39; ),
      bless( { &#39;&#39; =&gt; &#39;4&#39; }, &#39;number&#39; )
    ],
    &#39;comma&#39; =&gt; &#39;,&#39;
  }, &#39;numbers&#39; )
};</code></pre>
<p>Si cambiamos la llamada a la regla <code>&lt;comma&gt;</code> por <code>&lt;.comma&gt;</code></p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ diff numberscomma.pl numberscomma2.pl
14c14
&lt;         &lt;[number]&gt; (&lt;comma&gt; &lt;[number]&gt;)*
---
&gt;         &lt;[number]&gt; (&lt;.comma&gt; &lt;[number]&gt;)*</code></pre>
<p>eliminamos la aparición de la innecesaria clave:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma2.pl
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
  &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
  &#39;numbers&#39; =&gt; bless( {
    &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
    &#39;number&#39; =&gt; [
      bless( { &#39;&#39; =&gt; &#39;2&#39; }, &#39;number&#39; ),
      bless( { &#39;&#39; =&gt; &#39;3&#39; }, &#39;number&#39; ),
      bless( { &#39;&#39; =&gt; &#39;4&#39; }, &#39;number&#39; )
    ]
  }, &#39;numbers&#39; )
};</code></pre>
<h3 id="destilación-del-resultado">Destilación del resultado</h3>
<blockquote>
<p>also offers full manual control over the distillation process. If you use the reserved word <code>MATCH</code> as the alias for a subrule call:</p>
<pre><code>    &lt;MATCH=filename&gt;</code></pre>
<p>or a subpattern match:</p>
<pre><code>    &lt;MATCH=( \w+ )&gt;</code></pre>
<p>or a code block:</p>
<pre><code>    &lt;MATCH=(?{ 42 })&gt;</code></pre>
<p>then the current rule will treat the return value of that subrule, pattern, or code block as its complete result, and return that value instead of the usual result-hash it constructs. This is the case even if the result has other entries that would normally also be returned.</p>
<p>For example, in a rule like:</p>
<pre><code>    &lt;rule: term&gt;
          &lt;MATCH=literal&gt;
        | &lt;left_paren&gt; &lt;MATCH=expr&gt; &lt;right_paren&gt;</code></pre>
<p>The use of <code>MATCH</code> aliases causes the rule to return either whatever <code>&lt;literal&gt;</code> returns, or whatever <code>&lt;expr&gt;</code> returns (provided it’s between left and right parentheses).</p>
<p>Note that, in this second case, even though <code>&lt;left_paren&gt;</code> and <code>&lt;right_paren&gt;</code> are captured to the result-hash, they are not returned, because the <code>MATCH</code> alias overrides the normal <em>return the result-hash</em> semantics and returns only what its associated subrule (i.e. <code>&lt;expr&gt;</code>) produces.</p>
</blockquote>
<p>El siguiente ejemplo ilustra el uso del alias <code>MATCH</code>:</p>
<pre><code>$ cat -n demo_calc.pl
 1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 8          &lt;Answer&gt;
 9
10          &lt;rule: Answer&gt;
11              &lt;X=Mult&gt; &lt;Op=([+-])&gt; &lt;Y=Answer&gt;
12            | &lt;MATCH=Mult&gt;
13
14          &lt;rule: Mult&gt;
15              &lt;X=Pow&gt; &lt;Op=([*/%])&gt; &lt;Y=Mult&gt;
16            | &lt;MATCH=Pow&gt;
17
18          &lt;rule: Pow&gt;
19              &lt;X=Term&gt; &lt;Op=(\^)&gt; &lt;Y=Pow&gt;
20            | &lt;MATCH=Term&gt;
21
22          &lt;rule: Term&gt;
23                 &lt;MATCH=Literal&gt;
24            | \( &lt;MATCH=Answer&gt; \)
25
26          &lt;token: Literal&gt;
27              &lt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ )&gt;
28      }xms
29  };
30
31  while (my $input = &lt;&gt;) {
32      if ($input =~ $calculator) {
33          use Data::Dumper &#39;Dumper&#39;;
34          warn Dumper \%/;
35      }
36  }</code></pre>
<p>Veamos una ejecución:</p>
<pre><code>$ ./demo_calc.pl
2+3*5
$VAR1 = {
          &#39;&#39; =&gt; &#39;2+3*5&#39;,
          &#39;Answer&#39; =&gt; {
                        &#39;&#39; =&gt; &#39;2+3*5&#39;,
                        &#39;Op&#39; =&gt; &#39;+&#39;,
                        &#39;X&#39; =&gt; &#39;2&#39;,
                        &#39;Y&#39; =&gt; {
                                 &#39;&#39; =&gt; &#39;3*5&#39;,
                                 &#39;Op&#39; =&gt; &#39;*&#39;,
                                 &#39;X&#39; =&gt; &#39;3&#39;,
                                 &#39;Y&#39; =&gt; &#39;5&#39;
                               }
                      }
        };
4-5-2
$VAR1 = {
          &#39;&#39; =&gt; &#39;4-5-2&#39;,
          &#39;Answer&#39; =&gt; {
                        &#39;&#39; =&gt; &#39;4-5-2&#39;,
                        &#39;Op&#39; =&gt; &#39;-&#39;,
                        &#39;X&#39; =&gt; &#39;4&#39;,
                        &#39;Y&#39; =&gt; {
                                 &#39;&#39; =&gt; &#39;5-2&#39;,
                                 &#39;Op&#39; =&gt; &#39;-&#39;,
                                 &#39;X&#39; =&gt; &#39;5&#39;,
                                 &#39;Y&#39; =&gt; &#39;2&#39;
                               }
                      }
        };</code></pre>
<p>Obsérvese como el árbol construido para la expresión <code>4-5-2</code> se hunde a derechas dando lugar a una jerarquía errónea. Para arreglar el problema sería necesario eliminar la recursividad por la izquierda en las reglas correspondientes.</p>
<blockquote>
<p>It’s also possible to control what a rule returns from within a code block. provides a set of reserved variables that give direct access to the result-hash.</p>
<p>The result-hash itself can be accessed as <code>%MATCH</code> within any code block inside a rule. For example:</p>
<pre><code>    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            &lt;MATCH=(?{ $MATCH{X} + $MATCH{Y} })&gt;</code></pre>
<p>Here, the rule matches a product (aliased <code>'X'</code> in the result-hash), then a literal <code>'+'</code>, then another product (aliased to <code>'Y'</code> in the result-hash). The rule then executes the code block, which accesses the two saved values (as <code>$MATCH{X}</code> and <code>$MATCH{Y}</code>), adding them together. Because the block is itself aliased to <code>MATCH</code>, the sum produced by the block becomes the (only) result of the rule.</p>
<p>It is also possible to set the rule result from within a code block (instead of aliasing it). The special <em>override</em> return value is represented by the special variable <code>$MATCH</code>. So the previous example could be rewritten:</p>
<pre><code>    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })</code></pre>
<p>Both forms are identical in effect. Any assignment to <code>$MATCH</code> overrides the normal <em>return all subrule results</em> behaviour.</p>
<p>Assigning to <code>$MATCH</code> directly is particularly handy if the result may not always be <em>distillable</em>, for example:</p>
<pre><code>    &lt;rule: sum&gt; 
        &lt;X=product&gt; \+ &lt;Y=product&gt;
            (?{ if (!ref $MATCH{X} &amp;&amp; !ref $MATCH{Y}) {
                    # Reduce to sum, if both terms are simple scalars...
                    $MATCH = $MATCH{X} + $MATCH{Y};
                }
                else {
                    # Return full syntax tree for non-simple case...
                    $MATCH{op} = &#39;+&#39;;
                }
            })</code></pre>
<p>Note that you can also partially override the subrule return behaviour. Normally, the subrule returns the complete text it matched under the <em>empty key</em> of its result-hash. That is, of course, <code>$MATCH{&quot;&quot;}</code>, so you can override just that behaviour by directly assigning to that entry.</p>
<p>For example, if you have a rule that matches key/value pairs from a configuration file, you might prefer that any trailing comments not be included in the <span><em>matched text</em></span> entry of the rule’s result-hash. You could hide such comments like so:</p>
<pre><code>    &lt;rule: config_line&gt;
        &lt;key&gt; : &lt;value&gt;  &lt;comment&gt;?
            (?{
                # Edit trailing comments out of &quot;matched text&quot; entry...
                $MATCH = &quot;$MATCH{key} : $MATCH{value}&quot;;
            })</code></pre>
<p>Some more examples of the uses of <code>$MATCH</code>:</p>
<pre><code>    &lt;rule: FuncDecl&gt;
      # Keyword  Name               Keep return the name (as a string)...
        func     &lt;Identifier&gt; ;     (?{ $MATCH = $MATCH{&#39;Identifier&#39;} })


    &lt;rule: NumList&gt;
      # Numbers in square brackets...
        \[ 
            ( \d+ (?: , \d+)* )
        \]

      # Return only the numbers...
        (?{ $MATCH = $CAPTURE })


    &lt;token: Cmd&gt;
      # Match standard variants then standardize the keyword...
        (?: mv | move | rename )      (?{ $MATCH = &#39;mv&#39;; })</code></pre>
<p><code>$CAPTURE</code> and <code>$CONTEXT</code> are both aliases for the built-in read-only <code>$^N </code>variable, which always contains the substring matched by the nearest preceding <code>(...)</code> capture. <code>$^N</code> still works perfectly well, but these are provided to improve the readability of code blocks and error messages respectively.</p>
</blockquote>
<p>El siguiente código implementa una calculadora usando destilación en el código:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_calc_inline.pl
 1  use v5.10;
 2  use warnings;
 3
 4  my $calculator = do{
 5      use Regexp::Grammars;
 6      qr{
 7          &lt;Answer&gt;
 8
 9          &lt;rule: Answer&gt;
10              &lt;X=Mult&gt; \+ &lt;Y=Answer&gt;
11                  (?{ $MATCH = $MATCH{X} + $MATCH{Y}; })
12            | &lt;X=Mult&gt; - &lt;Y=Answer&gt;
13                  (?{ $MATCH = $MATCH{X} - $MATCH{Y}; })
14            | &lt;MATCH=Mult&gt;
15
16          &lt;rule: Mult&gt;
17              &lt;X=Pow&gt; \* &lt;Y=Mult&gt;
18                  (?{ $MATCH = $MATCH{X} * $MATCH{Y}; })
19            | &lt;X=Pow&gt;  / &lt;Y=Mult&gt;
20                  (?{ $MATCH = $MATCH{X} / $MATCH{Y}; })
21            | &lt;X=Pow&gt;  % &lt;Y=Mult&gt;
22                  (?{ $MATCH = $MATCH{X} % $MATCH{Y}; })
23            | &lt;MATCH=Pow&gt;
24
25          &lt;rule: Pow&gt;
26              &lt;X=Term&gt; \^ &lt;Y=Pow&gt;
27                  (?{ $MATCH = $MATCH{X} ** $MATCH{Y}; })
28            | &lt;MATCH=Term&gt;
29
30          &lt;rule: Term&gt;
31                 &lt;MATCH=Literal&gt;
32            | \( &lt;MATCH=Answer&gt; \)
33
34          &lt;token: Literal&gt;
35              &lt;MATCH=( [+-]? \d++ (?: \. \d++ )?+ )&gt;
36      }xms
37  };
38
39  while (my $input = &lt;&gt;) {
40      if ($input =~ $calculator) {
41          say &#39;--&gt; &#39;, $/{Answer};
42      }
43  }</code></pre>
<p>Cual es la salida del programa anterior para las entradas:</p>
<ul>
<li><p><code>4-2-2</code></p></li>
<li><p><code>8/4/2</code></p></li>
<li><p><code>2^2^3</code></p></li>
</ul>
<h3 id="llamadas-privadas-a-subreglas-y-subreglas-privadas">Llamadas privadas a subreglas y subreglas privadas</h3>
<blockquote>
<p>If a rule name (or an alias) begins with an underscore:</p>
<pre><code>     &lt;_RULENAME&gt;       &lt;_ALIAS=RULENAME&gt;  
    &lt;[_RULENAME]&gt;     &lt;[_ALIAS=RULENAME]&gt;</code></pre>
<p>then matching proceeds as normal, and any result that is returned is stored in the current result-hash in the usual way.</p>
<p>However, when any rule finishes (and just before it returns) it first filters its result-hash, removing any entries whose keys begin with an underscore. This means that any subrule with an underscored name (or with an underscored alias) remembers its result, but only until the end of the current rule. Its results are effectively private to the current rule.</p>
<p>This is especially useful in conjunction with result distillation.</p>
</blockquote>
<h3 id="mas-sobre-listas">Mas sobre listas</h3>
<p>El siguiente ejemplo muestra como construir un reconocedor de listas (posiblemente vacías) de números:</p>
<pre><code>casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           &lt;digit&gt; &lt;List&gt;
    11         | # empty
    12
    13      &lt;rule: digit&gt;
    14          &lt;MATCH=(\d+)&gt;
    15
    16  }xms;
    17
    18  while (my $input = &lt;&gt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper &#39;Dumper&#39;;
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn &quot;Does not match\n&quot;
    26      }
    27  }</code></pre>
<p>Sigue una ejecución:</p>
<pre><code>casiano@millo:~/Lregexp-grammar-examples$ ./simple_list.pl
2 3 4
$VAR1 = {
          &#39;&#39; =&gt; &#39;2 3 4&#39;,
          &#39;List&#39; =&gt; {
                      &#39;&#39; =&gt; &#39;2 3 4&#39;,
                      &#39;digit&#39; =&gt; &#39;2&#39;
                      &#39;List&#39; =&gt; {
                                  &#39;&#39; =&gt; &#39;3 4&#39;,
                                  &#39;digit&#39; =&gt; &#39;3&#39;
                                  &#39;List&#39; =&gt; {
                                              &#39;&#39; =&gt; &#39;4&#39;,
                                              &#39;digit&#39; =&gt; &#39;4&#39;
                                              &#39;List&#39; =&gt; &#39;&#39;,
                                            },
                                },
                    }
        };</code></pre>
<p>Tenga en cuenta que el orden de las reglas influye en el lenguaje reconocido. Véase lo que ocurre si cambiamos en el ejemplo anterior el orden de las reglas:</p>
<pre><code>casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_empty_first.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           # empty
    11         | &lt;digit&gt; &lt;List&gt;
    12
    13      &lt;rule: digit&gt;
    14          &lt;MATCH=(\d+)&gt;
    15
    16  }xms;
    17
    18  while (my $input = &lt;&gt;) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper &#39;Dumper&#39;;
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn &quot;Does not match\n&quot;
    26      }
    27  }</code></pre>
<p>Al ejecutar se obtiene:</p>
<pre><code>casiano@millo:~/Lregexp-grammar-examples$ ./simple_list_empty_first.pl
2 3 4
$VAR1 = {
          &#39;&#39; =&gt; &#39;&#39;,
          &#39;List&#39; =&gt; &#39;&#39;
        };</code></pre>
<p>Por supuesto basta poner anclas en el patrón a buscar para forzar a que se reconozca la lista completa:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ diff simple_list_empty_first.pl simple_list_empty_first_with_anchors.pl
7c7
&lt;     &lt;List&gt;
---
&gt;     ^&lt;List&gt;$</code></pre>
<p>En efecto, la nueva versión reconoce la lista:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_anchors.pl
2 3 4
$VAR1 = {
          &#39;&#39; =&gt; &#39;2 3 4&#39;,
          &#39;List&#39; =&gt; {
                      &#39;List&#39; =&gt; {
                                  &#39;List&#39; =&gt; {
                                              &#39;List&#39; =&gt; &#39;&#39;,
                                              &#39;&#39; =&gt; &#39;4&#39;,
                                              &#39;digit&#39; =&gt; &#39;4&#39;
                                            },
                                  &#39;&#39; =&gt; &#39;3 4&#39;,
                                  &#39;digit&#39; =&gt; &#39;3&#39;
                                },
                      &#39;&#39; =&gt; &#39;2 3 4&#39;,
                      &#39;digit&#39; =&gt; &#39;2&#39;
                    }
        };</code></pre>
<p>Si se quiere mantener la producción vacía en primer lugar pero forzar el reconocimiento de la lista completa, se puede hacer uso de un lookahead negativo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_empty_first_with_lookahead.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use strict;
     5  use Regexp::Grammars;
     6
     7  my $list = qr{
     8      &lt;List&gt;
     9
    10      &lt;rule: List&gt;
    11           (?! &lt;digit&gt; ) # still empty production
    12         | &lt;digit&gt; &lt;List&gt;
    13
    14      &lt;rule: digit&gt;
    15          &lt;MATCH=(\d+)&gt;
    16
    17  }xms;
    18
    19  while (my $input = &lt;&gt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper &#39;Dumper&#39;;
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn &quot;Does not match\n&quot;
    27      }
    28  }</code></pre>
<p>Así, sólo se reducirá por la regla vacía si el siguiente token no es un número. Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_lookahead.pl
2 3 4
$VAR1 = {
          &#39;&#39; =&gt; &#39;2 3 4&#39;,
          &#39;List&#39; =&gt; {
                      &#39;List&#39; =&gt; {
                                  &#39;List&#39; =&gt; {
                                              &#39;List&#39; =&gt; &#39;&#39;,
                                              &#39;&#39; =&gt; &#39;4&#39;,
                                              &#39;digit&#39; =&gt; &#39;4&#39;
                                            },
                                  &#39;&#39; =&gt; &#39;3 4&#39;,
                                  &#39;digit&#39; =&gt; &#39;3&#39;
                                },
                      &#39;&#39; =&gt; &#39;2 3 4&#39;,
                      &#39;digit&#39; =&gt; &#39;2&#39;
                    }
        };</code></pre>
<p>¿Cómo podemos hacer que la estructura retornada por el reconocedor sea una lista?. Podemos añadir acciones como sigue:</p>
<pre><code>casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_action.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      &lt;List&gt;
     8
     9      &lt;rule: List&gt;
    10           &lt;digit&gt; &lt;X=List&gt; &lt;MATCH= (?{ unshift @{$MATCH{X}}, $MATCH{digit}; $MATCH{X} })&gt;
    11         | # empty
    12           &lt;MATCH= (?{ [] })&gt;
    13
    14      &lt;rule: digit&gt;
    15          &lt;MATCH=(\d+)&gt;
    16
    17  }xms;
    18
    19  while (my $input = &lt;&gt;) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper &#39;Dumper&#39;;
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn &quot;Does not match\n&quot;
    27      }
    28  }</code></pre>
<p>Al ejecutarse este programa produce una salida como:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_action.pl
2 3 4
$VAR1 = {
          &#39;&#39; =&gt; &#39;2 3 4&#39;,
          &#39;List&#39; =&gt; [ &#39;2&#39;, &#39;3&#39;, &#39;4&#39; ]
        };</code></pre>
<p>Los operadores de repetición como <code>*</code>, <code>+</code>, etc. permiten simplificar el análisis de lenguajes de listas:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_star.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list = qr{
 7      &lt;List&gt;
 8
 9      &lt;rule: List&gt;
10          (?: &lt;[digit]&gt;)*
11
12      &lt;rule: digit&gt;
13          &lt;MATCH=(\d+)&gt;
14
15  }xms;
16
17  while (my $input = &lt;&gt;) {
18      chomp $input;
19      if ($input =~ $list) {
20          use Data::Dumper &#39;Dumper&#39;;
21          warn Dumper \%/;
22      }
23      else {
24        warn &quot;Does not match\n&quot;
25      }
26  }</code></pre>
<p>Los corchetes alrededor de <code>digit</code> hacen que el valor asociado con el patrón sea la lista de números. Si no los ponemos el valor asociado sería el último valor de la lista.</p>
<blockquote>
<p>One of the commonest tasks in text parsing is to match a list of unspecified length, in which items are separated by a fixed token. Things like:</p>
<pre><code>    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces

    g-c-a-g-t-t-a-c-a          # Bases separated by dashes

    /usr/local/bin             # Names separated by directory markers

    /usr:/usr/local:bin        # Directories separated by colons</code></pre>
<p>The usual construct required to parse these kinds of structures is either:</p>
<pre><code>    &lt;rule: list&gt;

        &lt;item&gt; &lt;separator&gt; &lt;list               # recursive definition
      | &lt;item&gt;                                 # base case</code></pre>
<p>Or, more efficiently, but less prettily:</p>
<pre><code>    &lt;rule: list&gt;

        &lt;[item]&gt; (?: &lt;separator&gt; &lt;[item]&gt; )*   # iterative definition</code></pre>
<p>Because this is such a common requirement, provides a cleaner way to specify the iterative version. The syntax is taken from Perl 6:</p>
<pre><code>    &lt;rule: list&gt;

        &lt;[item]&gt; ** &lt;separator&gt;                # iterative definition</code></pre>
<p>This is a repetition specifier on the first subrule (hence the use of <code>**</code> as the marker, to reflect the repetitive behaviour of <code>*</code>). However, the number of repetitions is controlled by the second subrule: the first subrule will be repeatedly matched for as long as the second subrule matches immediately after it.</p>
<p>So, for example, you can match a sequence of numbers separated by commas with:</p>
<pre><code>    &lt;[number]&gt; ** &lt;comma&gt;

    &lt;token: number&gt;  \d+
    &lt;token: comma&gt;   \s* , \s*</code></pre>
<p>Note that it’s important to use the <code>&lt;[...]&gt;</code> form for the items being matched, so that all of them are saved in the result hash. You can also save all the separators (if that’s important):</p>
<pre><code>    &lt;[number]&gt; ** &lt;[comma]&gt;</code></pre>
<p>The repeated item must be specified as a subrule call fo some kind, but the separators may be specified either as a subrule or a bracketed pattern. For example:</p>
<pre><code>    &lt;[number]&gt; ** ( , )</code></pre>
<p>The separator must always be specified in matched delimiters of some kind: either matching <code>&lt;...&gt;</code> or matching <code>(...)</code>. A common error is to write:</p>
<pre><code>    &lt;[number]&gt; ** ,</code></pre>
<p>You can also use a pattern as the item matcher, but it must be aliased into a subrule:</p>
<pre><code>    &lt;[item=(\d+)]&gt; ** ( , )</code></pre>
</blockquote>
<p>Veamos un ejemplo sencillo:</p>
<pre><code>casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n demo_list.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list_nonempty = qr{
 7      &lt;List&gt;
 8
 9      &lt;rule: List&gt;
10          \(  &lt;[Value]&gt; ** (,)  \)
11
12      &lt;token: Value&gt;
13          \d+
14  }xms;
15
16  my $list_empty = qr{
17      &lt;List&gt;
18
19      &lt;rule: List&gt;
20          \(  (?: &lt;[Value]&gt; ** &lt;_Sep=(,)&gt; )?  \)
21
22      &lt;token: Value&gt;
23          \d+
24  }xms;
25
26  use Smart::Comments;
27
28
29  while (my $input = &lt;&gt;) {
30      my $input2 = $input;
31      if ($input =~ $list_nonempty) {
32          ### nonempty: $/{List}
33      }
34      if ($input2 =~ $list_empty) {
35          ### empty: $/{List}
36      }
37  }</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>casiano@millo:~/src/perl/regexp-grammar-examples$ ./demo_list.pl
(3,4,5)

### nonempty: {
###             &#39;&#39; =&gt; &#39;(3,4,5)&#39;,
###             Value =&gt; [
###                        &#39;3&#39;,
###                        &#39;4&#39;,
###                        &#39;5&#39;
###                      ]
###           }

### empty: {
###          &#39;&#39; =&gt; &#39;(3,4,5)&#39;,
###          Value =&gt; [
###                     &#39;3&#39;,
###                     &#39;4&#39;,
###                     &#39;5&#39;
###                   ]
###        }
()

### empty: &#39;()&#39;</code></pre>
<p>Las expresiones aritméticas puede definirse como una jerarquía de listas como sigue:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n calcaslist.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5  $Data::Dumper::Indent = 1;
 6
 7  my $rbb = do {
 8      use Regexp::Grammars;
 9
10      qr{
11        \A&lt;expr&gt;\z
12
13        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
14
15        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
16
17        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
18
19        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
20
21        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
22
23        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
24                           | \( &lt;MATCH=expr&gt; \)
25
26        &lt;token: addop&gt;        [+-]
27
28        &lt;token: mulop&gt;        [*/]
29
30        &lt;token: powerop&gt;      \*\*|\^
31
32        &lt;token: minus&gt;        - &lt;MATCH=(?{ &#39;NEG&#39; })&gt;
33
34      }x;
35  };
36
37  while (my $input = &lt;&gt;) {
38      chomp($input);
39      if ($input =~ m{$rbb}) {
40          my $tree = $/{expr};
41          say Dumper $tree;
42
43      }
44      else {
45          say(&quot;does not match&quot;);
46      }
47  }</code></pre>
<p>Obsérvese el árbol generado para la expresión <code>4-2-2</code>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 calcaslist.pl
4-2-2
$VAR1 = bless( {
  &#39;operands&#39; =&gt; [
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;4&#39;, &#39;val&#39; =&gt; &#39;4&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;4&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;4&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;4&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;4&#39;
    }, &#39;term&#39; ),
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;2&#39;, &#39;val&#39; =&gt; &#39;2&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;2&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;2&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;2&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;2&#39;
    }, &#39;term&#39; ),
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;2&#39;, &#39;val&#39; =&gt; &#39;2&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;2&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;2&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;2&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;2&#39;
    }, &#39;term&#39; )
  ],
  &#39;&#39; =&gt; &#39;4-2-2&#39;,
  &#39;operators&#39; =&gt; [
    &#39;-&#39;,
    &#39;-&#39;
  ]
}, &#39;expr&#39; );</code></pre>
<h3 id="la-directiva-require">La directiva <span>require</span></h3>
<p>La directiva <code>require</code> es similar en su funcionamiento al paréntesis 5.10 <code>(??{ Código Perl })</code> el cuál hace que el <code>Código Perl</code> sea evaluado durante el tiempo de matching. El resultado de la evaluación se trata como una expresión regular con la que deberá casarse. (véase la sección [subsection:tiempodematching] para mas detalles).</p>
<p>La sintáxis de la directiva <code>&lt;require:&gt;</code> es</p>
<blockquote>
<pre><code>                        &lt;require: (?{ CODE }) &gt;</code></pre>
<p>The code block is executed and if its final value is true, matching continues from the same position. If the block’s final value is false, the match fails at that point and starts backtracking.</p>
</blockquote>
<blockquote>
<p>The <code>&lt;require:...&gt;</code> directive is useful for testing conditions that it’s not easy (or even possible) to check within the syntax of the the regex itself. For example:</p>
<pre><code>    &lt;rule: IPV4_Octet_Decimal&gt;
        # Up three digits...
        &lt;MATCH= ( \d{1,3}+ )&gt;
        
        # ...but less that 256...
        &lt;require: (?{ $MATCH &lt;= 255 })&gt;</code></pre>
<p>A require expects a regex codeblock as its argument and succeeds if the final value of that codeblock is true. If the final value is false, the directive fails and the rule starts backtracking.</p>
<p>Note, in this example that the digits are matched with <code>\d{1,3}+</code> . <em>The trailing</em> <code>+</code> prevents the <code>{1,3}</code> repetition from backtracking to a smaller number of digits if the <code>&lt;require:...&gt;</code> fails.</p>
</blockquote>
<p>El programa <code>demo_IP4.pl</code> ilustra el uso de la directiva:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n ./demo_IP4.pl
 1  #!/usr//bin/env perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  use Regexp::Grammars;
 6
 7  my $grammar = qr{
 8      \A &lt;IP4_addr&gt; \Z
 9
10      &lt;token: quad&gt;
11          &lt;MATCH=(\d{1,3})&gt;
12          &lt;require: (?{ $MATCH &lt; 256 })&gt;
13
14      &lt;token: IP4_addr&gt;
15          &lt;[MATCH=quad]&gt;**(\.)
16          &lt;require: (?{ @$MATCH == 4 })&gt;
17  }xms;
18
19  while (my $line = &lt;&gt;) {
20      if ($line =~ $grammar) {
21          use Data::Dumper &#39;Dumper&#39;;
22          say Dumper \%/;
23      }
24      else {
25          say &#39;Does not match&#39;
26      }
27  }</code></pre>
<p>Las condiciones usadas en el <code>require</code> obligan a que cada quad<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> sea menor que 256 y a que existan sólo cuatro quads.</p>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123 . 145 . 105 . 252
Does not match
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123.145.105.252
$VAR1 = {
          &#39;&#39; =&gt; &#39;123.145.105.252&#39;,
          &#39;IP4_addr&#39; =&gt; [
                          123,
                          145,
                          105,
                          252
                        ]
        };
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
148.257.128.128
Does not match
0.0.0.299
Does not match
pl@nereida:~/Lregexpgrammars/demo$  ./demo_IP4.pl
123.145.105.242.193
Does not match</code></pre>
<p>Obsérvese como no se aceptan blancos entre los puntos en esta versión. ¿Sabría explicar la causa?</p>
<h3 id="casando-con-las-claves-de-un-hash">Casando con las claves de un hash</h3>
<blockquote>
<p>In some situations a grammar may need a rule that matches dozens, hundreds, or even thousands of one-word alternatives. For example, when matching command names, or valid userids, or English words. In such cases it is often impractical (and always inefficient) to list all the alternatives between <code>|</code> alterators:</p>
<pre><code>    &lt;rule: shell_cmd&gt;
        a2p | ac | apply | ar | automake | awk | ...
        # ...and 400 lines later
        ... | zdiff | zgrep | zip | zmore | zsh

    &lt;rule: valid_word&gt;
        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
        # ...and 40,000 lines later... 
        ... | zymotize | zymotoxic | zymurgy | zythem | zythum</code></pre>
<p>To simplify such cases, provides a special construct that allows you to specify all the alternatives as the keys of a normal hash. The syntax for that construct is simply to put the hash name inside angle brackets (with no space between the angles and the hash name).</p>
<p>Which means that the rules in the previous example could also be written:</p>
<pre><code>    &lt;rule: shell_cmd&gt;
        &lt;%cmds&gt;

    &lt;rule: valid_word&gt;
        &lt;%dict&gt;</code></pre>
<p>provided that the two hashes (<code>%cmds</code> and <code>%dict</code>) are visible in the scope where the grammar is created.</p>
<p>Internally, the construct is converted to something equivalent to:</p>
<pre><code>    &lt;rule: shell_cmd&gt;
        (&lt;.hk&gt;)  &lt;require: exists $cmds{$CAPTURE}&gt;

    &lt;rule: valid_word&gt;
        (&lt;.hk&gt;)  &lt;require: exists $dict{$CAPTURE}&gt;</code></pre>
<p>The special <code>&lt;hk&gt;</code> rule is created automatically, and defaults to <code>\S+</code>, but you can also define it explicitly to handle other kinds of keys. For example:</p>
<pre><code>    &lt;rule: hk&gt;
        .+            # Key may be any number of chars on a single line

    &lt;rule: hk&gt;
        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs</code></pre>
<p>Matching a hash key in this way is typically significantly faster than matching a full set of alternations. Specifically, it is O(length of longest potential key), instead of O(number of keys).</p>
</blockquote>
<p>Sigue un ejemplo:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n hash.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Data::Dumper;
 6  $Data::Dumper::Deparse = 1;
 7
 8  my %cmd = map { ($_ =&gt; undef ) } qw( uname pwd date );
 9
10  my $rbb = do {
11      use Regexp::Grammars;
12
13      qr{
14        ^&lt;command&gt;$
15
16        &lt;rule: command&gt;
17          &lt;cmd=%cmd&gt; (?: &lt;[arg]&gt; )*
18
19        &lt;token: arg&gt; [^\s&lt;&gt;`&amp;]+
20      }xms;
21  };
22
23  while (my $input = &lt;&gt;) {
24      chomp($input);
25      if ($input =~ m{$rbb}) {
26          say(&quot;matches: &lt;$&amp;&gt;&quot;);
27          say Dumper \%/;
28          system $/{&#39;&#39;}
29      }
30      else {
31          say(&quot;does not match&quot;);
32      }
33  }</code></pre>
<p>Sigue un ejemplo de ejecución:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 hash.pl
a2p f1 f2
matches: &lt;a2p f1 f2&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;a2p f1 f2&#39;,
          &#39;command&#39; =&gt; {
                         &#39;&#39; =&gt; &#39;a2p f1 f2&#39;,
                         &#39;cmd&#39; =&gt; &#39;a2p&#39;,
                         &#39;arg&#39; =&gt; [
                                    &#39;f1&#39;,
                                    &#39;f2&#39;
                                  ]
                       }
        };

pocho 2 5
does not match</code></pre>
<h3 id="depuración">Depuración</h3>
<blockquote>
<p>provides a number of features specifically designed to help debug both grammars and the data they parse.</p>
<p>All debugging messages are written to a log file (which, by default, is just <code>STDERR</code>). However, you can specify a disk file explicitly by placing a <code>&quot;&lt;logfile:...&gt;&quot;</code> directive <em>at the start of your grammar</em><a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>:</p>
<pre><code>        $grammar = qr{

            &lt;logfile: LaTeX_parser_log &gt;

            \A &lt;LaTeX_file&gt; \Z    # Pattern to match

            &lt;rule: LaTeX_file&gt;
                # etc.
        }x;</code></pre>
<p>You can also explicitly specify that messages go to the terminal:</p>
<pre><code>            &lt;logfile: - &gt;</code></pre>
<p>Whenever a log file has been directly specified, automatically does verbose static analysis of your grammar. That is, whenever it compiles a grammar containing an explicit <code>&quot;&lt;logfile:...&gt;&quot;</code> directive it logs a series of messages explaining how it has interpreted the various components of that grammar. For example, the following grammar:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n log.pl
     1  #!/usr/bin/env perl5.10.1
     2  use strict;
     3  use warnings;
     4  use 5.010;
     5  use Data::Dumper;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        &lt;logfile: -&gt;
    12
    13        &lt;numbers&gt;
    14
    15        &lt;rule: numbers&gt;
    16          &lt;number&gt; ** &lt;.comma&gt;
    17
    18        &lt;token: number&gt; \d+
    19
    20        &lt;token: comma&gt;   ,
    21      }xms;
    22  };
    23
    24  while (my $input = &lt;&gt;) {
    25      if ($input =~ m{$rbb}) {
    26          say(&quot;matches: &lt;$&amp;&gt;&quot;);
    27          say Dumper \%/;
    28      }
    29  }</code></pre>
<p>would produce the following analysis in the terminal:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ ./log.pl
  warn | Repeated subrule &lt;number&gt;* will only capture its final match
       | (Did you mean &lt;[number]&gt;* instead?)
       |
  info | Processing the main regex before any rule definitions
       |    |
       |    |...Treating &lt;numbers&gt; as:
       |    |      |  match the subrule &lt;numbers&gt;
       |    |       \ saving the match in $MATCH{&#39;numbers&#39;}
       |    |
       |     \___End of main regex
       |
       | Defining a rule: &lt;numbers&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating &lt;number&gt; as:
       |    |      |  match the subrule &lt;number&gt;
       |    |       \ saving the match in $MATCH{&#39;number&#39;}
       |    |
       |    |...Treating &lt;.comma&gt; as:
       |    |      |  match the subrule &lt;comma&gt;
       |    |       \ but don&#39;t save anything
       |    |
       |    |...Treating &lt;number&gt; ** &lt;.comma&gt; as:
       |    |      |  repeatedly match the subrule &lt;number&gt;
       |    |       \ as long as the matches are separated by matches of &lt;.comma&gt;
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: &lt;number&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating &#39;\d&#39; as:
       |    |       \ normal Perl regex syntax
       |    |
       |    |...Treating &#39;+ &#39; as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: &lt;comma&gt;
       |    |...Returns: a hash
       |    |
       |    |...Treating &#39;, &#39; as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
2, 3, 4
matches: &lt;2, 3, 4&gt;
$VAR1 = {
          &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
          &#39;numbers&#39; =&gt; {
                         &#39;&#39; =&gt; &#39;2, 3, 4&#39;,
                         &#39;number&#39; =&gt; &#39;4&#39;
                       }
        };</code></pre>
<p>This kind of static analysis is a useful starting point in debugging a <a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>, because it enables you to see what you actually specified (as opposed to what you <em>thought</em> you’d specified).</p>
<p>also provides a simple interactive debugger, with which you can observe the process of parsing and the data being collected in any result-hash.</p>
<p>To initiate debugging, place a <code>&lt;debug:...&gt;</code> directive anywhere in your grammar. When parsing reaches that directive the debugger will be activated, and the command specified in the directive immediately executed. The available commands are:</p>
<pre><code>        &lt;debug: on&gt;    - Enable debugging, stop when entire grammar matches
        &lt;debug: match&gt; - Enable debugging, stope when a rule matches
        &lt;debug: try&gt;   - Enable debugging, stope when a rule is tried
        &lt;debug: off&gt;   - Disable debugging and continue parsing silently

        &lt;debug: continue&gt; - Synonym for &lt;debug: on&gt;
        &lt;debug: run&gt;      - Synonym for &lt;debug: on&gt;
        &lt;debug: step&gt;     - Synonym for &lt;debug: try&gt;</code></pre>
<p>These directives can be placed anywhere within a grammar and take effect when that point is reached in the parsing. Hence, adding a <code>&lt;debug:step&gt;</code> directive is very much like setting a breakpoint at that point in the grammar. Indeed, a common debugging strategy is to turn debugging on and off only around a suspect part of the grammar:</p>
<pre><code>        &lt;rule: tricky&gt;   # This is where we think the problem is...
            &lt;debug:step&gt;
            &lt;preamble&gt; &lt;text&gt; &lt;postscript&gt;
            &lt;debug:off&gt;</code></pre>
<p>Once the debugger is active, it steps through the parse, reporting rules that are tried, matches and failures, backtracking and restarts, and the parser’s location within both the grammar and the text being matched. That report looks like this:</p>
<pre><code>        ===============&gt; Trying &lt;grammar&gt; from position 0
        &gt; cp file1 file2 |...Trying &lt;cmd&gt;
                         |   |...Trying &lt;cmd=(cp)&gt;
                         |   |    \FAIL &lt;cmd=(cp)&gt;
                         |    \FAIL &lt;cmd&gt;
                          \FAIL &lt;grammar&gt;
        ===============&gt; Trying &lt;grammar&gt; from position 1
         cp file1 file2  |...Trying &lt;cmd&gt;
                         |   |...Trying &lt;cmd=(cp)&gt;
         file1 file2     |   |    \_____&lt;cmd=(cp)&gt; matched &#39;cp&#39;
        file1 file2      |   |...Trying &lt;[file]&gt;+
         file2           |   |    \_____&lt;[file]&gt;+ matched &#39;file1&#39;
                         |   |...Trying &lt;[file]&gt;+
        [eos]            |   |    \_____&lt;[file]&gt;+ matched &#39; file2&#39;
                         |   |...Trying &lt;[file]&gt;+
                         |   |    \FAIL &lt;[file]&gt;+
                         |   |...Trying &lt;target&gt;
                         |   |   |...Trying &lt;file&gt;
                         |   |   |    \FAIL &lt;file&gt;
                         |   |    \FAIL &lt;target&gt;
         &lt;~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
        file2            |   |...Trying &lt;target&gt;
                         |   |   |...Trying &lt;file&gt;
                         |   |   |    \____ &lt;file&gt; matched &#39;file2&#39;
        [eos]            |   |    \_____&lt;target&gt; matched &#39;file2&#39;
                         |    \_____&lt;cmd&gt; matched &#39; cp file1 file2&#39;
                          \_____&lt;grammar&gt; matched &#39; cp file1 file2&#39;</code></pre>
<p>The first column indicates the point in the input at which the parser is trying to match, as well as any backtracking or forward searching it may need to do. The remainder of the columns track the parser’s hierarchical traversal of the grammar, indicating which rules are tried, which succeed, and what they match.</p>
<p>Provided the logfile is a terminal (as it is by default), the debugger also pauses at various points in the parsing process–before trying a rule, after a rule succeeds, or at the end of the parse–according to the most recent command issued. When it pauses, you can issue a new command by entering a single letter:</p>
<pre><code>        m       - to continue until the next subrule matches
        t or s  - to continue until the next subrule is tried
        r or c  - to continue to the end of the grammar
        o       - to switch off debugging</code></pre>
<p>Note that these are the first letters of the corresponding <code>&lt;debug:...&gt;</code> commands, listed earlier. Just hitting ENTER while the debugger is paused repeats the previous command.</p>
<p>While the debugger is paused you can also type a <code>d</code>, which will display the result-hash for the current rule. This can be useful for detecting which rule isn’t returning the data you expected.</p>
</blockquote>
<p>Veamos un ejemplo. El siguiente programa activa el depurador:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_debug.pl
     1  #!/usr/bin/env perl5.10.1
     2  use 5.010;
     3  use warnings;
     4
     5      use Regexp::Grammars;
     6
     7      my $balanced_brackets = qr{
     8          &lt;debug:on&gt;
     9
    10          &lt;left_delim=(  \( )&gt;
    11          (?:
    12              &lt;[escape=(  \\ )]&gt;
    13          |   &lt;recurse=( (?R) )&gt;
    14          |   &lt;[simple=(  .  )]&gt;
    15          )*
    16          &lt;right_delim=( \) )&gt;
    17      }xms;
    18
    19      while (&lt;&gt;) {
    20          if (/$balanced_brackets/) {
    21              say &#39;matched:&#39;;
    22              use Data::Dumper &#39;Dumper&#39;;
    23              warn Dumper \%/;
    24          }
    25      }</code></pre>
<p>Al ejecutar obtenemos</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
(a)
=====&gt; Trying &lt;grammar&gt; from position 0
(a)\n  |...Trying &lt;left_delim=(  \( )&gt;
a)\n   |    \_____&lt;left_delim=(  \( )&gt; matched &#39;(&#39;      c
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 1
a)\n   |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
)\n    |    \_____&lt;[simple=(  .  )]&gt; matched &#39;a&#39;
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 2
)\n    |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
\n     |    \_____&lt;[simple=(  .  )]&gt; matched &#39;)&#39;
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 3
\n     |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
[eos]  |    \_____&lt;[simple=(  .  )]&gt; matched &#39;&#39;
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 4
[eos]  |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
       |    \FAIL &lt;[simple=(  .  )]&gt;
       |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;
 &lt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;
 &lt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying &lt;right_delim=( \) )&gt;
\n     |    \_____&lt;right_delim=( \) )&gt; matched &#39;)&#39;
        \_____&lt;grammar&gt; matched &#39;(a)&#39;   d
              :         {
              :           &#39;&#39; =&gt; &#39;(a)&#39;,
              :           &#39;left_delim&#39; =&gt; &#39;(&#39;,
              :           &#39;simple&#39; =&gt; [
              :                         &#39;a&#39;
              :                       ],
              :           &#39;right_delim&#39; =&gt; &#39;)&#39;
              :         };      o
matched:
$VAR1 = {
          &#39;&#39; =&gt; &#39;(a)&#39;,
          &#39;left_delim&#39; =&gt; &#39;(&#39;,
          &#39;simple&#39; =&gt; [
                        &#39;a&#39;
                      ],
          &#39;right_delim&#39; =&gt; &#39;)&#39;
        };</code></pre>
<pre><code>&lt;PRE&gt;
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
&lt;span class=&quot;lightblue&quot;&gt;(a)&lt;/span&gt;
=====&amp;gt; Trying &amp;lt;grammar&amp;gt; from position 0
(a)\n  |...Trying &amp;lt;left_delim=(  \( )&amp;gt;

a)\n   |    \_____&amp;lt;left_delim=(  \( )&amp;gt; matched &#39;(&#39;      &lt;span class=&quot;lightblue&quot;&gt;c&lt;/span&gt;
       |...Trying &amp;lt;[escape=(  \ )]&amp;gt;
       |    \FAIL &amp;lt;[escape=(  \ )]&amp;gt;
       |...Trying &amp;lt;recurse=( (?R) )&amp;gt;
=====&amp;gt; Trying &amp;lt;grammar&amp;gt; from position 1
a)\n   |   |...Trying &amp;lt;left_delim=(  \( )&amp;gt;

       |   |    \FAIL &amp;lt;left_delim=(  \( )&amp;gt;
        \FAIL &amp;lt;grammar&amp;gt;
       |...Trying &amp;lt;[simple=(  .  )]&amp;gt;
)\n    |    \_____&amp;lt;[simple=(  .  )]&amp;gt; matched &#39;a&#39;
       |...Trying &amp;lt;[escape=(  \ )]&amp;gt;

       |    \FAIL &amp;lt;[escape=(  \ )]&amp;gt;
       |...Trying &amp;lt;recurse=( (?R) )&amp;gt;
=====&amp;gt; Trying &amp;lt;grammar&amp;gt; from position 2
)\n    |   |...Trying &amp;lt;left_delim=(  \( )&amp;gt;
       |   |    \FAIL &amp;lt;left_delim=(  \( )&amp;gt;

        \FAIL &amp;lt;grammar&amp;gt;
       |...Trying &amp;lt;[simple=(  .  )]&amp;gt;
\n     |    \_____&amp;lt;[simple=(  .  )]&amp;gt; matched &#39;)&#39;
       |...Trying &amp;lt;[escape=(  \ )]&amp;gt;
       |    \FAIL &amp;lt;[escape=(  \ )]&amp;gt;

       |...Trying &amp;lt;recurse=( (?R) )&amp;gt;
=====&amp;gt; Trying &amp;lt;grammar&amp;gt; from position 3
\n     |   |...Trying &amp;lt;left_delim=(  \( )&amp;gt;
       |   |    \FAIL &amp;lt;left_delim=(  \( )&amp;gt;
        \FAIL &amp;lt;grammar&amp;gt;

       |...Trying &amp;lt;[simple=(  .  )]&amp;gt;
[eos]  |    \_____&amp;lt;[simple=(  .  )]&amp;gt; matched &#39;&#39;
       |...Trying &amp;lt;[escape=(  \ )]&amp;gt;
       |    \FAIL &amp;lt;[escape=(  \ )]&amp;gt;
       |...Trying &amp;lt;recurse=( (?R) )&amp;gt;

=====&amp;gt; Trying &amp;lt;grammar&amp;gt; from position 4
[eos]  |   |...Trying &amp;lt;left_delim=(  \( )&amp;gt;
       |   |    \FAIL &amp;lt;left_delim=(  \( )&amp;gt;
        \FAIL &amp;lt;grammar&amp;gt;
       |...Trying &amp;lt;[simple=(  .  )]&amp;gt;

       |    \FAIL &amp;lt;[simple=(  .  )]&amp;gt;
       |...Trying &amp;lt;right_delim=( \) )&amp;gt;
       |    \FAIL &amp;lt;right_delim=( \) )&amp;gt;
 &amp;lt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying &amp;lt;right_delim=( \) )&amp;gt;
       |    \FAIL &amp;lt;right_delim=( \) )&amp;gt;

 &amp;lt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying &amp;lt;right_delim=( \) )&amp;gt;
\n     |    \_____&amp;lt;right_delim=( \) )&amp;gt; matched &#39;)&#39;
        \_____&amp;lt;grammar&amp;gt; matched &#39;(a)&#39;   &lt;span class=&quot;lightblue&quot;&gt;d&lt;/span&gt;
              :         {
              :           &#39;&#39; =&amp;gt; &#39;(a)&#39;,
              :           &#39;left_delim&#39; =&amp;gt; &#39;(&#39;,
              :           &#39;simple&#39; =&amp;gt; [
              :                         &#39;a&#39;
              :                       ],
              :           &#39;right_delim&#39; =&amp;gt; &#39;)&#39;
              :         };      &lt;span class=&quot;lightblue&quot;&gt;o&lt;/span&gt;
matched:
$VAR1 = {
          &#39;&#39; =&amp;gt; &#39;(a)&#39;,
          &#39;left_delim&#39; =&amp;gt; &#39;(&#39;,
          &#39;simple&#39; =&amp;gt; [
                        &#39;a&#39;
                      ],
          &#39;right_delim&#39; =&amp;gt; &#39;)&#39;
        };

&lt;/PRE&gt;</code></pre>
<h3 id="mensajes-de-log-del-usuario">Mensajes de <span>log</span> del usuario</h3>
<blockquote>
<p>Both static and interactive debugging send a series of predefined log messages to whatever log file you have specified. It is also possible to send additional, user-defined messages to the log, using the <code>&quot;&lt;log:...&gt;&quot;</code> directive.</p>
<p>This directive expects either a simple text or a codeblock as its single argument. If the argument is a code block, that code is expected to return the text of the message; if the argument is anything else, that something else <em>is</em> the literal message. For example:</p>
<pre><code>        &lt;rule: ListElem&gt;

            &lt;Elem=   ( [a-z]\d+) &gt;
                &lt;log: Checking for a suffix, too...&gt;

            &lt;Suffix= ( : \d+   ) &gt;?
                &lt;log: (?{ &quot;ListElem: $MATCH{Elem} and $MATCH{Suffix}&quot; })&gt;</code></pre>
<p>User-defined log messages implemented using a codeblock can also specify a severity level. If the codeblock of a <code>&lt;log:...&gt;</code> directive returns two or more values, the first is treated as a log message severity indicator, and the remaining values as separate lines of text to be logged. For example:</p>
<pre><code>        &lt;rule: ListElem&gt;
            &lt;Elem=   ( [a-z]\d+) &gt;
            &lt;Suffix= ( : \d+   ) &gt;?

                &lt;log: (?{
                    warn =&gt; &quot;Elem was: $MATCH{Elem}&quot;,
                            &quot;Suffix was $MATCH{Suffix}&quot;,
                })&gt;</code></pre>
<p>When they are encountered, user-defined log messages are interspersed between any automatic log messages (i.e. from the debugger), at the correct level of nesting for the current rule.</p>
</blockquote>
<h3 id="depuración-de-regexps">Depuración de Regexps</h3>
<blockquote>
<p>It is possible to use without creating <em>any</em> subrule definitions, simply to debug a recalcitrant regex. For example, if the following regex wasn’t working as expected:</p>
<pre><code>        my $balanced_brackets = qr{
            \(             # left delim
            (?:
                \\         # escape or
            |   (?R)       # recurse or
            |   .          # whatever
            )*
            \)             # right delim
        }xms;</code></pre>
<p>you could instrument it with aliased subpatterns and then debug it step-by-step, using :</p>
<pre><code>        use Regexp::Grammars;

        my $balanced_brackets = qr{
            &lt;debug:step&gt;

            &lt;.left_delim=  (  \(  )&gt;
            (?:
                &lt;.escape=  (  \\  )&gt;
            |   &lt;.recurse= ( (?R) )&gt;
            |   &lt;.whatever=(  .   )&gt;
            )*
            &lt;.right_delim= (  \)  )&gt;
        }xms;

        while (&lt;&gt;) {
            say &#39;matched&#39; if /$balanced_brackets/;
        }</code></pre>
<p>Note the use of amnesiac aliased subpatterns to avoid needlessly building a result-hash. Alternatively, you could use listifying aliases to preserve the matching structure as an additional debugging aid:</p>
<pre><code>        use Regexp::Grammars;

        my $balanced_brackets = qr{
            &lt;debug:step&gt;

            &lt;[left_delim=  (  \(  )]&gt;
            (?:
                &lt;[escape=  (  \\  )]&gt;
            |   &lt;[recurse= ( (?R) )]&gt;
            |   &lt;[whatever=(  .   )]&gt;
            )*
            &lt;[right_delim= (  \)  )]&gt;
        }xms;

        if ( &#39;(a(bc)d)&#39; =~ /$balanced_brackets/) {
            use Data::Dumper &#39;Dumper&#39;;
            warn Dumper \%/;
        }</code></pre>
</blockquote>
<h3 id="manejo-y-recuperación-de-errores">Manejo y recuperación de errores</h3>
<p>En este punto debo decir que no he podido reproducir el comportamiento de las directivas <code>&lt;error:&gt;</code> y <code>&lt;warning:&gt;</code> tal y como las describe Conway en el manual de .</p>
<p>El siguiente ejemplo ilustra un conjunto de técnicas de gestión de errores que son independientes del soprote dado por .</p>
<p>Se trata de la misma calculadora explicada en la sección [subsection:recicla].</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculatorwitherrmanagement.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Lingua::EN::Inflect qw(PL);
 6  use Scalar::Util qw{blessed};
 7
 8  my $rbb = do {
 9      my ($warnings, $errors);    # closure
10      sub warnings { $warnings }  # accessor
11      sub errors { $errors }      # accessor
12
13      use Regexp::Grammars;
14      qr{
15        (?{
16            $warnings = 0;
17            $errors = 0;
18        })
19        \A&lt;expr&gt;
20        (?:   \z
21             |
22               (.*) (?{
23                        # Accept the string but emit a warning
24                        $warnings++;
25                        local our $expr = \$MATCH{expr}{&#39;&#39;};
26                        local our $endlegal = length($$expr) &gt; 4? &quot;... &quot;.substr($$expr, -4) : $$expr;
27                        warn &quot;Warning: Unexpected &#39;&quot;. substr($^N, 0, 10).&quot;&#39; after &#39;$endlegal&#39;\n&quot;;
28                     })
29        )
30
31        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
32
33        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
34
35        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
36
37        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
38
39        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
40
41        &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
42                           | \( &lt;MATCH=expr&gt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn &quot;Error: expecting a number or a open parenthesis, found: &#39;&quot;. substr($^N, 0, 10).&quot;&#39;\n&quot;;
46                                            $warnings++;
47                                            $errors++;
48                                        }) &lt;MATCH=factor&gt;
49
50        &lt;token: addop&gt;        [+-]
51
52        &lt;token: mulop&gt;        [*/]
53
54        &lt;token: powerop&gt;      \*\*|\^
55
56        &lt;token: minus&gt;        - &lt;MATCH=(?{ &#39;NEG&#39; })&gt;
57
58      }x;
59  };
60
61  sub test_calc {
62    my $prompt = shift;
63
64    print $prompt;
65    while (my $input = &lt;&gt;) {
66        chomp($input);
67
68        local %/;
69        $input =~ m{$rbb};
70
71        say warnings.&quot; &quot;.PL(&#39;warning&#39;,warnings) if warnings;
72        say errors.&quot; &quot;.PL(&#39;error&#39;,errors)       if errors;
73
74        my $tree = $/{expr};
75        if (blessed($tree)) {
76            do &quot;PostfixCalc.pm&quot;;
77            say &quot;postfix: &quot;.$tree-&gt;ceval;
78
79            do &quot;EvalCalc.pm&quot;;
80            say &quot;result: &quot;.$tree-&gt;ceval;
81        }
82        print $prompt;
83    }
84    say &quot;Bye!&quot;
85  }
86
87  ########## main
88  test_calc(
89    &#39;Parsing infix arithmetic expressions (CTRL-D to end in unix) &#39;,
90  );</code></pre>
<p>Veamos algunas ejecuciones que incluyen entradas erróneas:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+3
postfix: 2 3 +
result: 5
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: &#39;#)&#39;
Error: expecting a number or a open parenthesis, found: &#39;#&#39;
Error: expecting a number or a open parenthesis, found: &#39;)&#39;
Warning: Unexpected &#39;*(3+#)&#39; after &#39;2&#39;
4 warnings
3 errors
postfix: 2
result: 2
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+#*4
Error: expecting a number or a open parenthesis, found: &#39;#*&#39;
1 warning
1 error
postfix: 2 4 +
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!</code></pre>
<p>Obsérvese los mensajes de error repetidos para la entrada <code>2*(3+#)</code>. Ellos son debidos a los reiterados intentos de casar <code>&lt;factor&gt;</code> en la regla de recuperación de errores:</p>
<pre><code>41        &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
42                           | \( &lt;MATCH=expr&gt; \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn &quot;Error: expecting a number or a open parenthesis, found: &#39;&quot;. substr($^N, 0, 10).&quot;&#39;\n&quot;;
46                                            $warnings++;
47                                            $errors++;
48                                        }) &lt;MATCH=factor&gt;</code></pre>
<p>en este caso resulta imposible encontrar un factor. Se puede cambiar la conducta indicando un <code>(* COMMIT)</code> antes de la llamada a <code>&lt;MATCH=factor&gt;</code>:</p>
<pre><code> 41       &lt;objrule: factor&gt;    (&lt;val=([+-]?\d+(?:\.\d*)?)&gt;)
 42                          | \( &lt;MATCH=expr&gt; \)
 43                          | ([^-+(0-9]+) (?{
 44                                           # is + and not * to avoid infinite recursion
 45                                           warn &quot;Error: expecting a number or a open parenthesis, found: &#39;&quot;. substr($^N, 0, 10).&quot;&#39;\n&quot;;
 46                                           $warnings++;
 47                                           $errors++;
 48                                       }) (*COMMIT) &lt;MATCH=factor&gt;</code></pre>
<p>en este caso la conducta es abandonar en el caso de que no se pueda encontrar un <code>&lt;factor&gt;</code>:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: &#39;#)&#39;
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*3
postfix: 2 3 *
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) @
Error: expecting a number or a open parenthesis, found: &#39;@&#39;
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!</code></pre>
<h3 id="mensajes-de-warning">Mensajes de Warning</h3>
<blockquote>
<p>Sometimes, you want to detect problems, but not invalidate the entire parse as a result. For those occasions, the module provides a <em>less stringent</em> form of error reporting: the <code>&lt;warning:...&gt;</code> directive.</p>
<p>This directive is exactly the same as an <code>&lt;error:...&gt;</code> in every respect except that it does not induce a failure to match at the point it appears.</p>
<p>The directive is, therefore, useful for reporting <em>non-fatal</em> problems in a parse. For example:</p>
<pre><code>       qr{ \A            # ...Match only at start of input
           &lt;ArithExpr&gt;   # ...Match a valid arithmetic expression

           (?:
               # Should be at end of input...
               \s* \Z
             |
               # If not, report the fact but don&#39;t fail...
               &lt;warning: Expected end-of-input&gt;
               &lt;warning: (?{ &quot;Extra junk at index $INDEX: $CONTEXT&quot; })&gt;
           )

           # Rule definitions here...
       }xms;</code></pre>
<p>Note that, because they do not induce failure, two or more <code>&lt;warning:...&gt;</code> directives can be “stacked” in sequence, as in the previous example.</p>
</blockquote>
<h3 id="simplificando-el-ast">Simplificando el AST</h3>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n exprdamian.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        \A&lt;expr&gt;\z
    12
    13        &lt;objrule: expr&gt;    &lt;MATCH=term&gt; (?! &lt;addop&gt; )                  # bypass
    14                         | &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
    15
    16        &lt;objrule: term&gt;    &lt;MATCH=factor&gt; (?! &lt;mulop&gt; )                # bypass
    17                         | &lt;[operands=factor]&gt; ** &lt;[operators=mulop]&gt;
    18
    19        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
    20                         | \( &lt;MATCH=expr&gt; \)
    21
    22        &lt;token: addop&gt; [+-]
    23
    24        &lt;token: mulop&gt; [*/]
    25
    26      }x;
    27  };
    28
    29  while (my $input = &lt;&gt;) {
    30      chomp($input);
    31      if ($input =~ m{$rbb}) {
    32          my $tree = $/{expr};
    33          say Dumper $tree;
    34          say $tree-&gt;ceval;
    35
    36      }
    37      else {
    38          say(&quot;does not match&quot;);
    39      }
    40  }
    41
    42  BEGIN {
    43
    44    package LeftBinaryOp;
    45    use strict;
    46    use base qw(Class::Accessor);
    47
    48    LeftBinaryOp-&gt;mk_accessors(qw{operators operands});
    49
    50    my %f = (
    51      &#39;+&#39; =&gt; sub { shift() + shift() },
    52      &#39;-&#39; =&gt; sub { shift() - shift() },
    53      &#39;*&#39; =&gt; sub { shift() * shift() },
    54      &#39;/&#39; =&gt; sub { shift() / shift() },
    55    );
    56
    57    sub ceval {
    58      my $self = shift;
    59
    60      # recursively evaluate the children first
    61      my @operands = map { $_-&gt;ceval } @{$self-&gt;operands};
    62
    63      # then combine them
    64      my $s = shift @operands;
    65      for (@{$self-&gt;operators}) {
    66        $s = $f{$_}-&gt;($s, shift @operands);
    67      }
    68      return $s;
    69    }
    70
    71    package term;
    72    use base qw{LeftBinaryOp};
    73
    74    package expr;
    75    use base qw{LeftBinaryOp};
    76
    77    package factor;
    78
    79    sub ceval {
    80      my $self = shift;
    81
    82      return $self-&gt;{val};
    83    }
    84
    85    1;
    86  }</code></pre>
<p>Ejecuciones:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 exprdamian.pl
4-2-2
$VAR1 = bless( {
  &#39;operands&#39; =&gt; [
    bless( {
      &#39;&#39; =&gt; &#39;4&#39;,
      &#39;val&#39; =&gt; &#39;4&#39;
    }, &#39;factor&#39; ),
    bless( {
      &#39;&#39; =&gt; &#39;2&#39;,
      &#39;val&#39; =&gt; &#39;2&#39;
    }, &#39;factor&#39; ),
    bless( {
      &#39;&#39; =&gt; &#39;2&#39;,
      &#39;val&#39; =&gt; &#39;2&#39;
    }, &#39;factor&#39; )
  ],
  &#39;&#39; =&gt; &#39;4-2-2&#39;,
  &#39;operators&#39; =&gt; [
    &#39;-&#39;,
    &#39;-&#39;
  ]
}, &#39;expr&#39; );

0
8/4/2
$VAR1 = bless( {
  &#39;operands&#39; =&gt; [
    bless( {
      &#39;&#39; =&gt; &#39;8&#39;,
      &#39;val&#39; =&gt; &#39;8&#39;
    }, &#39;factor&#39; ),
    bless( {
      &#39;&#39; =&gt; &#39;4&#39;,
      &#39;val&#39; =&gt; &#39;4&#39;
    }, &#39;factor&#39; ),
    bless( {
      &#39;&#39; =&gt; &#39;2&#39;,
      &#39;val&#39; =&gt; &#39;2&#39;
    }, &#39;factor&#39; )
  ],
  &#39;&#39; =&gt; &#39;8/4/2&#39;,
  &#39;operators&#39; =&gt; [
    &#39;/&#39;,
    &#39;/&#39;
  ]
}, &#39;term&#39; );

1
3
$VAR1 = bless( {
  &#39;&#39; =&gt; &#39;3&#39;,
  &#39;val&#39; =&gt; &#39;3&#39;
}, &#39;factor&#39; );

3
2*(3+4)
$VAR1 = bless( {
  &#39;operands&#39; =&gt; [
    bless( {
      &#39;&#39; =&gt; &#39;2&#39;,
      &#39;val&#39; =&gt; &#39;2&#39;
    }, &#39;factor&#39; ),
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;&#39; =&gt; &#39;3&#39;,
          &#39;val&#39; =&gt; &#39;3&#39;
        }, &#39;factor&#39; ),
        bless( {
          &#39;&#39; =&gt; &#39;4&#39;,
          &#39;val&#39; =&gt; &#39;4&#39;
        }, &#39;factor&#39; )
      ],
      &#39;&#39; =&gt; &#39;3+4&#39;,
      &#39;operators&#39; =&gt; [
        &#39;+&#39;
      ]
    }, &#39;expr&#39; )
  ],
  &#39;&#39; =&gt; &#39;2*(3+4)&#39;,
  &#39;operators&#39; =&gt; [
    &#39;*&#39;
  ]
}, &#39;term&#39; );

14</code></pre>
<h3 id="subsection:recicla">Reciclando una <span>Regexp::Grammar</span></h3>
<p>El siguiente programa <code>calculator.pl</code> recibe como entrada una expresión en infijo.</p>
<p>La ejecución consta de dos bucles. En la primera parte se inyecta a la jerarquía de clases de los AST generados para las expresiones en infijo una semántica que permite evaluar la expresión:</p>
<pre><code>    58  require EvalCalc;
    59
    60  test_calc(
    61    &#39;Evaluating infix arithmetic expressions (CTRL-D to end in unix) &#39;,
    62    sub { print &amp;Data::Dumper::Dumper(shift()) },
    63  );</code></pre>
<p>En esta primera parte mostraremos además el AST construido para la expresión infija de entrada.</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
8-4-2
$VAR1 = bless( {
  &#39;operands&#39; =&gt; [
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;8&#39;, &#39;val&#39; =&gt; &#39;8&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;8&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;8&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;8&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;8&#39;
    }, &#39;term&#39; ),
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;4&#39;, &#39;val&#39; =&gt; &#39;4&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;4&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;4&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;4&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;4&#39;
    }, &#39;term&#39; ),
    bless( {
      &#39;operands&#39; =&gt; [
        bless( {
          &#39;operands&#39; =&gt; [
            bless( {
              &#39;operands&#39; =&gt; [
                bless( {
                  &#39;operands&#39; =&gt; [
                    bless( { &#39;&#39; =&gt; &#39;2&#39;, &#39;val&#39; =&gt; &#39;2&#39; }, &#39;factor&#39; )
                  ],
                  &#39;&#39; =&gt; &#39;2&#39;
                }, &#39;factorial&#39; )
              ],
              &#39;&#39; =&gt; &#39;2&#39;
            }, &#39;power&#39; )
          ],
          &#39;&#39; =&gt; &#39;2&#39;
        }, &#39;uneg&#39; )
      ],
      &#39;&#39; =&gt; &#39;2&#39;
    }, &#39;term&#39; )
  ],
  &#39;&#39; =&gt; &#39;8-4-2&#39;,
  &#39;operators&#39; =&gt; [
    &#39;-&#39;,
    &#39;-&#39;
  ]
}, &#39;expr&#39; );
2</code></pre>
<pre><code>&lt;pre&gt;
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
&lt;span class=&#39;lightblue&#39;&gt;8-4-2&lt;/span&gt;
$VAR1 = bless( {
  &#39;operands&#39; =&amp;gt; [
    bless( {
      &#39;operands&#39; =&amp;gt; [
        bless( {
          &#39;operands&#39; =&amp;gt; [
            bless( {
              &#39;operands&#39; =&amp;gt; [
                bless( {
                  &#39;operands&#39; =&amp;gt; [
                    bless( { &#39;&#39; =&amp;gt; &#39;8&#39;, &#39;val&#39; =&amp;gt; &#39;8&#39; }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factor&#39;&lt;/span&gt; )
                  ],
                  &#39;&#39; =&amp;gt; &#39;8&#39;
                }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factorial&#39;&lt;/span&gt; )
              ],
              &#39;&#39; =&amp;gt; &#39;8&#39;
            }, &lt;span class=&#39;lightblue&#39;&gt;&#39;power&#39;&lt;/span&gt; )
          ],
          &#39;&#39; =&amp;gt; &#39;8&#39;
        }, &lt;span class=&#39;lightblue&#39;&gt;&#39;uneg&#39;&lt;/span&gt; )
      ],
      &#39;&#39; =&amp;gt; &#39;8&#39;
    }, &lt;span class=&#39;lightblue&#39;&gt;&#39;term&#39;&lt;/span&gt; ),
    bless( {
      &#39;operands&#39; =&amp;gt; [
        bless( {
          &#39;operands&#39; =&amp;gt; [
            bless( {
              &#39;operands&#39; =&amp;gt; [
                bless( {
                  &#39;operands&#39; =&amp;gt; [
                    bless( { &#39;&#39; =&amp;gt; &#39;4&#39;, &#39;val&#39; =&amp;gt; &#39;4&#39; }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factor&#39;&lt;/span&gt; )
                  ],
                  &#39;&#39; =&amp;gt; &#39;4&#39;
                }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factorial&#39;&lt;/span&gt; )
              ],
              &#39;&#39; =&amp;gt; &#39;4&#39;
            }, &lt;span class=&#39;lightblue&#39;&gt;&#39;power&#39;&lt;/span&gt; )
          ],
          &#39;&#39; =&amp;gt; &#39;4&#39;
        }, &lt;span class=&#39;lightblue&#39;&gt;&#39;uneg&#39;&lt;/span&gt; )
      ],
      &#39;&#39; =&amp;gt; &#39;4&#39;
    }, &lt;span class=&#39;lightblue&#39;&gt;&#39;term&#39;&lt;/span&gt; ),
    bless( {
      &#39;operands&#39; =&amp;gt; [
        bless( {
          &#39;operands&#39; =&amp;gt; [
            bless( {
              &#39;operands&#39; =&amp;gt; [
                bless( {
                  &#39;operands&#39; =&amp;gt; [
                    bless( { &#39;&#39; =&amp;gt; &#39;2&#39;, &#39;val&#39; =&amp;gt; &#39;2&#39; }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factor&#39;&lt;/span&gt; )
                  ],
                  &#39;&#39; =&amp;gt; &#39;2&#39;
                }, &lt;span class=&#39;lightblue&#39;&gt;&#39;factorial&#39;&lt;/span&gt; )
              ],
              &#39;&#39; =&amp;gt; &#39;2&#39;
            }, &lt;span class=&#39;lightblue&#39;&gt;&#39;power&#39;&lt;/span&gt; )
          ],
          &#39;&#39; =&amp;gt; &#39;2&#39;
        }, &lt;span class=&#39;lightblue&#39;&gt;&#39;uneg&#39;&lt;/span&gt; )
      ],
      &#39;&#39; =&amp;gt; &#39;2&#39;
    }, &lt;span class=&#39;lightblue&#39;&gt;&#39;term&#39;&lt;/span&gt; )
  ],
  &#39;&#39; =&amp;gt; &#39;8-4-2&#39;,
  &lt;span class=&#39;red&#39;&gt;&#39;operators&#39; =&amp;gt; [
    &#39;-&#39;,
    &#39;-&#39;
  ]&lt;/span&gt;
}, &lt;span class=&#39;lightblue&#39;&gt;&#39;expr&#39;&lt;/span&gt; );
2
&lt;/pre&gt;</code></pre>
<p>Observamos que la asociatividad es la correcta. El <code>2</code> final es el resultado de la evaluación de <code>8-4-2</code>.</p>
<p>La estructura del árbol se corresponde con la de la gramática:</p>
<pre><code> 8  my $rbb = do {
 9      use Regexp::Grammars;
10
11      qr{
12        \A&lt;expr&gt;\z
13
14        &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
15
16        &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
17
18        &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
19
20        &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
21
22        &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
23
24        &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
25                           | \( &lt;MATCH=expr&gt; \)
26
27        &lt;token: addop&gt;        [+-]
28
29        &lt;token: mulop&gt;        [*/]
30
31        &lt;token: powerop&gt;      \*\*|\^
32
33        &lt;token: minus&gt;        - &lt;MATCH=(?{ &#39;NEG&#39; })&gt;
34
35      }x;
36  };</code></pre>
<p>Ahora, en una segunda parte sobreescribimos los métodos <code>sem</code> que describen la semántica para producir una traducción de infijo a postfijo:</p>
<pre><code> 66  require PostfixCalc;
 67  test_calc(&#39;Translating expressions to postfix (CTRL-D to end in unix) &#39;);</code></pre>
<p>Ahora al proporcionar la entrada <code>6--3!</code> obtenemos:</p>
<pre><code>Translating expressions to postfix (CTRL-D to end in unix)
6--3!
6 3 ! ~ -</code></pre>
<p>Aquí <code>~</code> es el operador de negación unaria y <code>!</code> es el operador factorial.</p>
<p>Estos son los ficheros que integran la aplicación:</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ tree
.
|-- EvalCalc.pm            # Soporte para la evaluación de la expresión: sem
|-- Operator.pm            # Soporte a las clases nodo: recorridos
|-- PostfixCalc.pm         # Soporte para la traducción a postfijo: sem
`-- calculator.pl          # programa principal</code></pre>
<p>En el programa principal definimos la gramática y escribimos una subrutina <code>test_calc</code> que realiza el parsing.</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
 1    #!/usr/bin/env perl5.10.1
 2    use strict;
 3    use warnings;
 4    use 5.010;
 5    use Data::Dumper;
 6    $Data::Dumper::Indent = 1;
 7  
 8    my $rbb = do {
 9        use Regexp::Grammars;
10  
11        qr{
12          \A&lt;expr&gt;\z
13  
14          &lt;objrule: expr&gt;      &lt;[operands=term]&gt; ** &lt;[operators=addop]&gt;
15  
16          &lt;objrule: term&gt;      &lt;[operands=uneg]&gt; ** &lt;[operators=mulop]&gt;
17  
18          &lt;objrule: uneg&gt;      &lt;[operators=minus]&gt;* &lt;[operands=power]&gt;
19  
20          &lt;objrule: power&gt;     &lt;[operands=factorial]&gt; ** &lt;[operators=powerop]&gt;
21  
22          &lt;objrule: factorial&gt; &lt;[operands=factor]&gt;  &lt;[operators=(!)]&gt;*
23  
24          &lt;objrule: factor&gt;    &lt;val=([+-]?\d+(?:\.\d*)?)&gt;
25                             | \( &lt;MATCH=expr&gt; \)
26  
27          &lt;token: addop&gt;        [+-]
28  
29          &lt;token: mulop&gt;        [*/]
30  
31          &lt;token: powerop&gt;      \*\*|\^
32  
33          &lt;token: minus&gt;        - &lt;MATCH=(?{ &#39;NEG&#39; })&gt;
34  
35        }x;
36    };
37  
38    sub test_calc {
39      my $prompt = shift;
40      my $handler = shift;
41  
42      say $prompt;
43      while (my $input = &lt;&gt;) {
44          chomp($input);
45          if ($input =~ m{$rbb}) {
46              my $tree = $/{expr};
47              $handler-&gt;($tree) if $handler;
48  
49              say $tree-&gt;ceval;
50  
51          }
52          else {
53              say(&quot;does not match&quot;);
54          }
55      }
56    }
57  
58    require EvalCalc;
59  
60    test_calc(
61      &#39;Evaluating infix arithmetic expressions (CTRL-D to end in unix) &#39;,
62      sub { print &amp;Data::Dumper::Dumper(shift()) },
63    );
64  
65  
66    require PostfixCalc;
67    test_calc(&#39;Translating expressions to postfix (CTRL-D to end in unix) &#39;);</code></pre>
<pre><code>
&lt;pre&gt;
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
&lt;span class=&quot;synLinenum&quot;&gt;    1&lt;/span&gt;   &lt;span class=&quot;synComment&quot;&gt;#!/usr/bin/env perl5.10.1&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;    2&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use strict&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    3&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use warnings&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    4&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;5.010&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    5&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;Data::Dumper;
&lt;span class=&quot;synLinenum&quot;&gt;    6&lt;/span&gt;   &lt;span class=&quot;synIdentifier&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;Data::Dumper::&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;Indent&lt;/span&gt; = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;    7&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;    8&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$rbb&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;do&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;    9&lt;/span&gt;       &lt;span class=&quot;synStatement&quot;&gt;use &lt;/span&gt;Regexp::Grammars;
&lt;span class=&quot;synLinenum&quot;&gt;   10&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   11&lt;/span&gt;       &lt;span class=&quot;synConstant&quot;&gt;qr{&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   12&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\A&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;expr&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\z&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   13&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   14&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: expr&amp;gt;      &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operands=term]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operators=addop]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   15&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   16&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: term&amp;gt;      &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operands=uneg]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operators=mulop]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   17&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   18&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: uneg&amp;gt;      &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operators=minus]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operands=power]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   19&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   20&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: power&amp;gt;     &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operands=factorial]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operators=powerop]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   21&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   22&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: factorial&amp;gt; &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operands=factor]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;  &amp;lt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[operators=(!)]&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   23&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   24&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;objrule: factor&amp;gt;    &amp;lt;val=&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;([+-]?\d+(?:\.\d*)?)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   25&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;                           | &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt; &amp;lt;MATCH=expr&amp;gt; &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\)&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   26&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   27&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;token: addop&amp;gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[+-]&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   28&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   29&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;token: mulop&amp;gt;        &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;[*/]&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   30&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   31&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;token: powerop&amp;gt;      &lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\*\*&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\^&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   32&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   33&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;        &amp;lt;token: minus&amp;gt;        - &amp;lt;MATCH=&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;(?&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;{ &#39;NEG&#39; &lt;/span&gt;}&lt;span class=&quot;synSpecial&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;synLinenum&quot;&gt;   34&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   35&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;      }x&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   36&lt;/span&gt;   };
&lt;span class=&quot;synLinenum&quot;&gt;   37&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   38&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;sub &lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;test_calc &lt;/span&gt;{
&lt;span class=&quot;synLinenum&quot;&gt;   39&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$prompt&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   40&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$handler&lt;/span&gt; = &lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   41&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   42&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$prompt&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   43&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; = &amp;lt;&amp;gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   44&lt;/span&gt;         &lt;span class=&quot;synStatement&quot;&gt;chomp&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   45&lt;/span&gt;         &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synIdentifier&quot;&gt;$input&lt;/span&gt; =~ &lt;span class=&quot;synStatement&quot;&gt;m{&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;$rbb&lt;/span&gt;&lt;span class=&quot;synStatement&quot;&gt;}&lt;/span&gt;) {
&lt;span class=&quot;synLinenum&quot;&gt;   46&lt;/span&gt;             &lt;span class=&quot;synStatement&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$tree&lt;/span&gt; = &lt;span class=&quot;synIdentifier&quot;&gt;$/&lt;/span&gt;{expr};
&lt;span class=&quot;synLinenum&quot;&gt;   47&lt;/span&gt;             &lt;span class=&quot;synIdentifier&quot;&gt;$handler&lt;/span&gt;-&amp;gt;(&lt;span class=&quot;synIdentifier&quot;&gt;$tree&lt;/span&gt;) &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$handler&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   48&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   49&lt;/span&gt;             &lt;span class=&quot;synStatement&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;$tree-&amp;gt;ceval&lt;/span&gt;;
&lt;span class=&quot;synLinenum&quot;&gt;   50&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   51&lt;/span&gt;         }
&lt;span class=&quot;synLinenum&quot;&gt;   52&lt;/span&gt;         &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; {
&lt;span class=&quot;synLinenum&quot;&gt;   53&lt;/span&gt;             &lt;span class=&quot;synStatement&quot;&gt;say&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;does not match&amp;quot;&lt;/span&gt;);
&lt;span class=&quot;synLinenum&quot;&gt;   54&lt;/span&gt;         }
&lt;span class=&quot;synLinenum&quot;&gt;   55&lt;/span&gt;     }
&lt;span class=&quot;synLinenum&quot;&gt;   56&lt;/span&gt;   }
&lt;span class=&quot;synLinenum&quot;&gt;   57&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   58&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;require&lt;/span&gt; EvalCalc;
&lt;span class=&quot;synLinenum&quot;&gt;   59&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   60&lt;/span&gt;   test_calc(
&lt;span class=&quot;synLinenum&quot;&gt;   61&lt;/span&gt;     &lt;span class=&quot;synConstant&quot;&gt;&#39;Evaluating infix arithmetic expressions (CTRL-D to end in unix) &#39;&lt;/span&gt;,
&lt;span class=&quot;synLinenum&quot;&gt;   62&lt;/span&gt;     &lt;span class=&quot;synStatement&quot;&gt;sub &lt;/span&gt;{ &lt;span class=&quot;synStatement&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;synType&quot;&gt;Data::Dumper::&lt;/span&gt;&lt;span class=&quot;synIdentifier&quot;&gt;Dumper&lt;/span&gt;(&lt;span class=&quot;synStatement&quot;&gt;shift&lt;/span&gt;()) },
&lt;span class=&quot;synLinenum&quot;&gt;   63&lt;/span&gt;   );
&lt;span class=&quot;synLinenum&quot;&gt;   64&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   65&lt;/span&gt; 
&lt;span class=&quot;synLinenum&quot;&gt;   66&lt;/span&gt;   &lt;span class=&quot;synStatement&quot;&gt;require&lt;/span&gt; PostfixCalc;
&lt;span class=&quot;synLinenum&quot;&gt;   67&lt;/span&gt;   test_calc(&lt;span class=&quot;synConstant&quot;&gt;&#39;Translating expressions to postfix (CTRL-D to end in unix) &#39;&lt;/span&gt;);
&lt;/pre&gt;</code></pre>
<p>Los nodos del AST poseen un método <code>ceval</code> que se encarga de realizar la traducción del nodo.</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n Operator.pm
   1  #   Class hierarchy diagram:
   2  #  $ vgg -t &#39;Operator(LeftBinaryOp(expr,term),RightBinaryOp(power),PreUnaryOp(uneg),PostUnaryOp(factorial))&#39;
   3  #                           +--------+
   4  #                           |Operator|
   5  #                           +--------+
   6  #          .---------------.----^--------.-------------.
   7  #    +------------+ +-------------+ +----------+ +-----------+
   8  #    |LeftBinaryOp| |RightBinaryOp| |PreUnaryOp| |PostUnaryOp|
   9  #    +------------+ +-------------+ +----------+ +-----------+
  10  #      .---^--.        |              |               |
  11  #    +----+ +----+  +-----+         +----+       +---------+
  12  #    |expr| |term|  |power|         |uneg|       |factorial|
  13  #    +----+ +----+  +-----+         +----+       +---------+
  14  #
  15  #
  16  # NOTE: package &quot;factor&quot; actually implements numbers and is
  17  #       outside this hierarchy
  18  #
  19  package Operator;
  20  use strict;
  21  use Carp;
  22
  23  sub Operands {
  24    my $self = shift;
  25
  26    return () unless exists $self-&gt;{operands};
  27    return @{$self-&gt;{operands}};
  28  }
  29
  30  sub Operators {
  31    my $self = shift;
  32
  33    return () unless exists $self-&gt;{operators};
  34    return @{$self-&gt;{operators}};
  35  }
  36
  37  sub sem {
  38    confess &quot;not defined sem&quot;;
  39  }
  40
  41  sub make_sem {
  42    my $class = shift;
  43    my %semdesc = @_;
  44
  45    for my $class (keys %semdesc) {
  46      my %sem = %{$semdesc{$class}};
  47
  48      # Install &#39;sem&#39; method in $class
  49      no strict &#39;refs&#39;;
  50      no warnings &#39;redefine&#39;;
  51      *{$class.&quot;::sem&quot;} = sub {
  52        my ($self, $op) = @_;
  53        $sem{$op}
  54      };
  55    }
  56  }
  57
  58  package LeftBinaryOp;
  59  use base qw{Operator};
  60
  61  sub ceval {
  62    my $self = shift;
  63
  64    # recursively evaluate the children first
  65    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
  66
  67    # then combine them
  68    my $s = shift @operands;
  69    for ($self-&gt;Operators) {
  70      $s = $self-&gt;sem($_)-&gt;($s, shift @operands);
  71    }
  72    return $s;
  73  }
  74
  75  package RightBinaryOp;
  76  use base qw{Operator};
  77
  78  sub ceval {
  79    my $self = shift;
  80
  81    # recursively evaluate the children first
  82    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
  83
  84    # then combine them
  85    my $s = pop @operands;
  86    for (reverse $self-&gt;Operators) {
  87      $s = $self-&gt;sem($_)-&gt;(pop @operands, $s);
  88    }
  89    return $s;
  90  }
  91
  92  package PreUnaryOp;
  93  use base qw{Operator};
  94
  95  sub ceval {
  96    my $self = shift;
  97
  98    # recursively evaluate the children first
  99    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
 100
 101    # then combine them
 102    my $s = shift @operands;
 103    for (reverse $self-&gt;Operators) {
 104      $s = $self-&gt;sem($_)-&gt;($s);
 105    }
 106    return $s;
 107  }
 108
 109  package PostUnaryOp;
 110  use base qw{Operator};
 111
 112  sub ceval {
 113    my $self = shift;
 114
 115    # recursively evaluate the children first
 116    my @operands = map { $_-&gt;ceval } $self-&gt;Operands;
 117
 118    # then combine them
 119    my $s = shift @operands;
 120    for ($self-&gt;Operators) {
 121      $s = $self-&gt;sem($_)-&gt;($s);
 122    }
 123    return $s;
 124  }
 125
 126  package term;
 127  use base qw{LeftBinaryOp};
 128
 129  package expr;
 130  use base qw{LeftBinaryOp};
 131
 132  package power;
 133  use base qw{RightBinaryOp};
 134
 135  package uneg;
 136  use base qw{PreUnaryOp};
 137
 138  package factorial;
 139  use base qw{PostUnaryOp};
 140
 141  package factor;
 142
 143  sub ceval {
 144    my $self = shift;
 145
 146    return $self-&gt;{val};
 147  }
 148
 149  1;</code></pre>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n EvalCalc.pm
 1  package EvalCalc;
 2  use strict;
 3  use Carp;
 4
 5  use Operator;
 6
 7  ####
 8  sub f {
 9    $_[0]&gt;1?$_[0]*f($_[0]-1):1;
10  }
11
12  sub fac {
13    my $n = shift;
14
15    confess &quot;Not valid number&quot; unless $n =~ /^\d+$/;
16    f($n);
17  };
18
19  my $s = sub { shift() **  shift() };
20
21  Operator-&gt;make_sem(
22     expr =&gt; {
23        &#39;+&#39; =&gt; sub { shift()  +  shift() },
24        &#39;-&#39; =&gt; sub { shift()  -  shift() },
25     },
26     term =&gt; {
27       &#39;*&#39; =&gt; sub { shift()  *  shift() },
28       &#39;/&#39; =&gt; sub { shift()  /  shift() },
29     },
30     power =&gt; {
31        &#39;^&#39;  =&gt; $s,
32        &#39;**&#39; =&gt; $s,
33     },
34     uneg =&gt; {
35        &#39;NEG&#39; =&gt; sub { -shift() },
36     },
37     factorial =&gt; {
38        &#39;!&#39; =&gt; \&amp;fac,
39     },
40  );
41
42  1;</code></pre>
<pre><code>pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n PostfixCalc.pm
 1  package PostfixCalc;
 2  use strict;
 3
 4  use Operator;
 5
 6  # Modify semantics: now translate to postfix
 7  my $powers = sub { shift().&#39; &#39;.shift().&#39; **&#39; };
 8
 9  Operator-&gt;make_sem(
10     expr =&gt; {
11        &#39;+&#39; =&gt; sub { shift().&#39; &#39;.shift().&#39; +&#39;  },
12        &#39;-&#39; =&gt; sub { shift().&#39; &#39;.shift().&#39; -&#39; },
13      },
14      term =&gt; {
15        &#39;*&#39; =&gt; sub { shift().&#39; &#39;.shift().&#39; *&#39;  },
16        &#39;/&#39; =&gt; sub { shift().&#39; &#39;.shift().&#39; /&#39; },
17      },
18      power =&gt; {
19        &#39;^&#39;  =&gt; $powers,
20        &#39;**&#39; =&gt; $powers,
21      },
22      uneg =&gt; {
23         # use ~ for unary minus
24        &#39;NEG&#39; =&gt; sub { shift().&#39; ~&#39; },
25      },
26      factorial =&gt; {
27        &#39;!&#39; =&gt; sub { shift().&#39; !&#39;},
28      },
29  );
30
31  1;</code></pre>
<ul>
<li><p>Explique el significado de la primera línea del programa principal</p>
<pre><code>pl@nereida:~/Lregexpgrammars/demo$ cat -n calculator.pl
   1  #!/usr/bin/env perl5.10.1</code></pre></li>
<li><p>Explique el significado de <code>$handler</code> en <code>test_calc</code>:</p>
<pre><code>  42  sub test_calc {
  43    my $prompt = shift;
  44    my $handler = shift;
  45
  46    say $prompt;
  47    while (my $input = &lt;&gt;) {
  48        chomp($input);
  49        if ($input =~ m{$rbb}) {
  50            my $tree = $/{expr};
  51            $handler-&gt;($tree) if $handler;
  52
  53            say $tree-&gt;ceval;
  54
  55        }
  56        else {
  57            say(&quot;does not match&quot;);
  58        }
  59    }
  60  }</code></pre></li>
<li><p>Aisle las funciones relacionadas con la creación de semántica como <code>make_sem</code>, <code>fac</code> y las llamadas a <code>make_sem</code> en un módulo <code>Calculator::Semantics</code> aparte.</p></li>
<li><p>Añada un traductor de infijo a prefijo al código presentado en esta sección. Una expresión como <code>2*3+4</code> se traducirá como <code>+ * 2 3 4</code></p></li>
</ul>
<ul>
<li><p>Reforme la estructura del ejemplo para que tenga una jerarquía de desarrollo de acuerdo a los estándares de Perl. Use o bien . Use el espacio de nombres <code>Calculator</code>. Mueva el módulo <code>Operator</code> a <code>Calculator::Operator</code>. Lea el capítulo de los apuntes de LHP.</p></li>
<li><p>Defina el conjunto de pruebas que deberá pasar su traductor. Añádalas como pruebas <code>TODO</code>. Cuando la funcionalidad a comprobar esté operativa cambie su estatus.</p></li>
<li><p>Añada variables y la expresión de asignación:</p>
<pre><code>b = a = 4*2</code></pre>
<p>que será traducida a postfijo como:</p>
<pre><code>4 2 * a = b =</code></pre>
<p>El operador de asignación es asociativo a derechas. El valor devuelto por una expresión de asignación es el valor asignado.</p>
<p>Use un hash para implantar la relación nombre-valor en el caso de la evaluación</p></li>
<li><p>Introduzca la expresión bloque:</p>
<pre><code>c = { a = 4; b = 2*a }</code></pre>
<p>Los bloques son listas entre llaves de expresiones separadas por punto y coma. El valor retornado por una expresión bloque es el último evaluado en el bloque.</p>
<p>El símbolo de arranque de la gramática (esto es, el patrón regular contra el que hay que casar) será la expresión bloque.</p></li>
<li><p>Introduzca las expresiones de comparación <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> y <code>!=</code> con la prioridad adecuada. Tenga en cuenta que una expresión como:</p>
<pre><code>a = b+2 &gt; c*4</code></pre>
<p>deberá entenderse como</p>
<pre><code>a = ((b+2) &gt; (c*4))</code></pre>
<p>Esto es, se traducirá como:</p>
<pre><code>b 2 + c 4 * &gt; a =</code></pre></li>
<li><p>Introduzca la expresión <code>if ... then ... else</code>. La parte del <code>else</code> será opcional:</p>
<pre><code>c = if a &gt; 0 then { a = a -1; 2*a } else { b + 2 };
d = if a &gt; 0 then { a = b -1; 2*b }; </code></pre>
<p>un <code>else</code> casa con el <code>if</code> mas cercano. La sentencia:</p>
<pre><code>if (a &gt; 0) then if (b &gt; 0) then {5} else {6}</code></pre>
<p>se interpreta como:</p>
<pre><code>if (a &gt; 0) then (if (b &gt; 0) then {5} else {6})</code></pre>
<p>y no como:</p>
<pre><code>if (a &gt; 0) then (if (b &gt; 0) then {5}) else {6}</code></pre>
<p>Se traducirá como:</p>
<pre><code>        a
        0
        &gt;
        jz endif124
        b
        0
        &gt;
        jz else125
        5
        j endif126
:else125
        6
:endif124
:endif125
        ...</code></pre></li>
<li><p>Escriba un intérprete de la máquina orientada a pila definida en los apartados anteriores. El código generado debería poder ejecutarse correctamente en el intérprete.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Una diferencia entre <span><span class="math"> ∖ <em>k</em></span></span> y <span><span class="math"> ∖ <em>g</em></span></span> es que el primero sólo admite un nombre como argumento mientras que <span><span class="math"> ∖ <em>g</em></span></span> admite enteros<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>This Perl tip and associated text is copyright Perl Training Australia<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>En este caso la conmutatividad no funciona<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>catnip: La nepeta cataria, también llamada menta de los gatos, de la familia del tomillo y la lavanda. Su perfume desencadena un comportamiento en el animal, similar al del celo<a href="#fnref4">↩</a></p></li>
<li id="fn5"><ul>
<li><p>saippuakauppias: Vendedor de jabón (suomi)</p></li>
<li><p>yam: batata (inglés)</p></li>
<li><p>cam: leva</p></li>
</ul>
<a href="#fnref5">↩</a></li>
<li id="fn6"><ul>
<li><p>peasy:A disagreeable taste of very fresh green peas</p></li>
<li><p>easy peasy:</p>
<ol>
<li><p>(uk) very easy (short for easy-peasy-lemon-squeezy)</p></li>
<li><p>the first half of a rhyming phrase with several alternate second halves, all of which connote an activity or a result that is, respectively, simple to perform or achieve.</p>
<blockquote>
<p>Tie your shoes? Why that’s easy peasy lemon squeezy!<br />Beat your meat? Why that’s easy peasy Japanesey!<br />As a red-stater, condemn books and films without having read or seen them? Why that’s easy peasy puddin’n’pie!<br /></p>
</blockquote></li>
<li><p>It comes from a 1970’s british TV commercial for Lemon Squeezy detergent. They were with a little girl who points out dirty greasy dishes to an adult (mom or relative) and then this adult produces Lemon Squeezy and they clean the dishes quickly. At the end of the commercial the girl says <span><em>Easy Peasy Lemon Squeezy</em></span>.</p>
<p>Today it is a silly way to state something was or will be very easy.</p></li>
</ol></li>
</ul>
<a href="#fnref6">↩</a></li>
<li id="fn7"><p>No sé si existe el término. Significa que la lectura directa y la inversa pueden diferir en los signos de puntuación<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Versión de <span>Grammar.pm</span> obtenida por email con las correcciones de Damian<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>A quad (pronounced KWAHD ) is a unit in a set of something that comes in four units. The term is sometimes used to describe each of the four numbers that constitute an Internet Protocol ( IP ) address. Thus, an Internet address in its numeric form (which is also sometimes called a dot address ) consists of four quads separated by “dots” (periods).</p>
<p>A quad also means <em>a quarter</em> in some usages. (A quarter as a U.S. coin or monetary unit means <em>a quarter of a dollar,</em> and in slang is sometimes called <em>two bits.</em> However, this usage does not mean two binary bits as used in computers.)<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>no funcionará si no se pone al principio de la gramática<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>miscreant - <em><span>One who has behaved badly, or illegally; One not restrained by moral principles; an unscrupulous villain; One who holds an incorrect religious belief; an unbeliever; Lacking in conscience or moral principles; unscrupulous; Holding an incorrect religious belief.</span></em><a href="#fnref11">↩</a></p></li>
</ol>
</div>
