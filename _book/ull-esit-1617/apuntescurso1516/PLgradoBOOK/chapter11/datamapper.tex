
\section{Introducción a Los Object Relational Mappers (ORM)}

What is a Object Relational Mapper?

A simple answer is that you wrap your tables or stored procedures
in classes in your programming language, so that instead of writing
SQL statements to interact with your database, you use methods and
properties of objects.

In other words, instead of something like this:

\begin{verbatim}
  String sql = "SELECT ... FROM persons WHERE id = 10"
  DbCommand cmd = new DbCommand(connection, sql);
  Result res = cmd.Execute();
  String name = res[0]["FIRST_NAME"];
\end{verbatim}
you do something like this:

\begin{verbatim}
  Person p = Person.Get(10);
\end{verbatim}

or similar code (lots of variations here). 
The framework is what makes this code possible.

Now, benefits:

\begin{enumerate}
\item 
First of all, you hide the SQL away from your logic
code
\item 
This has the benefit of allowing you to more easily support
more database engines 
\item 
For instance, MS SQL Server and Oracle have
different names on typical functions, and different ways to do
calculations with dates.
This difference can be put away from your
logic code.
\item 
Additionally, you can focus on writing the logic, instead of getting all the SQL right.
\item 
The code will typically be more readable as well, since it doesn't
contain all the plumbing necessary to talk to the database.
\end{enumerate}

\section{Patterns Active Record y  DataMapper}

\parrafo{Active Record}
In software engineering, the active record pattern is an architectural
pattern found in software that stores its data in relational databases. It
was named by Martin Fowler in his 2003 book {\it Patterns of Enterprise
Application Architecture}. 

The interface of an object conforming to
this pattern would include functions such as 
\begin{itemize}
\item
Insert, 
\item
Update, and 
\item
Delete,
\end{itemize}
plus properties that correspond more or less directly to the columns in
the underlying database table.

Active record is an approach to accessing data in a database. 

\begin{itemize}
\item
A database
table or view is wrapped into a class. 

\item
Thus, an object instance is tied
to a single row in the table. 

\item
After creation of an object, a new row is
added to the table upon save. 

\item
Any object loaded gets its information
from the database. 

\item
When an object is updated the corresponding row in
the table is also updated. 

\item
The wrapper class implements accessor methods
or properties for each column in the table or view.

\item
This pattern is commonly used by object persistence tools, and in
object-relational mapping (ORM). 

\item
Typically, foreign key relationships will
be exposed as an object instance of the appropriate type via a property.
\end{itemize}

Las gemas \htmladdnormallink{activerecord}{https://rubygems.org/gems/activerecord}
y \datamapper{} siguen el patrón \cei{Active Record}.

\begin{itemize}
\item
\htmladdnormallink{Proyecto sinatra-datamapper-sample}{https://github.com/crguezl/sinatra-datamapper-sample} en GitHub
\item
Documentación de \htmladdnormallink{DataMapper}{http://datamapper.org/docs/}
\item
\htmladdnormallink{Sinatra Recipes: DataMapper}{http://recipes.sinatrarb.com/p/models/data\_mapper}
\item
\htmladdnormallink{Sinatra Book: DataMapper}{http://sinatra-book.gittr.com/\#datamapper}
\end{itemize}

\parrafo{DataMapper}
Martin Fowler 
(\htmladdnormallink{Catalog of Patterns of Enterprise Application Architecture}{http://martinfowler.com/eaaCatalog/index.html}):

\begin{quote}
\begin{enumerate}
\item 
Objects and relational databases have different mechanisms for structuring
data. 
\item 
Many parts of an object, such as collections and inheritance,
aren't present in relational databases. 
\item 
When you build an
object model with a lot of business logic it's valuable to use these
mechanisms  
to better organize the data and the behavior that goes with
it. 
\item 
Doing so leads to variant schemas; that is, the object
schema and the relational schema don't match up.
\item 
You still need to transfer data between the two schemas, and this data
transfer becomes a complexity in its own right. 
\item 
If the in-memory objects
know about the relational database structure, changes in
one tend to ripple to the other.
\item 
The \cei{Data Mapper} is a layer of software that separates the in-memory
objects from the database. 
\item 
\emph{Its responsibility is to transfer data between
the two and also to isolate them from each other}
\item 
 With
Data Mapper 
  \begin{enumerate}
  \item
  the in-memory objects needn't know even that there's a
  database present; 
  \item
  they need no SQL interface code, 
  \item
  and certainly no
  knowledge of the database schema. 
  \end{enumerate}
\item 
  (The database schema is always
  ignorant of the objects that use it.) 
  \end{enumerate}
\end{quote}

\red{The gem \htmladdnormallink{perpetuity}{https://github.com/jgaskins/perpetuity}
implements the DataMapper pattern}.

\begin{itemize}
\item \wikip{DataMapper en la Wikipedia}{Data\_mapper\_pattern}
\item
\htmladdnormallink{Martin Fowler: DataMapper}{http://martinfowler.com/eaaCatalog/dataMapper.html}
\item
\htmladdnormallink{https://github.com/crguezl/perpetuity-example}{https://github.com/crguezl/perpetuity-example}
\end{itemize}

\section{Ejemplo de Uso de DataMapper}
\label{section:ejemplodedatamapper}

\parrafo{Donde}
\begin{itemize}
\item
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ pwd -P
/Users/casiano/local/src/ruby/sinatra/sinatra-datamapper-jump-start
\end{verbatim}
\item
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ git remote -v
origin  git@github.com:crguezl/sinatra-datamapper-jump-start.git (fetch)
origin  git@github.com:crguezl/sinatra-datamapper-jump-start.git (push)
\end{verbatim}
\item 
\htmladdnormallink{Este ejemplo en GitHub}{https://github.com/crguezl/sinatra-datamapper-jump-start}
\item
\htmladdnormallink{http://sinadm.herokuapp.com/}{http://sinadm.herokuapp.com/}
(Puede que este caída)
\end{itemize}

\parrafo{Enlaces}
\begin{enumerate}
\item 
\htmladdnormallink{Documentación del módulo DataMapper}{http://rubydoc.info/github/datamapper/dm-core/}
en RubyDoc
\item 
\htmladdnormallink{https://github.com/crguezl/datamapper\_example}{https://github.com/crguezl/datamapper\_example}
\item 
\htmladdnormallink{https://github.com/crguezl/datamapper-intro}{https://github.com/crguezl/datamapper-intro}

\end{enumerate}

\parrafo{La Clase Song}
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ cat song.rb 
require 'dm-core'
require 'dm-migrations'

class Song
  include DataMapper::Resource
  property :id, Serial
  property :title, String
  property :lyrics, Text
  property :length, Integer
  
end
\end{verbatim}
The \verb|Song| model is going to need to be persistent, 
so we'll include \verb|DataMapper::Resource|. 

The convention with model names is to use the singular, not plural version...
but that's just the convention, we can do whatever we want.

\begin{verbatim}
configure do
  enable :sessions
  set :username, 'frank'
  set :password, 'sinatra'
end
\end{verbatim}

\parrafo{DataMapper.finalize}

\begin{verbatim}
DataMapper.finalize
\end{verbatim}
This method performs the  necessary steps to finalize \datamapper{} 
for the current repository. It should be called after loading all models and plugins.
It ensures foreign key properties and anonymous join models are
created. These are otherwise lazily declared, which can lead to
unexpected errors. It also performs basic validity checking of the
\datamapper{} models.

\parrafo{Mas código de Song.rb}
\begin{verbatim}
get '/songs' do
  @songs = Song.all
  slim :songs
end

get '/songs/new' do
  halt(401,'Not Authorized') unless session[:admin]
  @song = Song.new
  slim :new_song
end

get '/songs/:id' do
  @song = Song.get(params[:id])
  slim :show_song
end

get '/songs/:id/edit' do
  @song = Song.get(params[:id])
  slim :edit_song
end
\end{verbatim}

\parrafo{Song.create}

If you want to create a new resource with some given attributes and
then save it all in one go, you can use the \verb|#create| method:
\begin{verbatim}
post '/songs' do  
  song = Song.create(params[:song])
  redirect to("/songs/#{song.id}")
end

put '/songs/:id' do
  song = Song.get(params[:id])
  song.update(params[:song])
  redirect to("/songs/#{song.id}")
end

delete '/songs/:id' do
  Song.get(params[:id]).destroy
  redirect to('/songs')
end
\end{verbatim}

\parrafo{Una sesión con pry probando DataMapper}
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ pry
[1] pry(main)> require 'sinatra'
=> true
[2] pry(main)> require './song'
=> true
\end{verbatim}

\parrafo{DataMapper.setup}

We must specify our database connection.

We need to make sure to do this before you use our models, 
i.e. before we actually start accessing the database.

\begin{verbatim}
  # If you want the logs displayed you have to do this before the call to setup
  DataMapper::Logger.new($stdout, :debug)

  # An in-memory Sqlite3 connection:
  DataMapper.setup(:default, 'sqlite::memory:')

  # A Sqlite3 connection to a persistent database
  DataMapper.setup(:default, 'sqlite:///path/to/project.db')

  # A MySQL connection:
  DataMapper.setup(:default, 'mysql://user:password@hostname/database')

  # A Postgres connection:
  DataMapper.setup(:default, 'postgres://user:password@hostname/database')
Note: that currently you must setup a :default repository to work with DataMapper (and to be able to use additional differently named repositories). This might change in the future.
\end{verbatim}

In our case:

\begin{verbatim}
[4] pry(main)> pry(main)> DataMapper.setup(:default,'sqlite:development.db')
\end{verbatim}

\parrafo{Multiple Data-Store Connections}

DataMapper sports a concept called a \cei{context} which encapsulates the
\cei{data-store context} in which you want operations to occur. For example,
when you setup a connection you are defining a
context known as \verb|:default|

\begin{verbatim}
   DataMapper.setup(:default, 'mysql://localhost/dm_core_test')
\end{verbatim}
If you supply another context name, you will now have 2 database contexts
with their own unique loggers, connection pool, identity map....one
\cei{default context} and one \cei{named context}.

\begin{verbatim}
 DataMapper.setup(:external, 'mysql://someother_host/dm_core_test')
\end{verbatim}
To use one context rather than another, simply wrap your code block inside
a \verb|repository| call. It will return whatever your block of code returns.

\begin{verbatim}
 DataMapper.repository(:external) { Person.first }
 # hits up your :external database and retrieves the first Person
\end{verbatim}
This will use your connection to the \verb|:external|
 data-store and the first
\verb|Person| it finds. Later, when you call \verb|.save| 
on that person, it'll get
saved back to the \verb|:external| data-store; 
An \red{object is aware of what
context it came from and should be saved back to}.

\parrafo{El Objeto DataMapper::Adapters}
\begin{verbatim}
=> #<DataMapper::Adapters::SqliteAdapter:0x007fad2c0f6a50
 @field_naming_convention=DataMapper::NamingConventions::Field::Underscored,
 @name=:default,
 @normalized_uri=
  #<DataObjects::URI:0x007fad2c0f62a8
   @fragment="{Dir.pwd}/development.db",
   @host="",
   @password=nil,
   @path=nil,
   @port=nil,
   @query=
    {"scheme"=>"sqlite3",
     "user"=>nil,
     "password"=>nil,
     "host"=>"",
     "port"=>nil,
     "query"=>nil,
     "fragment"=>"{Dir.pwd}/development.db",
     "adapter"=>"sqlite3",
     "path"=>nil},
   @relative=nil,
   @scheme="sqlite3",
   @subscheme=nil,
   @user=nil>,
 @options=
  {"scheme"=>"sqlite3",
   "user"=>nil,
   "password"=>nil,
   "host"=>"",
   "port"=>nil,
   "query"=>nil,
   "fragment"=>"{Dir.pwd}/development.db",
   "adapter"=>"sqlite3",
   "path"=>nil},
 @resource_naming_convention=
  DataMapper::NamingConventions::Resource::UnderscoredAndPluralized>
\end{verbatim}

\parrafo{Creando las tablas con DataMapper.auto\_migrate!}
We can create the table by issuing the following command:
\begin{verbatim}
[4] pry(main)> DataMapper.auto_migrate!
\end{verbatim}
\begin{enumerate}
\item 
This will issue the necessary \verb|CREATE| statements (\verb|DROP|ing
the table first, if it exists) to define each storage according to
their properties. 
\item 
After \verb|auto_migrate!| has been run, the
database should be in a pristine state. 
\item 
All the tables will be empty
and match the model definitions.
\end{enumerate}

\parrafo{DataMapper.auto\_upgrade!}
This wipes out existing data, so you could also do:
\begin{verbatim}
DataMapper.auto_upgrade!
\end{verbatim}

\begin{enumerate}
\item 
This tries to make the schema match the model. 
\item 
It will \verb|CREATE|
new tables, and add columns to existing tables. 
\item 
It won't change any
existing columns though (say, to add a \verb|NOT NULL| constraint)
and it doesn't drop any columns. 
\item 
Both these commands also can be
used on an individual model (e.g. \verb|Song.auto_migrate!|)
\end{enumerate}

\parrafo{Métodos de la Clase Mapeada}
\begin{verbatim}
[5] pry(main)> song = Song.new
=> #<Song @id=nil @title=nil @lyrics=nil @length=nil @released_on=nil>
[6] pry(main)> song.save
=> true
[7] pry(main)> song
=> #<Song @id=1 @title=<not loaded> @lyrics=<not loaded> @length=<not loaded> @released_on=<not loaded>>
[8] pry(main)> song.title = "My Way"
=> "My Way"
[9] pry(main)> song.lyrics
=> nil
[10] pry(main)> song.lyrics = "And now, the end is near ..."
=> "And now, the end is near ..."
[11] pry(main)> song.length = 435
=> 435
[42] pry(main)> song.save
=> true
[43] pry(main)> song
=> #<Song @id=1 @title="My Way" @lyrics="And now, the end is near ..." @length=435 @released_on=nil>
\end{verbatim}

\parrafo{El método create}
If you want to create a new resource with some given attributes and
then save it all in one go, you can use the \verb|#create|
method.
\begin{verbatim}
[28] pry(main)> Song.create(title: "Come fly with me", lyrics: "Come fly with me, let's fly, let's fly away ...", length: 199) 
=> #<Song @id=2 @title="Come fly with me" @lyrics="Come fly with me, let's fly, let's fly away ..." @length=199 @released_on=<not loaded>>
\end{verbatim}
\begin{enumerate}
\item 
If the creation was successful, \verb|#create| will return the newly created \verb|DataMapper::Resource|
\item  If it failed, it will return a new resource that is initialized with the given attributes and possible default values declared for that resource, but that's not yet saved
\item  To find out wether the creation was successful or not, you can call \verb|#saved|? on the returned resource
\item  It will return \verb|true| if the resource was successfully persisted, or \verb|false| otherwise
\end{enumerate}

\parrafo{first\_or\_create}
If you want to either find the first resource matching some given criteria or just create that resource if it can't be found, you can use \verb|#first_or_create|.

\begin{verbatim}
s = Song.first_or_create(:title => 'New York, New York')
\end{verbatim}
This will first try to find a \verb|Song| instance with the given \verb|title|, and if it fails to do so, it will return a newly created \verb|Song| with that \verb|title|.


If the criteria you want to use to query for the resource differ from the attributes you need for creating a new resource, you can pass the attributes for creating a new resource as the second parameter to \verb|#first_or_create|, also in the form of a \verb|#Hash|.

\begin{verbatim}
s = Song.first_or_create({ :title => 'My Way' }, { :lyrics => '... the end is not near' })
\end{verbatim}

This will search for a \verb|Song| named '\verb|My Way|' and if it
can't find one, it will return a new \verb|Song| instance with its
name set to '\verb|My Way|' and the \verb|lyrics| set to 
\verb|.. the end is not near| 

\begin{enumerate}
\item You can see that for creating a new resource, both hash
arguments will be merged so you don't need to specify the query
criteria again in the second argument Hash that lists the attributes
for creating a new resource
\item However, if you really need to create the new resource with
different values from those used to query for it, the second Hash
argument will overwrite the first one.
\end{enumerate}

\begin{verbatim}
s = Song.first_or_create({ :title => 'My Way' }, {
  :title  => 'My Way Home',
  :lyrics => '... the end is not near'
})
\end{verbatim}
This will search for a \verb|Song| named 
\verb|'My Way'| but if it fails to find one, 
it will return a \verb|Song| instance with its 
title set to \verb|'My Way Home'| and its 
\verb|lyrics| set to \verb|'... the end is not near'|.

\parrafo{Comprobando con sqlite3}

Podemos abrir la base de datos con el gestor de base de datos y comprobar
que las tablas y los datos están allí:
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ sqlite3 development.db 
SQLite version 3.7.11 2012-03-20 11:35:50
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .schema
CREATE TABLE "songs" ("id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, 
		      "title" VARCHAR(50), "lyrics" TEXT, "length"
		      INTEGER, "released_on" TIMESTAMP);
sqlite> select * from songs;
1|My Way|And now, the end is near ...|435|
2|Come fly with me|Come fly with me, let's fly, let's fly away ...|199|
sqlite> 
\end{verbatim}

\parrafo{Búsquedas y Consultas}
\datamapper{} has methods which allow you to grab a single record by
key, the first match to a set of conditions, or a collection of
records matching conditions.

\begin{verbatim}
song  = Song.get(1)                     # get the song with primary key of 1.
song  = Song.get!(1)                    # Or get! if you want an ObjectNotFoundError on failure
song  = Song.first(:title => 'Girl')    # first matching record with the title 'Girl'
song  = Song.last(:title => 'Girl')     # last matching record with the title 'Girl'
songs = Song.all                        # all songs
\end{verbatim}

\begin{verbatim}
[29] pry(main)> Song.count
=> 2
[30] pry(main)> Song.all
=> [#<Song @id=1 @title=nil @lyrics=<not loaded> @length=nil @released_on=nil>, #<Song @id=2 @title="Come fly with me" @lyrics=<not loaded> @length=199 @released_on=nil>]
[31] pry(main)> Song.get(1)
=> #<Song @id=1 @title=nil @lyrics=<not loaded> @length=nil @released_on=nil>
[32] pry(main)> Song.first
=> #<Song @id=1 @title=nil @lyrics=<not loaded> @length=nil @released_on=nil>
[33] pry(main)> Song.last
=> #<Song @id=2 @title="Come fly with me" @lyrics=<not loaded> @length=199 @released_on=nil>
[35] pry(main)> x = Song.first(title: 'Come fly with me')
=> #<Song @id=2 @title="Come fly with me" @lyrics=<not loaded> @length=199 @released_on=nil>
\end{verbatim}

\begin{verbatim}
[44] pry(main)> y = Song.first(title: 'My Way')
=> #<Song @id=1 @title="My Way" @lyrics=<not loaded> @length=435 @released_on=nil>
[45] pry(main)> y.length
=> 435
[46] pry(main)> y.update(length: 275)
=> true
\end{verbatim}

En Sqlite3:
\begin{verbatim}
sqlite> select * from songs;
1|My Way|And now, the end is near ...|275|
2|Come fly with me|Come fly with me, let's fly, let's fly away ...|199|
\end{verbatim}

\parrafo{Borrando}
\begin{verbatim}
[47] pry(main)> Song.create(title: "One less lonely girl")
=> #<Song @id=3 @title="One less lonely girl" @lyrics=<not loaded> @length=<not loaded> @released_on=<not loaded>>
[48] pry(main)> Song.last.destroy
=> true
[49] pry(main)> Song.all
=> [#<Song @id=1 @title="My Way" @lyrics=<not loaded> @length=275 @released_on=nil>, #<Song @id=2 @title="Come fly with me" @lyrics=<not loaded> @length=199 @released_on=nil>]
\end{verbatim}

\parrafo{Búsqueda con Condiciones}
Rather than defining conditions using SQL fragments, we can actually specify conditions using a hash.

The examples above are pretty simple, but you might be wondering
how we can specify conditions beyond equality without resorting to
SQL. Well, thanks to some clever additions to the \Symbol{} class,
it's easy!

\begin{verbatim}
exhibitions = Exhibition.all(:run_time.gt => 2, :run_time.lt => 5)
# => SQL conditions: 'run_time > 1 AND run_time < 5'
\end{verbatim}
Valid symbol operators for the conditions are:

\begin{verbatim}
gt    # greater than
lt    # less than
gte   # greater than or equal
lte   # less than or equal
not   # not equal
eql   # equal
like  # like
\end{verbatim}
Veamos un ejemplo de uso con nuestra clase \verb|Song|:
\begin{verbatim}
[31] pry(main)> Song.all.each do |s|
[31] pry(main)*   s.update(length: rand(400))
[31] pry(main)* end  
=> [#<Song @id=1 @title="My Way" @lyrics=<not loaded> @length=122 @released_on=nil>,
   #<Song @id=2 @title="Come fly with me" @lyrics=<not loaded> @length=105 @released_on=nil>,
   #<Song @id=4 @title="Girl from Ipanema" @lyrics=<not loaded> @length=389 @released_on=nil>]
[32] pry(main)> long = Song.all(:length.gt => 120)
=> [#<Song @id=1 @title="My Way" @lyrics=<not loaded> @length=122 @released_on=nil>,
   #<Song @id=4 @title="Girl from Ipanema" @lyrics=<not loaded> @length=389 @released_on=nil>]
\end{verbatim}

\parrafo{Insertando SQL}
Sometimes you may find that you need to tweak a query manually:
\begin{verbatim}
[40] pry(main)> songs = repository(:default).adapter.select('SELECT title FROM songs WHERE length >= 110')
=> ["My Way", "Girl from Ipanema"]
\end{verbatim}
Note that this will not return \verb|Song| objects, 
rather the raw data straight from the database

\parrafo{main.rb}

\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ cat main.rb
require 'sinatra'
require 'slim'
require 'sass'
require './song'

configure do
  enable :sessions
  set :username, 'frank'
  set :password, 'sinatra'
end

configure :development do
  DataMapper.setup(:default, "sqlite3://#{Dir.pwd}/development.db")
end

configure :production do
  DataMapper.setup(:default, ENV['DATABASE_URL'])
end

get('/styles.css'){ scss :styles }

get '/' do
  slim :home
end

get '/about' do
  @title = "All About This Website"
  slim :about
end

get '/contact' do
  slim :contact
end

not_found do
  slim :not_found
end

get '/login' do
  slim :login
end

post '/login' do
  if params[:username] == settings.username && params[:password] == settings.password
    session[:admin] = true
    redirect to('/songs')
  else
    slim :login
  end
end

get '/logout' do
  session.clear
  redirect to('/login')
end
\end{verbatim}

\section{Configurando la Base de Datos en Heroku con DataMapper. Despliegue}

\Heroku{} utiliza la base de datos PostgreSQL y una URL en una variable 
de entorno \verb|ENV['DATABASE_URL']|.

\begin{verbatim}
configure :development do
  DataMapper.setup(:default, "sqlite3://#{Dir.pwd}/development.db")
end

configure :production do
  DataMapper.setup(:default, ENV['DATABASE_URL'])
end
\end{verbatim}

Estas líneas especifican que se usa SQLite en desarrollo y PostgreSQL en producción.
Obsérvese que el \verb|Gemfile| debe estar coherente:
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ cat Gemfile
source 'https://rubygems.org'
gem "sinatra"
gem "slim"
gem "sass"
gem "dm-core"
gem "dm-migrations"
gem "thin"
gem "pg", :group => :production
gem "dm-postgres-adapter", :group => :production
gem "dm-sqlite-adapter", :group => :development
\end{verbatim}
o mejor:
\begin{verbatim}
group :production do
    gem "pg"
    gem "dm-postgres-adapter"
end
\end{verbatim}


\begin{verbatim}
heroku create ...
\end{verbatim}

\begin{verbatim}
git push heroku master
\end{verbatim}

\begin{verbatim}
heroku open
\end{verbatim}

\begin{verbatim}
heroku logs --source app
\end{verbatim}

Ahora ejecutamos la consola de heroku:

\begin{verbatim}
heroku run console
\end{verbatim}
lo que nos abre una sesión \verb|irb|.

Ahora creamos la base de datos en \Heroku{}:
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku run console
Running `console` attached to terminal... up, run.8011
irb(main):001:0> require './main'
=> true
irb(main):002:0> DataMapper.auto_migrate!
=> #<DataMapper::DescendantSet:0x007fb89c878230 @descendants=#<DataMapper::SubjectSet:0x007fb89c8781b8 @entries=#<DataMapper::OrderedSet:0x007fb89c878190 @cache=#<DataMapper::SubjectSet::NameCache:0x007fb89c878168 @cache={"Song"=>0}>, @entries=[Song]>>>
irb(main):003:0> 
\end{verbatim}
Véase también 
la practica TicTacToe
\ref{practica:ticatactoe}
y
el capítulo {\it Despliegue en Heroku} 
\ref{chapter:despliegueenheroku}.
.
