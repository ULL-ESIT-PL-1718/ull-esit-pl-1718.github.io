
\section{Introducción}


\parrafo{Prerequisitos}
Estos son los prerequisitos (Octubre 2013)
\begin{enumerate}
\item 
Basic Ruby knowledge, including an installed version of Ruby 2.0.0, Rubygems, and Bundler.
\item 
Basic Git knowledge
\item 
Your application must run on Ruby (MRI) 2.0.0.
\item 
Your application must use Bundler.
\item 
A Heroku user account. 
\end{enumerate}

\parrafo{Instala el Heroku Toolbelt}

\begin{enumerate}
\item 
\htmladdnormallink{Crea una cuenta en Heroku}{https://id.heroku.com/signup/www-header}
\item El
\htmladdnormallink{Heroku Toolbelt}{https://toolbelt.heroku.com/}
se compone de:
  \begin{enumerate}
  \item 
  Heroku client - CLI tool for creating and managing Heroku apps
  \item 
  Foreman - an easy option for running your apps locally
  \item 
  Git - revision control and pushing to Heroku
  \end{enumerate}
\end{enumerate}

La primera vez te pedirá las credenciales:
\begin{verbatim}
$ heroku login
Enter your Heroku credentials.
Email: adam@example.com
Password: 
Could not find an existing public key.
Would you like to generate one? [Yn] 
Generating new SSH public key.
Uploading ssh public key /Users/adam/.ssh/id_rsa.pub
\end{verbatim}
La clave la cargas en la sección \verb|SSH keys add key| de
\htmladdnormallink{https://dashboard.heroku.com/account}{https://dashboard.heroku.com/account}

\begin{verbatim}
[~/rack/rack-rock-paper-scissors(test)]$ heroku --version
heroku-gem/2.39.4 (x86_64-darwin11.4.2) ruby/1.9.3
\end{verbatim}

\begin{verbatim}
[~/local/src/ruby/sinatra/rack/rack-rock-paper-scissors(test)]$  which heroku
/Users/casiano/.rvm/gems/ruby-1.9.3-p392/bin/heroku
[~/local/src/ruby/sinatra/rack/rack-rock-paper-scissors(test)]$ ruby -v
ruby 1.9.3p392 (2013-02-22 revision 39386) [x86_64-darwin11.4.2]
\end{verbatim}
Seguramente tienes que instalar una versión del toolbet por cada versión de Ruby con la que quieras usarlo.

Para desinstalarlo:
\begin{verbatim}
$ gem uninstall heroku --all
\end{verbatim}

\parrafo{Actualizaciones}
The Heroku Toolbelt will automatically keep itself up to date.

\begin{enumerate}
\item 
When you run a heroku command, a background process will be spawned
that checks a URL for the latest available version of the CLI. 
\item 
If
a new version is found, it will be downloaded and stored in
\verb|~/.heroku/client|. 
\item 
This background check will happen at most once
every 5 minutes.
\item 
The heroku binary will check for updated clients in \verb|~/.heroku/client|
before loading the system-installed version.
\end{enumerate}

\parrafo{Ayuda}

\begin{verbatim}
[~/local/src/ruby/sinatra/rack/rack-rock-paper-scissors(master)]$ heroku --help
Usage: heroku COMMAND [--app APP] [command-specific-options]

Primary help topics, type "heroku help TOPIC" for more details:

  addons    #  manage addon resources
  apps      #  manage apps (create, destroy)
  auth      #  authentication (login, logout)
  config    #  manage app config vars
  domains   #  manage custom domains
  logs      #  display logs for an app
  ps        #  manage dynos (dynos, workers)
  releases  #  manage app releases
  run       #  run one-off commands (console, rake)
  sharing   #  manage collaborators on an app

Additional topics:

  account      #  manage heroku account options
  certs        #  manage ssl endpoints for an app
  db           #  manage the database for an app
  drains       #  display syslog drains for an app
  fork         #  clone an existing app
  git          #  manage git for apps
  help         #  list commands and display help
  keys         #  manage authentication keys
  labs         #  manage optional features
  maintenance  #  manage maintenance mode for an app
  pg           #  manage heroku-postgresql databases
  pgbackups    #  manage backups of heroku postgresql databases
  plugins      #  manage plugins to the heroku gem
  regions      #  list available regions
  stack        #  manage the stack for an app
  status       #  check status of heroku platform
  update       #  update the heroku client
  version      #  display version
\end{verbatim}

\parrafo{Specify Ruby Version and Declare dependencies with a Gemfile}

Heroku recognizes an app as Ruby by the existence of a \verb|Gemfile|.

Even if your app has no gem dependencies, you should still create
an empty \verb|Gemfile| in order that it appear as a Ruby app.

In local testing, you should be sure to run your app in an isolated
environment (via \verb|bundle exec| or an empty RVM gemset), to make sure
that all the gems your app depends on are in the \verb|Gemfile|.

In addition to specifying dependencies, you’ll want to specify your
Ruby Version using the ruby DSL provided by Bundler.

Here’s an example \verb|Gemfile| for a Sinatra app:

\begin{verbatim}
source "https://rubygems.org"
ruby "2.0.0"
gem 'sinatra', '1.1.0'
\end{verbatim}

\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ cat Gemfile
source 'https://rubygems.org'
gem 'sinatra'
gem 'haml'
gem 'puma'
\end{verbatim}

Run \verb|bundle install| to set up your bundle locally.
\begin{enumerate}
\item  Run:
\begin{verbatim}
$ bundle install
\end{verbatim}
\item 
This ensures that all gems specified in Gemfile, together with their
dependencies, are available for your application.
\item 
 Running bundle
install also generates a \verb|Gemfile.lock| file, \emph{which should be added
to your git repository}. 
\item 
\verb|Gemfile.lock| ensures that your deployed
versions of gems on Heroku match the version installed locally on
your development machine.
\end{enumerate}


\parrafo{Declare process types with {\tt Procfile}}
\label{parrafo:procfile}

Process types are declared via a file named \tei{Procfile} placed in the
root of your app. 

Its format is one process type per line, with
each line containing:
\begin{verbatim}
<process type>: <command>
\end{verbatim}
The syntax is defined as:

\begin{enumerate}
\item 
\verb|<process type>| – an alphanumeric string, is a name for your command, such as 
  \begin{enumerate}
  \item 
  \verb|web|, 
  \item \verb|worker|, 
  \item \verb|urgentworker|, 
  \item \verb|clock|, etc.
  \end{enumerate}
\item 
\verb|<command>| – a command line to launch the process, such as \verb|rake jobs:work|.
\end{enumerate}
The \tei{web} process type \red{is special as it’s the only process type that
will receive HTTP traffic from Heroku’s routers}.


\begin{enumerate}
\item 
Use a \tei{Procfile}, a text file in the root directory of your
application, to explicitly declare what command should be executed
to start a \cei{web dyno}. 

\item 
Assume for instance, that we wanto to execute 
\verb|web.rb| using Ruby.
Here’s a \verb|Procfile|:
\begin{verbatim}
web: bundle exec ruby web.rb -p $PORT
\end{verbatim}
\item 
If we are instead deploying a straight Rack app, here’s a Procfile
that can execute our config.ru:
\begin{verbatim}
web: bundle exec rackup config.ru -p $PORT
\end{verbatim}

\begin{verbatim}
[~/sinatra/rockpaperscissors(spec)]$ cat config.ru 
#\ -s puma
require './rps'
run RockPaperScissors::App
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\item 
This declares a single process type, \verb|web|, and the command needed
to run it. 
\item 
The name \verb|web| is important here. 
It declares that this
process type will be attached to the HTTP routing stack of Heroku,
and receive web traffic when deployed.
\end{enumerate}

\parrafo{Foreman}
\begin{enumerate}
\item 
It’s important when developing and debugging an application that
the local development environment is executed in the same manner
as the remote environments. 

\item 
This ensures that incompatibilities and
hard to find bugs are caught before deploying to production and
treats the application as a holistic unit instead of a series of
individual commands working independently.

\item 
Foreman is a command-line tool for running Procfile-backed apps.
It’s installed automatically by the Heroku Toolbelt.

\item 
If you had a Procfile with both web and worker process types, Foreman
will start one of each process type, with the output interleaved
on your terminal

\item 
We can now start our application locally using Foreman (installed as part of the Toolbelt):
\begin{verbatim}
$ foreman start
16:39:04 web.1     | started with pid 30728
18:49:43 web.1     | [2013-03-12 18:49:43] INFO  WEBrick 1.3.1
18:49:43 web.1     | [2013-03-12 18:49:43] INFO  ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-linux]
18:49:43 web.1     | [2013-03-12 18:49:43] INFO  WEBrick::HTTPServer#start: pid=30728 port=5000
\end{verbatim}
\item 
Our app will come up on port 5000. Test that it’s working with 
\verb|curl|
or a web browser, then \verb|Ctrl-C| to exit.
\end{enumerate}

\parrafo{Setting local environment variables}

Config vars saved in the \verb|.env| file of a project directory will be
added to the environment when run by Foreman. 

For example we can
set the \verb|RACK_ENV| to \verb|development| in your environment.
\begin{verbatim}
$ echo "RACK_ENV=development" >>.env
$ foreman run irb
> puts ENV["RACK_ENV"]
> development
\end{verbatim}
Do not commit the \verb|.env| file to source control.
It should only be used for local configuration.

\parrafo{Procfile y Despliegue}


Véase la descripción de los contenidos del Procfile en
\ref{parrafo:procfile}.

\begin{enumerate}
\item 
A Procfile is not necessary to deploy apps written in most languages
supported by Heroku. 

\item 
The platform automatically detects the language,
and creates a default web process type to boot the application
server.

\item 
Creating an explicit \verb|Procfile| is recommended for greater control and flexibility over your app.

\item 
For Heroku to use your Procfile, add the Procfile to the root of your application, then push to Heroku:

\begin{verbatim}
$ git add .
$ git commit -m "Procfile"
$ git push heroku
...
-----> Procfile declares process types: web, worker
       Compiled slug size is 10.4MB
-----> Launching... done
       http://strong-stone-297.herokuapp.com deployed to Heroku

To git@heroku.com:strong-stone-297.git
 * [new branch]      master -> master
\end{verbatim}
\end{enumerate}

\parrafo{Store your app in Git}

\begin{verbatim}
$ git init
$ git add .
$ git commit -m "init"
\end{verbatim}

\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ git remote -v
origin  git@github.com:crguezl/sinatra-rock-paper-scissors.git (fetch)
origin  git@github.com:crguezl/sinatra-rock-paper-scissors.git (push)
\end{verbatim}

\parrafo{Deploy your application to Heroku}

Create the app on Heroku:
\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ heroku create
Creating mysterious-falls-4594... done, stack is cedar
http://mysterious-falls-4594.herokuapp.com/ | git@heroku.com:mysterious-falls-4594.git
Git remote heroku added
\end{verbatim}

\begin{verbatim}
[~/sinatra/rockpaperscissors(spec)]$ cat Rakefile 
desc "start server using rackup ..."
task :default do
  sh "rackup"
end

require 'rspec/core/rake_task'

RSpec::Core::RakeTask.new do |task|
  task.rspec_opts = ["-c", "-f progress"] 
  task.pattern    = 'spec/**/*_spec.rb'
end
\end{verbatim}

\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ git remote -v
heroku  git@heroku.com:mysterious-falls-4594.git (fetch)
heroku  git@heroku.com:mysterious-falls-4594.git (push)
origin  git@github.com:crguezl/sinatra-rock-paper-scissors.git (fetch)
origin  git@github.com:crguezl/sinatra-rock-paper-scissors.git (push)
\end{verbatim}

Deploy your code:

\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ git push heroku master
Counting objects: 31, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (29/29), done.
Writing objects: 100% (31/31), 9.09 KiB, done.
Total 31 (delta 11), reused 0 (delta 0)

-----> Ruby/Rack app detected
-----> Installing dependencies using Bundler version 1.3.2
       Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
       Fetching gem metadata from https://rubygems.org/..........
       Fetching gem metadata from https://rubygems.org/..
       Installing tilt (1.4.1)
       Installing haml (4.0.3)
       Installing rack (1.5.2)
       Installing puma (2.0.1)
       Installing rack-protection (1.5.0)
       Installing sinatra (1.4.2)
       Using bundler (1.3.2)
       Your bundle is complete! It was installed into ./vendor/bundle
       Post-install message from haml:
       HEADS UP! Haml 4.0 has many improvements, but also has changes that may break
       your application:
       * Support for Ruby 1.8.6 dropped
       * Support for Rails 2 dropped
       * Sass filter now always outputs <style> tags
       * Data attributes are now hyphenated, not underscored
       * html2haml utility moved to the html2haml gem
       * Textile and Maruku filters moved to the haml-contrib gem
       For more info see:
       http://rubydoc.info/github/haml/haml/file/CHANGELOG.md
       Cleaning up the bundler cache.
-----> Discovering process types
       Procfile declares types     -> (none)
       Default types for Ruby/Rack -> console, rake, web

-----> Compiled slug size: 1.3MB
-----> Launching... done, v4
       http://mysterious-falls-4594.herokuapp.com deployed to Heroku

To git@heroku.com:mysterious-falls-4594.git
 * [new branch]      master -> master
[~/sinatra/rockpaperscissors(master)]$ 
\end{verbatim}

\parrafo{Visit your application}

You’ve deployed your code to Heroku, and specified the process types
in a Procfile. 

You can now instruct Heroku to execute a process
type. 

Heroku does this by running the associated command in a dyno
- a lightweight container which is the basic unit of composition
on Heroku.

Let’s ensure we have one dyno running the web process type:
\begin{verbatim}
$ heroku ps:scale web=1
\end{verbatim}
Veamos que dice la ayuda:
\begin{verbatim}
$ heroku help ps
Usage: heroku ps

 list processes for an app

Additional commands, type "heroku help COMMAND" for more details:

  ps:restart [PROCESS]           #  ps:restart [PROCESS]
  ps:scale PROCESS1=AMOUNT1 ...  #  ps:scale PROCESS1=AMOUNT1 ...
  ps:stop PROCESS                #  ps:stop PROCESS

$ heroku help ps:scale
Usage: heroku ps:scale PROCESS1=AMOUNT1 ...

 scale processes by the given amount

 Example: heroku ps:scale web=3 worker+1
\end{verbatim}

You can check the state of the app’s dynos. 
The heroku \verb|ps| command lists the running dynos of your application:
\begin{verbatim}
$ heroku ps
=== web: `bundle exec ruby web.rb -p $PORT`
web.1: up for 9m
\end{verbatim}
Here, one dyno is running.
\begin{verbatim}
[~/sinatra/sinatra-rock-paper-scissors/sinatra-rockpaperscissors(master)]$ heroku ps
Process  State        Command                               
-------  -----------  ------------------------------------  
web.1    idle for 8h  bundle exec rackup config.ru -p $P..  
\end{verbatim}

We can now visit the app in our browser with \verb|heroku open|.
\begin{verbatim}
[~/sinatra/rockpaperscissors(master)]$ heroku open
Opening http://mysterious-falls-4594.herokuapp.com/
[~/sinatra/rockpaperscissors(master)]$ 
\end{verbatim}


\begin{rawhtml}
<img src="sinatraenheroku.png">
\end{rawhtml}

\parrafo{Dyno sleeping and scaling}

\begin{enumerate}
\item 
Having only a single \red{web dyno} running will result in the dyno going
to sleep after one hour of inactivity. 

\item 
This causes a delay of a few
seconds for the first request upon waking. 

\item 
Subsequent requests will
perform normally.

\item 
To avoid this, you can scale to more than one \red{web dyno}. For example:
\begin{verbatim}
$ heroku ps:scale web=2
\end{verbatim}
\item 
For each application, Heroku provides 750 free dyno-hours. 

\item 
Running
your app at 2 dynos would exceed this free, monthly allowance, so
let’s scale back:
\begin{verbatim}
$ heroku ps:scale web=1
\end{verbatim}
\end{enumerate}

\parrafo{View the logs}

Heroku treats logs as streams of time-ordered events aggregated
from the output streams of all the dynos running the components of
your application. 

Heroku’s Logplex provides a single channel for
all of these events.

View information about your running app using one of the logging commands, heroku logs:
\begin{verbatim}
$ heroku logs
2013-03-13T04:10:49+00:00 heroku[web.1]: Starting process with command `bundle exec ruby web.rb -p 25410`
2013-03-13T04:10:50+00:00 app[web.1]: [2013-03-13 04:10:50] INFO  WEBrick 1.3.1
2013-03-13T04:10:50+00:00 app[web.1]: [2013-03-13 04:10:50] INFO  ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-linux]
2013-03-13T04:10:50+00:00 app[web.1]: [2013-03-13 04:10:50] INFO  WEBrick::HTTPServer#start: pid=2 port=25410
\end{verbatim}

\parrafo{\red{heroku run bash}}
Heroku allows you to run commands in a \cei{one-off dyno} 
- scripts and
applications that only need to be executed when needed - using the
\verb|heroku run| command. 

Since your app is - in general - 
spread across many dynos by the dyno manager, there
is no single place to SSH into. 

\blue{You deploy and manage apps, not servers}.

You can invoke a shell as a \blue{one-off dyno}.

While the \cei{web dyno} would be defined in the \verb|Procfile| 
and managed by
the platform, the console and script would only be executed when
needed. These are \cei{one-off dynos}.

There are differences between \blue{one-off dyno}s (run with heroku run) and formation dynos 

\begin{enumerate}
\item
\blue{One-off dyno}s run attached to your terminal, with a character-by-character
TCP connection for \verb|STDIN| and \verb|STDOUT|. 
This allows you to use interactive
processes like a console. 
\item
Since \verb|STDOUT| is going to your terminal, the
only thing recorded in the app’s logs is the startup and shutdown of
the dyno.
\item
\blue{One-off dyno}s terminate as soon as you press \verb|Ctrl-C| or otherwise
disconnect in your local terminal. 
\item
\blue{One-off dyno}s never automatically
restart, whether the process ends on its own or whether you manually
disconnect.
\item
\blue{One-off dyno}s are named in the scheme \verb|run.N| 
rather than the scheme \verb|<process-type>.N|.
\item
\blue{One-off dyno}s can never receive HTTP traffic, since the routers only
routes traffic to dynos named \verb|web.N|.
\end{enumerate}

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku run bash
Running `bash` attached to terminal... up, run.2966
~ $ uname -a
Linux 8f9f0a0c-b10d-4cd5-9c1e-8e87067b6be2 3.8.11-ec2 #1 SMP Fri May 3 09:11:15 UTC 2013 x86_64 GNU/Linux
[~/srcPLgrado/pegjscalc(master)]$ heroku run bash
Running `bash` attached to terminal... up, run.2966
~ $ ls -l
total 48
drwx------ 2 u20508 20508 4096 2014-03-24 11:23 bin
-rw------- 1 u20508 20508   42 2014-03-24 11:23 config.ru
-rw------- 1 u20508 20508  258 2014-03-24 11:23 Gemfile
-rw------- 1 u20508 20508 2399 2014-03-24 11:23 Gemfile.lock
-rw------- 1 u20508 20508 1152 2014-03-24 11:23 main.rb
-rw------- 1 u20508 20508   43 2014-03-24 11:23 Procfile
drwx------ 2 u20508 20508 4096 2014-03-24 11:23 public
-rw------- 1 u20508 20508  492 2014-03-24 11:23 Rakefile
-rw------- 1 u20508 20508  421 2014-03-24 11:23 README.md
drwx------ 2 u20508 20508 4096 2014-03-24 11:23 tmp
drwx------ 5 u20508 20508 4096 2014-03-24 11:23 vendor
drwx------ 2 u20508 20508 4096 2014-03-24 11:23 views
\end{verbatim}

\begin{verbatim}
~ $ ls -l tmp/
total 4
-rw------- 1 u20508 20508 242 2014-03-24 11:23 heroku-buildpack-release-step.yml
~ $ ls -l vendor
total 12
drwx------ 4 u20508 20508 4096 2014-03-20 23:33 bundle
drwx------ 2 u20508 20508 4096 2014-03-20 23:33 heroku
drwx------ 6 u20508 20508 4096 2014-03-24 11:23 ruby-2.0.0
\end{verbatim}

\begin{verbatim}
~ $ ls -l bin
total 0
lrwxrwxrwx 1 u20508 20508 28 2014-03-24 15:05 erb -> ../vendor/ruby-2.0.0/bin/erb
lrwxrwxrwx 1 u20508 20508 28 2014-03-24 15:05 gem -> ../vendor/ruby-2.0.0/bin/gem
lrwxrwxrwx 1 u20508 20508 28 2014-03-24 15:05 irb -> ../vendor/ruby-2.0.0/bin/irb
lrwxrwxrwx 1 u20508 20508 29 2014-03-24 15:05 rake -> ../vendor/ruby-2.0.0/bin/rake
lrwxrwxrwx 1 u20508 20508 29 2014-03-24 15:05 rdoc -> ../vendor/ruby-2.0.0/bin/rdoc
lrwxrwxrwx 1 u20508 20508 27 2014-03-24 15:05 ri -> ../vendor/ruby-2.0.0/bin/ri
lrwxrwxrwx 1 u20508 20508 29 2014-03-24 15:05 ruby -> ../vendor/ruby-2.0.0/bin/ruby
lrwxrwxrwx 1 u20508 20508 33 2014-03-24 15:05 ruby.exe -> ../vendor/ruby-2.0.0/bin/ruby.exe
lrwxrwxrwx 1 u20508 20508 31 2014-03-24 15:05 testrb -> ../vendor/ruby-2.0.0/bin/testrb
\end{verbatim}

\begin{itemize}
\item
The filesystem is ephemeral, and the dyno itself will only live as long as your console session.
\item
When running multiple dynos, apps are distributed across several nodes
by the dyno manager. 

\item
Access to your app always goes through the routers.
As a result, \red{dynos don’t have static IP addresses}. 

\item
While you can never connect to a dyno directly, it is possible to
originate outgoing requests from a dyno. 
However, you can count on the
dyno’s IP address changing as it gets restarted in different places.
\end{itemize}

\parrafo{\red{heroku run console}}

\begin{enumerate}
\item 
Heroku allows you to run commands in a \blue{one-off dyno} - scripts and
applications that only need to be executed when needed - using the
\verb|heroku run| command. 

\item 
You can use this to launch an interactive Ruby
shell (\verb|bundle exec irb|) attached to your local terminal for
experimenting in your app’s environment:
\begin{verbatim}
$ heroku run console
Running `console` attached to terminal... up, ps.1
irb(main):001:0>
\end{verbatim}
\item 
By default, \verb|irb| has nothing loaded other than the Ruby standard
library. From here you can require some of your application files.
Or you can do it on the command line:
\begin{verbatim}
$ heroku run console -r ./web
\end{verbatim}
\end{enumerate}

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku run irb
Running `irb` attached to terminal... up, run.1081
irb(main):001:0> ENV.keys
=> ["DATABASE_URL", "SHLVL", "PORT", "HOME", "HEROKU_POSTGRESQL_BROWN_URL", "PS1", "_", "COLUMNS", "RACK_ENV", "TERM", "PATH", "LANG", "GEM_PATH", "PWD", "LINES", "DYNO"]
irb(main):002:0> ENV["DATABASE_URL"]
=> "postgres://moiwgreelvvujc:GL3shXGOpURyWOPrS2G8qaxzUe@ec2-23-21-101-129.compute-1.amazonaws.com:5432/dat9smslrg6g0a"
irb(main):003:0> ENV["HEROKU_POSTGRESQL_BROWN_URL"]
=> "postgres://moiwgreelvvujc:GL3shXGOpURyWOPrS2G8qaxzUe@ec2-23-21-101-129.compute-1.amazonaws.com:5432/dat9smslrg6g0a"
irb(main):004:0> 
\end{verbatim}
Podemos cargar librerías de nuestra aplicación
(véase 
\htmladdnormallink{pegjscalc}{https://github.com/crguezl/pegjscalc}) 
y usarlas.
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku run console
Running `console` attached to terminal... up, run.9013
irb(main):002:0> require './main'
=> true
irb(main):003:0> p = PL0Program.all
=> [#<PL0Program @name="3p2m1" @source="                    3-2-1\r\n          ">, #<PL0Program @name="apbtc" @source="a+b*c">]
irb(main):005:0> chuchu = PL0Program.first(:name => "apbtc")
=> #<PL0Program @name="apbtc" @source="a+b*c">
irb(main):006:0> chuchu.source
=> "a+b*c"
irb(main):007:0> prog = PL0Program.create(:name => "tata", :source => "3*a-c")
=> #<PL0Program @name="tata" @source="3*a-c">
irb(main):008:0> 
\end{verbatim}


\parrafo{Rake}

Rake can be run in an attached dyno exactly like the console:
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku run rake -T
Running `rake -T` attached to terminal... up, run.2124
rake clean  # Remove pl0.pegjs
rake sass   # Compile public/styles.scss into public/styles.css using sass
rake test   # tests
rake web    # Compile pl0.pegjs browser version
[~/srcPLgrado/pegjscalc(master)]$ heroku run rake test
Running `rake test` attached to terminal... up, run.2082
Not implemented (yet)
\end{verbatim}

\parrafo{Using a SQL database}

By default, non-Rails apps aren’t given a SQL database. 

This is
because you might want to use a NoSQL database like 
Redis or CouchDB,
or you don’t need any
database at all. 

If you need a SQL database for your app, do this:
\begin{enumerate}
\item 
\begin{verbatim}
$ heroku addons:add heroku-postgresql:dev
\end{verbatim}
\item 
You must also add the Postgres gem to your app in order to use your
database. Add a line to your \verb|Gemfile| like this:
\begin{verbatim}
gem 'pg'
\end{verbatim}
\item 
You’ll also want to setup a local PostgreSQL database.
\end{enumerate}

\parrafo{Webserver}

By default your app (Rack) will use \verb|Webrick|. 

This is fine for
testing, but for production apps you’ll want to switch to a more
robust webserver. 

On Cedar, they  recommend \verb|Unicorn| as the webserver.


\section{Logging}
Heroku aggregates three categories of logs for your app:
\begin{enumerate}
\item 
App logs - Output from your application. 

This will include logs
generated from 
\begin{enumerate}
\item 
within your application, 
\item 
application server and
\item 
libraries. 
\end{enumerate}
(Filter: \verb|--source app|)
\item 
System logs - 

Messages about actions taken by the Heroku platform
infrastructure on behalf of your app, such as: 
\begin{enumerate}
\item 
restarting a crashed process, 
\item 
sleeping or waking a \red{web dyno}, or 
\item 
serving an error page
due to a problem in your app. 
\end{enumerate}
(Filter: \verb|--source heroku|)
\item 
API logs - 

Messages about administrative actions taken by you and
other developers working on your app, such as: 

\begin{enumerate}
\item 
deploying new code,
\item 
scaling the process formation, or 
\item 
toggling maintenance mode. 
\end{enumerate}
(Filter: \verb|--source heroku --ps api|)

\begin{verbatim}
[~/rack/rack-rock-paper-scissors(master)]$ heroku logs --source heroku --ps api
2013-10-23T21:33:41.105090+00:00 heroku[api]: Deploy 5ec1351 by chuchu.chachi.leon@gmail.com
2013-10-23T21:33:41.154690+00:00 heroku[api]: Release v7 created by chuchu.chachi.leon@gmail.com
\end{verbatim}
\end{enumerate}

Logplex is designed for collating and routing log messages, not for
storage. It keeps the last 1,500 lines of consolidated logs. 

Heroku recommends using a separate service for long-term log storage; see
Syslog drains for more information.

\parrafo{Writing to your log}

Anything written to standard out (stdout) or standard error (stderr)
is captured into your logs. This means that you can log from anywhere
in your application code with a simple output statement:
\begin{verbatim}
puts "Hello, logs!"
\end{verbatim}
To take advantage of the realtime logging, you may need to disable
any log buffering your application may be carrying out. For example,
in Ruby add this to your config.ru:
\begin{verbatim}
$stdout.sync = true
\end{verbatim}
Some frameworks send log output somewhere other than stdout by
default. 

\parrafo{To fetch your logs}
\begin{verbatim}
$ heroku logs
2010-09-16T15:13:46.677020+00:00 app[web.1]: Processing PostController#list (for 208.39.138.12 at 2010-09-16 15:13:46) [GET]
2010-09-16T15:13:46.677023+00:00 app[web.1]: Rendering template within layouts/application
2010-09-16T15:13:46.677902+00:00 app[web.1]: Rendering post/list
2010-09-16T15:13:46.678990+00:00 app[web.1]: Rendered includes/_header (0.1ms)
2010-09-16T15:13:46.698234+00:00 app[web.1]: Completed in 74ms (View: 31, DB: 40) | 200 OK [http://myapp.heroku.com/]
2010-09-16T15:13:46.723498+00:00 heroku[router]: at=info method=GET path=/posts host=myapp.herokuapp.com fwd="204.204.204.204" dyno=web.1 connect=1ms service=18ms status=200 bytes=975
2010-09-16T15:13:47.893472+00:00 app[worker.1]: 2 jobs processed at 16.6761 j/s, 0 failed ...
\end{verbatim}
In this example, the output includes log lines from one of the app’s
\red{web dyno}s, the Heroku HTTP router, and one of the app’s workers.

The logs command retrieves 100 log lines by default.

\parrafo{Log message ordering}

When retrieving logs, you may notice that the logs are not always
in order, especially when multiple components are involved. 

This
is likely an artifact of distributed computing. 

Logs originate from
many sources (router nodes, dynos, etc) and are assembled into a
single log stream by logplex. 

It is up to the logplex user to sort
the logs and provide the ordering required by their application,
if any

\parrafo{Log history limits}

You can fetch up to 1500 lines using the --num (or -n) option:
\begin{verbatim}
$ heroku logs -n 200
\end{verbatim}
Heroku only stores the last 1500 lines of log history. If you’d
like to persist more than 1500 lines, use a logging add-on or create
your own syslog drain\footnote{Logplex drains allow you to forward
your Heroku logs to an external syslog server for long-term archiving.
You must configure the service or your server to be able to receive
syslog packets from Heroku, and then add its syslog URL (which
contains the host and port) as a syslog drain.}.

\parrafo{Log format}

Each line is formatted as follows:
\begin{enumerate}
\item 
timestamp source[dyno]: message
\item 
Timestamp - The date and time recorded at the time the log line was produced by the dyno or component. The timestamp is in the format specified by RFC5424, and includes microsecond precision.
\item 
Source - 
  \begin{enumerate}
  \item 
  All of your app’s dynos (\red{web dyno}s, background workers, cron) have a source of app. 
  \item 
  All of Heroku’s system components (HTTP router, dyno manager) have a source of heroku.
  \end{enumerate}
\item 
Dyno - The name of the dyno or component that wrote this log line.
For example, \verb|worker #3| appears as \verb|worker.3|, and the Heroku HTTP
router appears as router.
\item 
Message - The content of the log line. Dynos can generate messages
up to approximately 1024 bytes in length and longer messages will
be truncated. 
\end{enumerate}

\parrafo{Realtime tail}

\begin{enumerate}
\item 
Similar to \verb|tail -f|, realtime tail displays recent logs and leaves
the session open for realtime logs to stream in. 
\item 
By viewing a live
stream of logs from your app, you can gain insight into the behavior
of your live application and debug current problems.
\item 
You may tail your logs using \verb|--tail| (or \verb|-t|).
\begin{verbatim}
$ heroku logs --tail
\end{verbatim}
When you are done, press Ctrl-C to close the session.
\end{enumerate}

\parrafo{Filtering}

If you only want to fetch logs with a certain source, a certain
dyno, or both, you can use the \verb|--source| (or \verb|-s|) and
\verb|--ps| (or \verb|-p|) filtering arguments:
\begin{verbatim}
$ heroku logs --ps router
2012-02-07T09:43:06.123456+00:00 heroku[router]: at=info method=GET path=/stylesheets/dev-center/library.css host=devcenter.heroku.com fwd="204.204.204.204" dyno=web.5 connect=1ms service=18ms status=200 bytes=13
2012-02-07T09:43:06.123456+00:00 heroku[router]: at=info method=GET path=/articles/bundler host=devcenter.heroku.com fwd="204.204.204.204" dyno=web.6 connect=1ms service=18ms status=200 bytes=20375
\end{verbatim}

\begin{verbatim}
$ heroku logs --source app
2012-02-07T09:45:47.123456+00:00 app[web.1]: Rendered shared/_search.html.erb (1.0ms)
2012-02-07T09:45:47.123456+00:00 app[web.1]: Completed 200 OK in 83ms (Views: 48.7ms | ActiveRecord: 32.2ms)
2012-02-07T09:45:47.123456+00:00 app[worker.1]: [Worker(host:465cf64e-61c8-46d3-b480-362bfd4ecff9 pid:1)] 1 jobs processed at 23.0330 j/s, 0 failed ...
2012-02-07T09:46:01.123456+00:00 app[web.6]: Started GET "/articles/buildpacks" for 4.1.81.209 at 2012-02-07 09:46:01 +0000
\end{verbatim}

\begin{verbatim}
$ heroku logs --source app --ps worker
2012-02-07T09:47:59.123456+00:00 app[worker.1]: [Worker(host:260cf64e-61c8-46d3-b480-362bfd4ecff9 pid:1)] Article#record_view_without_delay completed after 0.0221
2012-02-07T09:47:59.123456+00:00 app[worker.1]: [Worker(host:260cf64e-61c8-46d3-b480-362bfd4ecff9 pid:1)] 5 jobs processed at 31.6842 j/s, 0 failed ...
\end{verbatim}

When filtering by dyno, either the base name, \verb|--ps web|, or the full
name, \verb|--ps web.1|, may be used.

You can also combine the filtering switches with \verb|--tail| to get a
realtime stream of filtered output.
\begin{verbatim}
$ heroku logs --source app --tail
\end{verbatim}

\section{Heroku Postgress}

Véase \htmladdnormallink{Heroku Postgress}{https://devcenter.heroku.com/articles/heroku-postgresql}.

Heroku Postgres is the SQL database service run by Heroku that is
provisioned and managed as an add-on. 

Heroku Postgres is accessible
from any language with a PostgreSQL driver including all languages
and frameworks supported by Heroku: Java, Ruby, Python, Scala, Play,
Node.js and Clojure.

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku addons
=== pegjspl0 Configured Add-ons
heroku-postgresql:hobby-dev  HEROKU_POSTGRESQL_BROWN
\end{verbatim}

In addition to a variety of management commands available via the Heroku
CLI, Heroku Postgres features a 
\htmladdnormallink{web dashboard}{https://postgres.heroku.com/databases}, 
the ability to create
\htmladdnormallink{dataclips }{https://postgres.heroku.com/blog/past/2012/1/31/simple_data_sharing_with_data_clips/}
and several additional services on top of a fully managed
database service.

\begin{rawhtml}
<img src="herokudatabases.png" />
\end{rawhtml}

\parrafo{Provisioning the add-on}
Many 
\htmladdnormallink{buildpacks }{https://devcenter.heroku.com/articles/buildpacks}
(what compiles your application into a runnable entity on
Heroku) automatically provision a \red{Heroku Postgres instance for you}. 

Your
language’s buildpack documentation will specify if any add-ons are
automatically provisioned. 

Additionally, you can use \verb|heroku addons| 
to
see if your application already has a database provisioned and what plan
it is\footnote{In order for Heroku to manage this add-on for you and
respond to a variety of operational situations, the value of this config
var may change at any time. Relying on it outside your Heroku app may
prove problematic as you will have to re-copy the value on change.}.

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku addons
=== pegjspl0 Configured Add-ons
heroku-postgresql:hobby-dev  HEROKU_POSTGRESQL_BROWN
\end{verbatim}

If your application doesn’t yet have a database provisioned, or you
wish to 
\htmladdnormallink{upgrade your existing database}{https://devcenter.heroku.com/articles/upgrade-heroku-postgres-with-pgbackups}
 or 
\htmladdnormallink{create a master/slave setup,}{https://devcenter.heroku.com/articles/heroku-postgres-follower-databases}
you can create a new database using the CLI.

\parrafo{Create new db}
Heroku Postgres can be attached to a Heroku application via the 
CLI\footnote{Heroku Postgres has a variety of plans spread across two
general tiers of service – starter and production. Please understand the
different levels of service provided by database tiers when provisioning
the service. You can always upgrade databases should you outgrow your
initial plan.}:
\begin{verbatim}
$ heroku addons:add heroku-postgresql:dev
Adding heroku-postgresql:dev to sushi... done, v69 (free)
Attached as HEROKU_POSTGRESQL_RED
Database has been created and is available
\end{verbatim}

Once Heroku Postgres has been added a \verb|HEROKU_POSTGRESQL_COLOR_URL| 
setting
will be available in the app configuration and will contain the URL
used to access the newly provisioned Heroku Postgres service. 

This can
be confirmed using the \verb|heroku config| command.
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku config
=== pegjspl0 Config Vars
DATABASE_URL:                postgres://moiwgreelvvujc:GL3shXGOpURyWOPrS2G8qaxzUe@ec2-23-21-101-129.compute-1.amazonaws.com:5432/dat9smslrg6g0a
HEROKU_POSTGRESQL_BROWN_URL: postgres://moiwgreelvvujc:GL3shXGOpURyWOPrS2G8qaxzUe@ec2-23-21-101-129.compute-1.amazonaws.com:5432/dat9smslrg6g0a
LANG:                        en_US.UTF-8
PGBACKUPS_URL:               https://453643:cqz59jrxbbfcxj0fanhjfg0vz@pgbackups.herokuapp.com/client
RACK_ENV:                    production
\end{verbatim}

\parrafo{Establish primary DB}

Heroku recommends using the \verb|DATABASE_URL| config var to store
the location
of your primary database. 
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ head main.rb 
require 'sinatra'
require "sinatra/reloader" if development?
require 'sinatra/flash'
require 'data_mapper'
require 'pp'

# full path!
DataMapper.setup(:default, 
                 ENV['DATABASE_URL'] || "sqlite3://#{Dir.pwd}/database.db" )
\end{verbatim}

In single-database setups your new database
will have already been assigned a \verb|HEROKU_POSTGRESQL_COLOR_URL|
config with
the accompanying \verb|DATABASE_URL|. 

You may verify this via heroku config and
verifying the value of both \verb|HEROKU_POSTGRESQL_COLOR_URL| 
and \verb|DATABASE_URL|
which should match.

\parrafo{pg:info}

To see all PostgreSQL databases provisioned by your application and the
identifying characteristics of each 
(db size, status, number of tables, PG version, creation date etc…) 
use the \verb|heroku pg:info| command.

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku pg:info
=== HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)
Plan:        Hobby-dev
Status:      available
Connections: 0
PG Version:  9.3.3
Created:     2014-03-20 23:33 UTC
Data Size:   6.5 MB
Tables:      1
Rows:        4/10000 (In compliance)
Fork/Follow: Unsupported
Rollback:    Unsupported
\end{verbatim}

To continuously monitor the status of your database, pass pg:info through the unix watch command:
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ watch heroku pg:info
-bash: watch: no se encontró la orden
[~/srcPLgrado/pegjscalc(master)]$ brew install watch
[~/srcPLgrado/pegjscalc(master)]$ watch heroku pg:info
...
\end{verbatim}

\parrafo{pg:psql}
\verb|psql| is the native PostgreSQL interactive terminal and is used to execute queries and issue commands to the connected database.

To establish a \verb|psql| session 
with your remote database use \verb|heroku pg:psql|.
You must have PostgreSQL installed on your system to use heroku \verb|pg:psql|.


\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku pg:psql
---> Connecting to HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)
psql (9.2.6, server 9.3.3)
WARNING: psql version 9.2, server version 9.3.
         Some psql features might not work.
SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)
Type "help" for help.

pegjspl0::BROWN=> \dt
               List of relations
 Schema |     Name     | Type  |     Owner      
--------+--------------+-------+----------------
 public | pl0_programs | table | moiwgreelvvujc
(1 row)

pegjspl0::BROWN=> 
pegjspl0::BROWN=> SELECT * FROM pl0_programs;
  name  |           source            
--------+-----------------------------
 3m2m1  |                     3-2-1\r+
        |           
 ap1tb  | a+1*b\r                    +
        |           
 test   |                     a+1*b\r+
        |           \r               +
        |           
 lolwut |                     3-2-1\r+
        |           
(4 rows)
\end{verbatim}


If you have more than one database, specify the database to connect to as
the first argument to the command (the database located at \verb|DATABASE_URL|
is used by default).
\begin{verbatim}
$ heroku pg:psql HEROKU_POSTGRESQL_GRAY
Connecting to HEROKU_POSTGRESQL_GRAY... done
...
\end{verbatim}

\parrafo{pg:reset}
 To drop and recreate your database use \verb|pg:reset|:

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku pg:reset DATABASE

 !    WARNING: Destructive Action
 !    This command will affect the app: pegjspl0
 !    To proceed, type "pegjspl0" or re-run this command with --confirm pegjspl0

> pegjspl0
Resetting HEROKU_POSTGRESQL_BROWN_URL (DATABASE_URL)... done
\end{verbatim}
Es necesario a continuación rearrancar el servidor:
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku ps:restart
Restarting dynos... done
\end{verbatim}


\parrafo{pg:pull}
\verb|pg:pull| can be used to pull remote data from a Heroku Postgres
database to a database on your local machine. The command looks like this:
\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start
server starting
\end{verbatim}

\begin{verbatim}
$ heroku pg:pull HEROKU_POSTGRESQL_MAGENTA mylocaldb --app sushi
\end{verbatim}
This command will create a new local database named \verb|mylocaldb| and
then pull data from database at \verb|DATABASE_URL| from the app 
\verb|sushi|. 

In
order to prevent accidental data overwrites and loss, the local database
must not exist. You will be prompted to drop an already existing local
database before proceeding.

\parrafo{pg:push}
Like pull but in reverse, \verb|pg:push| will push data from a local
database into a remote Heroku Postgres database. The command looks
like this:
\begin{verbatim}
$ heroku pg:push mylocaldb HEROKU_POSTGRESQL_MAGENTA --app sushi
\end{verbatim}
This command will take the local database \verb|mylocaldb| 
and push it
to the database at \verb|DATABASE_URL| on the app \verb|sushi|. 
In order to
prevent accidental data overwrites and loss, the remote database must
be empty. You will be prompted to \verb|pg:reset| an already a remote database
that is not empty.


\section{Troubleshooting}

\subsection{Crashing}
If you push your app and it crashes, 
\verb|heroku ps| shows state crashed:
\begin{verbatim}
=== web (1X): `bundle exec thin start -R config.ru -e $RACK_ENV -p $PORT`
web.1: crashed 2013/10/24 20:21:34 (~ 1h ago)
\end{verbatim}
check your logs to find out what went wrong. 

Here are some common
problems.

\parrafo{Failed to require a sourcefile}

If your app failed to require a sourcefile, chances are good you’re
running Ruby 1.9.1 or 1.8 in your local environment. 

The load paths
have changed in Ruby 1.9 which applies to Ruby 2.0. 

Port your app
forward to Ruby 2.0.0 making certain it works locally before trying
to push to Cedar again.

\parrafo{Encoding error}
Ruby 1.9 added more sophisticated encoding support to the language
which applies to Ruby 2.0. 

Not all gems work with Ruby 2.0. If you
hit an encoding error, you probably haven’t fully tested your app
with Ruby 2.0.0 in your local environment. 

Port your app forward
to Ruby 2.0.0 making certain it works locally before trying to push
to Cedar again.

\parrafo{Missing a gem}

If your app crashes due to missing a gem, you may have it installed
locally but not specified in your Gemfile. 

You must isolate all
local testing using \verb|bundle exec|. 

For example, don’t run \verb|ruby web.rb|,
run 

\begin{verbatim}
bundle exec ruby web.rb
\end{verbatim}
Don’t run \verb|rake db:migrate|, run 
\begin{verbatim}
bundle exec rake db:migrate.
\end{verbatim}
Another approach is to create a blank RVM gemset to be absolutely
sure you’re not touching any system-installed gems:
\begin{verbatim}
$ rvm gemset create myapp
$ rvm gemset use myapp
\end{verbatim}

\parrafo{Runtime dependencies on development/test gems}

If you’re still missing a gem when you deploy, check your Bundler
groups.

Heroku builds your app without the \verb|development| or \verb|test|
groups, and if you app depends on a gem from one of these groups
to run, you should move it out of the group.

One common example using the \verb|RSpec tasks| in your Rakefile. 
If you see this in your Heroku deploy:
\begin{verbatim}
$ heroku run rake -T
Running `rake -T` attached to terminal... up, ps.3
rake aborted!
no such file to load -- rspec/core/rake_task
\end{verbatim}
Then you’ve hit this problem. 

First, duplicate the problem locally like so:
\begin{verbatim}
$ bundle install --without development:test
...
$ bundle exec rake -T
rake aborted!
no such file to load -- rspec/core/rake_task
\end{verbatim}
Now you can fix it by making these Rake tasks conditional on the gem load. 
For example:
\begin{verbatim}
begin
  require "rspec/core/rake_task"

  desc "Run all examples"
  RSpec::Core::RakeTask.new(:spec) do |t|
    t.rspec_opts = %w[--color]
    t.pattern = 'spec/*_spec.rb'
  end
rescue LoadError
end
\end{verbatim}
Confirm it works locally, then push to Heroku.

\parrafo{Versiones soportadas por Heroku}

Véase
\htmladdnormallink{Heroku Ruby Support}{https://devcenter.heroku.com/articles/ruby-support\#ruby-versions}

\parrafo{Rack::Sendfile}

Heroku does not support the use of Rack::Sendfile. 

Rack:Sendfile
usually requires that there is a frontend webserver like nginx or
apache is running on the same machine as the application server.

This is not how Heroku is architected. Using the Rack::Sendfile
middleware will cause your file downloads to fail since it will
send a body with Content-Length of 0.

\subsection{\red{heroku run}: Timeout awaiting process}

The \red{heroku run command opens a connection to Heroku on port 5000}. If
your local network or ISP is blocking port 5000 (el caso de la ULL), 
or you are experiencing
a connectivity issue, you will see an error similar to:

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ heroku run console
Running `console` attached to terminal... up, run.4357
 !    
 !    Timeout awaiting process
\end{verbatim}

You can test your connection to Heroku by trying to connect directly to
port 5000 by using \verb|telnet| to \verb|rendezvous.runtime.heroku.com|. 

Desde la universidad fracasa:

\begin{verbatim}
[~/srcPLgrado/pegjscalc(master)]$ telnet rendezvous.runtime.heroku.com 5000Trying 50.19.103.36...
telnet: connect to address 50.19.103.36: Operation timed out
telnet: Unable to connect to remote host
\end{verbatim}

A successful session will look like this:

\begin{verbatim}
$ telnet rendezvous.runtime.heroku.com 5000
Trying 50.19.103.36...
Connected to ec2-50-19-103-36.compute-1.amazonaws.com.
Escape character is '^]'.
\end{verbatim}
If you do not get this output, your computer is being blocked from
accessing our services. We recommend contacting your IT department, ISP,
or firewall manufacturer to move forward with this issue.

\section{Configuration}
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku help config 
Usage: heroku config

 display the config vars for an app

 -s, --shell  # output config vars in shell format

Examples:

 $ heroku config
 A: one
 B: two

 $ heroku config --shell
 A=one
 B=two

Additional commands, type "heroku help COMMAND" for more details:

  config:get KEY                            #  display a config value for an app
  config:set KEY1=VALUE1 [KEY2=VALUE2 ...]  #  set one or more config vars
  config:unset KEY1 [KEY2 ...]              #  unset one or more config vars
\end{verbatim}

\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku config -s
DATABASE_URL=postgres://bhhatrhjjhwcvt:hjgjfhgjfhjfuWH7ls_PJKK5QD@ec2-54-204-35-132.compute-1.amazonaws.com:5999/d2888888888888
HEROKU_POSTGRESQL_BLACK_URL=postgres://bhjshfdhakwcvt:hQssnhq1y1jhgfhgls_PGNu5QD@ec2-54-204-35-132.compute-1.amazonaws.com:9999/d555555555555j
\end{verbatim}

\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku config:set C=4
Setting config vars and restarting crguezl-songs... done, v6
C: 4
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku config:get C
4
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku config:unset C
Unsetting C and restarting crguezl-songs... done, v7
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku config:get C

[~/sinatra/sinatra-datamapper-jump-start(master)]$]]
\end{verbatim}

\section{Make Heroku run non-master Git branch}

\htmladdnormallink{Make Heroku run non-master Git branch}{http://stackoverflow.com/questions/14593538/make-heroku-run-non-master-git-branch}
You can push an alternative branch to Heroku using Git.
\begin{verbatim}
git push heroku-dev test:master
\end{verbatim}
This pushes your local test branch to the remote's master branch (on Heroku).

El manual de \verb1git push1 dice:

To push a local branch to an established remote, you need to issue the command:
\begin{verbatim}
git push  <REMOTENAME> <BRANCHNAME> 
\end{verbatim}
This is most typically invoked as \verb|git push origin master|. 

If you
would like to give the branch a different name on the upstream side
of the push, you can issue the command:

\begin{verbatim}
git push  <REMOTENAME> <LOCALBRANCHNAME>:<REMOTEBRANCHNAME> 
\end{verbatim}

\section{Account Verification and add-ons}
You must verify your account by adding a credit card before you can
add any add-on to your app other than \verb|heroku-postgresql:dev| and
\verb|pgbackups:plus|.

Adding a credit card to your account lets you 

\begin{enumerate}
\item 
use the free
add-ons, 
\item 
allows your account to have more than 5 apps at a time
(verified accounts may have up to 100 apps),
\item 
 and gives you access
to turn on paid services any time with a few easy clicks.
\item 
The easiest way to do this is to go to 
\htmladdnormallink{your account page}{https://dashboard.heroku.com/account}
and click
\verb|Add Credit Card|. 
\item 
Alternatively, when you attempt to perform an
action that requires a credit card, either from the Heroku CLI or
through the web interface, you will be prompted to visit the credit
card page.
\begin{verbatim}
[~/sinatra/sinatra-datamapper-jump-start(master)]$ heroku addons:add rediscloud:20
Adding rediscloud:20 on dgjgxcl-songs... failed
 !    Please verify your account to install this add-on
 !    For more information, see http://devcenter.heroku.com/categories/billing
 !    Verify now at https://heroku.com/verify
\end{verbatim}
\end{enumerate}


\section{Véase}
\begin{itemize}
\item 
\htmladdnormallink{Heroku: Getting Started with Ruby on Heroku}{https://devcenter.heroku.com/articles/getting-started-with-ruby}
\item 
\htmladdnormallink{SitePoint: Get Started with Sinatra on Heroku by Jagadish Thaker.
Published August 12, 2013}{http://www.sitepoint.com/get-started-with-sinatra-on-heroku/}
\item
\htmladdnormallink{Deploying Rack-based Apps}{https://devcenter.heroku.com/articles/rack}
\item 
\htmladdnormallink{Heroku: List of Published Articles for Ruby}{https://devcenter.heroku.com/categories/ruby}
\item Foreman
\begin{enumerate}
\item 
\htmladdnormallink{Introducing Foreman}{http://blog.daviddollar.org/2011/05/06/introducing-foreman.html}
by David Dollar
\item 
\htmladdnormallink{Foreman man pages}{http://ddollar.github.io/foreman/}
\item 
\htmladdnormallink{Applying the Unix Process Model to Web Apps}{http://adam.heroku.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/} by Adam Wiggins
\end{enumerate}
\item
\htmladdnormallink{Ruby Kickstart - Session 6 de Joshua Cheek}{https://vimeo.com/25814869} (Vimeo)
\item
\htmladdnormallink{sinatra-rock-paper-scissors}{https://github.com/crguezl/sinatra-rock-paper-scissors}
\item 
\htmladdnormallink{The Procfile is your friend}{http://www.neilmiddleton.com/the-procfile-is-your-friend/}
13 January, 2012. Neil Middleton
\end{itemize}
