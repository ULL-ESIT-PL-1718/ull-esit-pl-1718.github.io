
\section{Conceptos Básicos para el Análisis Sintáctico}
\label{section:conceptos}
Suponemos que el lector de esta sección ha realizado con éxito
un curso en teoría de autómatas y lenguajes formales (computabilidad).
Las siguientes definiciones repasan los conceptos mas importantes.

\begin{definition}
Dado un conjunto $A$, se define $A^*$ el cierre de Kleene de $A$ como:
\begin{math}
A^* = \cup_{n=0}^{\infty} A^n
\end{math}

Se admite que $A^0 = \{ \epsilon \}$, donde $\epsilon$ denota la palabra vacía, esto es
la palabra que tiene longitud cero, formada por cero símbolos del conjunto base $A$.
\end{definition}

\begin{definition}
Una gramática $G$ es una cuaterna $G =(\Sigma,V,P,S)$. 
$\Sigma$ es el conjunto de terminales. $V$ es un conjunto (disjunto de $\Sigma$)
que se denomina conjunto de \emph{variables sintácticas} o \emph{categorías gramáticales},
P es un conjunto de pares de $V \times (V \cup \Sigma )^*$. En vez de escribir
un par usando la notación $(A, \alpha) \in P$ se escribe $A \rightarrow \alpha$.
Un elemento de $P$ se denomina producción. Por último, $S$ es un símbolo del conjunto
$V$ que se denomina símbolo de arranque.
\end{definition}

\begin{definition}
Dada una gramática $G=(\Sigma,V,P,S)$ y $\mu = \alpha A \beta \in (V \cup \Sigma)^*$
una frase formada por variables y terminales y $A \rightarrow \gamma$ una producción de 
$P$, decimos que  $\mu$ deriva en un paso en  $\alpha \gamma \beta$. Esto es, derivar 
una cadena $\alpha A \beta$ es sustituir 
una variable sintáctica $A$ de $V$ por la parte derecha $\gamma$ de una de sus reglas de producción.
Se dice que $\mu$ deriva en $n$ pasos en $\delta$ si deriva en $n-1$ pasos en una cadena
$\alpha A \beta$ la cual deriva en un paso en $\delta$. Se escribe entonces
que $\mu  \stackrel{*}{\Longrightarrow}  \delta$. Una cadena deriva en 0 pasos en si misma.

\end{definition}

\begin{definition}
\label{definition:lenguajegenerado}
Dada una gramática $G=(\Sigma,V,P,S)$ se denota por $L(G)$ o lenguaje
generado por $G$ al lenguaje:

\begin{center}
$L(G) = \{ x \in \Sigma^* : S \stackrel{*}{\Longrightarrow} x \}$
\end{center}

Esto es, el lenguaje generado por la gramática $G$ esta formado por las cadenas
de terminales que pueden ser derivados desde el símbolo de arranque.
\end{definition}

\begin{definition}
Una derivación que comienza en el símbolo de arranque y termina en una secuencia
formada por sólo terminales de $\Sigma$ se dice \emph{completa}.

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $\alpha A x$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la derecha se dice \emph{una derivación a derechas}

Una derivación $\mu  \stackrel{*}{\Longrightarrow}  \delta$ 
en la cual en cada paso $x A \alpha$ la regla de producción aplicada $A \rightarrow \gamma$
se aplica en la variable sintáctica mas a la izquierda se dice \emph{una derivación a izquierdas}
\end{definition}

\begin{definition}
Observe que una derivación puede ser representada como un árbol cuyos nodos
están etiquetados en $V \cup \Sigma$. La aplicación de la regla de 
producción $A \rightarrow \gamma$ se traduce en asignar como hijos del nodo etiquetado con $A$
a los nodos etiquetados con los símbolos $X_1 \ldots X_n$ que constituyen
la frase $\gamma = X_1 \ldots X_n$.  
Este árbol se llama \cei{árbol sintáctico concreto} asociado 
con la derivación.
\end{definition}

\begin{definition}
\label{definition:arbolconcreto}
Observe que, dada una frase $x \in L(G)$ una derivación desde el
símbolo de arranque da lugar a  un árbol. Ese árbol tiene como raíz el 
símbolo de arranque y como hojas los terminales 
$x_1 \ldots x_n$ que forman $x$. Dicho árbol se denomina \emph{árbol
de análisis sintáctico concreto} de $x$. Una derivación determina
una forma de recorrido del árbol de análisis sintáctico concreto.
\end{definition}

\begin{definition}
Una gramática $G$ se dice ambigua si existe alguna frase $x \in L(G)$
con al menos dos árboles sintácticos. 
Es claro que esta definición es equivalente a afirmar que existe 
alguna frase $x \in L(G)$ para la cual existen dos derivaciones a 
izquierda (derecha) distintas.
\end{definition}

\subsection{Ejercicio}
\label{ejercicio:tutugrammar}
Dada la gramática con producciones:

\vspace{0.5cm}
\begin{tabular}{l}
program      $\rightarrow$  declarations  statements         $|$ statements\\
declarations $\rightarrow$ declaration  ';'  declarations    $|$ declaration ';'\\
declaration  $\rightarrow$ INT  idlist                       $|$ STRING   idlist\\
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM $|$ STR\\
idlist       $\rightarrow$ ID ',' idlist $|$ ID
\end{tabular}
\vspace{0.25cm}

En esta gramática, $\Sigma$ esta formado por los caracteres entre comillas simples y 
los símbolos cuyos identificadores están en mayúsculas. Los restantes identificadores
corresponden a elementos de $V$. El símbolo de arranque es $S =$ program.

Conteste a las siguientes cuestiones:

\begin{enumerate}
\item
Describa con palabras el lenguaje generado.
\item
\label{ejer:arbol}
Construya el árbol de análisis sintáctico
concreto para cuatro frases del lenguaje.
\item
Señale a que recorridos del árbol corresponden las respectivas
derivaciones a izquierda y a derecha en el apartado \ref{ejer:arbol}.
\item
¿Es ambigua esta gramática?. Justifique su respuesta.
\end{enumerate}

\section{Análisis Sintáctico Predictivo Recursivo}
\label{section:predictivo}
La siguiente fase en la construcción del analizador es la fase de 
análisis sintáctico. Esta toma como entrada el flujo de terminales
y construye como salida el árbol de análisis sintáctico abstracto.

El árbol de análisis sintáctico abstracto es una representación  compactada del árbol 
de análisis sintáctico concreto que contiene la misma información que éste.

Existen diferentes métodos de análisis sintáctico. La mayoría caen en una de dos categorías:
ascendentes y descendentes. Los ascendentes construyen el árbol desde las hojas
hacia la raíz. Los descendentes lo hacen en modo inverso. El que describiremos
aqui es uno de los mas sencillos: se denomina método de análisis predictivo descendente 
recursivo.

\subsection{Introducción}
\label{subsection:introduccion}
En este método se asocia una subrutina con cada variable sintáctica $A \in V$. Dicha subrutina 
(que llamaremos \verb|A|) reconocerá el lenguaje generado desde la variable $A$:

\begin{center}
$L_A(G) = \{ x \in \Sigma^* : A \stackrel{*}{\Longrightarrow} x \}$
\end{center}

En este método se escribe una rutina \verb|A| por variable sintáctica $A \in V$. 
Se le da a la rutina asociada el mismo nombre que a la variable sintáctica
asociada. 

La función de la rutina \verb|A| asociada con la variable
$A \in V$ es reconocer el lenguaje $L(A)$ generado por $A$.

La estrategia general que sigue la rutina \verb|A| para reconocer
$L(A)$ es decidir en términos del terminal $a$ en la entrada
que regla de producción concreta $A \rightarrow \alpha$ se aplica para
a continuación comprobar que la entrada que sigue pertenece al lenguaje generado por 
$\alpha$. 

En un analizador predictivo descendente recursivo (APDR) se asume que
el símbolo que actualmente
esta siendo observado (denotado habitualmente como 
\verb|lookahead|) permite determinar unívocamente
que producción de $A$ hay que aplicar. 

Una vez que se ha determinado que la regla por la que continuar la derivación
es $A \rightarrow \alpha$ se procede a reconocer $L_{\alpha}(G)$,
el lenguaje generado por $\alpha$. Si $\alpha = X_1 \ldots X_n$,
las apariciones de terminales $X_i$ en $\alpha$ son emparejadas
con los terminales en la entrada mientras que las apariciones de variables $X_i = B$
en $\alpha$ se traducen en llamadas a la correspondiente subrutina asociada con \verb|B|.

\parrafo{Ejemplo}

Para ilustrar el método,
simplificaremos la gramática presentada en el ejercicio
\ref{ejercicio:tutugrammar} eliminando las declaraciones:


\begin{table}
\begin{center}
\vspace{0.25cm}
\begin{tabular}{|l|}
statements   $\rightarrow$ statement  ';'  statements        $|$ statement\\
statement    $\rightarrow$ ID '=' expression                 $|$ P  expression\\
expression   $\rightarrow$ term '+' expression               $|$ term\\
term         $\rightarrow$ factor '*' term                   $|$ factor\\
factor       $\rightarrow$ '(' expression ')' $|$ ID $|$ NUM
\end{tabular}
\end{center}
\label{table:gramaticasimple}
\caption{Una Gramática Simple}
\end{table}
\vspace{0.25cm}

La secuencia de llamadas cuando se procesa la entrada mediante 
el siguiente programa construye \red{implícitamente} el \cei{árbol 
de análisis sintáctico concreto}.

Escribiremos el analizador en 
\htmladdnormallink{CoffeeScript}{http://coffeescript.org/}.
Véase 
\ref{chapter:coffeescript}.

\begin{verbatim}
parse = (input) ->
  tokens = input.tokens()
  lookahead = tokens.shift()
  match = (t) ->
    if lookahead.type is t
      lookahead = tokens.shift()
      lookahead = null  if typeof lookahead is "undefined"
    else # Error. Throw exception
      throw "Syntax Error. Expected #{t} found '" + 
            lookahead.value + "' near '" + 
            input.substr(lookahead.from) + "'"
    return

  statements = ->
    result = [statement()]
    while lookahead and lookahead.type is ";"
      match ";"
      result.push statement()
    (if result.length is 1 then result[0] else result)

  statement = ->
    result = null
    if lookahead and lookahead.type is "ID"
      left =
        type: "ID"
        value: lookahead.value

      match "ID"
      match "="
      right = expression()
      result =
        type: "="
        left: left
        right: right
    else if lookahead and lookahead.type is "P"
      match "P"
      right = expression()
      result =
        type: "P"
        value: right
    else # Error!
      throw "Syntax Error. Expected identifier but found " + 
        (if lookahead then lookahead.value else "end of input") + 
        " near '#{input.substr(lookahead.from)}'"
    result

  expression = ->
    result = term()
    if lookahead and lookahead.type is "+"
      match "+"
      right = expression()
      result =
        type: "+"
        left: result
        right: right
    result

  term = ->
    result = factor()
    if lookahead and lookahead.type is "*"
      match "*"
      right = term()
      result =
        type: "*"
        left: result
        right: right
    result

  factor = ->
    result = null
    if lookahead.type is "NUM"
      result =
        type: "NUM"
        value: lookahead.value

      match "NUM"
    else if lookahead.type is "ID"
      result =
        type: "ID"
        value: lookahead.value

      match "ID"
    else if lookahead.type is "("
      match "("
      result = expression()
      match ")"
    else # Throw exception
      throw "Syntax Error. Expected number or identifier or '(' but found " + 
        (if lookahead then lookahead.value else "end of input") + 
        " near '" + input.substr(lookahead.from) + "'"
    result

  tree = statements(input)
  if lookahead?
    throw "Syntax Error parsing statements. " + 
      "Expected 'end of input' and found '" + 
      input.substr(lookahead.from) + "'"  
  tree
\end{verbatim}

\begin{verbatim}
  var parse = function(input) {
    var tokens = input.tokens();
    var lookahead = tokens.shift();

    var match = function(t) {
      if (lookahead.type === t) {
        lookahead = tokens.shift();
        if (typeof lookahead === 'undefined') {
         lookahead = null; // end of input
        } 
      } else { // Error. Throw exception
          throw "Syntax Error. Expected "+t+" found '"+lookahead.value+
                "' near '"+input.substr(lookahead.from)+"'";
      }
    };

    var statements = function() {
      var result = [ statement() ];
      while (lookahead && lookahead.type === ';') {
        match(';');
        result.push(statement());
      }
      return result.length === 1? result[0] : result;
    };

    var statement = function() {
      var result = null;

      if (lookahead && lookahead.type === 'ID') {
        var left = { type: 'ID', value: lookahead.value };
        match('ID');
        match('=');
        right = expression();
        result = { type: '=', left: left, right: right };
      } else if (lookahead && lookahead.type === 'P') {
        match('P');
        right = expression();
        result = { type: 'P', value: right };
      } else { // Error!
        throw "Syntax Error. Expected identifier but found "+
              (lookahead? lookahead.value : "end of input")+
              " near '"+input.substr(lookahead.from)+"'";
      }
      return result;
    };

    var expression = function() {
      var result = term();
      if (lookahead && lookahead.type === '+') { 
        match('+');
        var right = expression();
        result = {type: '+', left: result, right: right};
      }
      return result;
    };

    var term = function() {
      var result = factor();
      if (lookahead && lookahead.type === '*') { 
        match('*');
        var right = term();
        result = {type: '*', left: result, right: right};
      }
      return result;
    };

    var factor = function() {
      var result = null;

      if (lookahead.type === 'NUM') { 
        result = {type: 'NUM', value: lookahead.value};
        match('NUM'); 
      }
      else if (lookahead.type === 'ID') {
        result = {type: 'ID', value: lookahead.value};
        match('ID');
      }
      else if (lookahead.type === '(') {
        match('(');
        result = expression();
        match(')');
      } else { // Throw exception
        throw "Syntax Error. Expected number or identifier or '(' but found "+
              (lookahead? lookahead.value : "end of input")+
              " near '"+input.substr(lookahead.from)+"'";
      }
      return result;
    };
    var tree = statements(input);
    if (lookahead != null) {
        throw "Syntax Error parsing statements. Expected end of input and found '"+
              input.substr(lookahead.from)+"'";
    }
    return tree;
  }
\end{verbatim}

\parrafo{Caracterización de las Gramáticas Analizables}
Como vemos en el ejemplo, el análisis predictivo confía en que, si estamos
ejecutando la entrada del procedimiento \verb|A|,
el cuál está asociado con la variable $A \in V$, el símbolo terminal
que esta en la entrada $a$  determine de manera unívoca la regla
de producción $A \rightarrow a \alpha$ que debe ser procesada.

Si se piensa, esta condición requiere que todas las partes derechas $\alpha$ de
las reglas $A \rightarrow \alpha$ de $A$ \red{comiencen} por diferentes símbolos.
Para formalizar esta idea, introduciremos el concepto de
conjunto $FIRST(\alpha)$:

\begin{definition}
Dada una gramática 
$G=(\Sigma,V,P,S)$ y un símbolo $\alpha \in (V \cup \Sigma)^*$ se define el conjunto 
$FIRST(\alpha)$ como:

$FIRST(\alpha) = \left \{ b \in \Sigma :  \alpha  \stackrel{*}{\Longrightarrow}  b \beta \right \}
\cup N(\alpha)$ 

\noindent donde:

$N(\alpha) = \left \{ \begin{array}{ll}
                         \left \{ \epsilon \right \}& \mbox{si $\alpha \stackrel{*}{\Longrightarrow} \epsilon$} \\
                         \emptyset & \mbox{en otro caso} 
                      \end{array}
             \right. $ 

\end{definition}


Podemos reformular ahora nuestra afirmación anterior en estos términos:
Si $A \rightarrow \gamma_1 \mid \ldots \mid \gamma_n$ y los conjuntos $FIRST(\gamma_i)$ son 
disjuntos podemos construir el procedimiento para la variable $A$ siguiendo
este seudocódigo:

\begin{verbatim}
A = function() {
  if (lookahead in FIRST(gamma_1)) { imitar gamma_1 }
  else if (lookahead in FIRST(gamma_2)) { imitar gamma_2 }
  ...
  else (lookahead in FIRST(gamma_n)) { imitar gamma_n }
}
\end{verbatim}

Donde si $\gamma_j$ es $X_1 \ldots X_k$ el código \verb|gamma_j| consiste
en una secuencia $i = 1 \ldots k$ de llamadas de uno de estos dos tipos:
\begin{itemize}
\item
Llamar a la subrutina \verb|X_i| si $X_i$ es una variable sintáctica
\item
Hacer una llamada a \verb|match(X_i)| si $X_i$ es un terminal
\end{itemize}

\subsectionejercicio{Recorrido del árbol en un ADPR}
¿En que forma es recorrido el árbol de análisis sintáctico concreto en un 
analizador descendente predictivo recursivo? ¿En que orden son visitados los nodos?

\section{Recursión por la Izquierda}
\label{section:recursionizquierda}

\begin{definition}
Una \cei{gramática es recursiva por la izquierda} cuando existe una derivación
$A \stackrel{*}{\Longrightarrow} A \alpha$. 

En particular, es recursiva por la izquierda si contiene
una regla de producción de la forma $A \rightarrow A \alpha$. 
En este caso se dice que la recursión por la izquierda es directa.
\end{definition}

Cuando la gramática es \cei{recursiva por la izquierda}, 
el método 
de análisis recursivo descendente predictivo no funciona. 
En ese caso, el procedimiento
\verb|A| asociado con $A$ ciclaría para siempre sin llegar a consumir ningún 
terminal. 


\section{Esquemas de Traducción}
\label{section:esquemas}
\begin{definition}
Un \cei{esquema de traducción} es una gramática independiente del contexto
en la cual se han insertado fragmentos de código en las partes derechas
de sus reglas de producción. Los fragmentos de código asi insertados 
se denominan \cei{acciones semánticas}. Dichos fragmentos actúan, calculan
y modifican los atributos asociados con los nodos del árbol sintáctico. 
El orden en que se evalúan los fragmentos
es el de un recorrido primero-profundo del árbol de análisis sintáctico.
\end{definition}
Obsérvese que, en general, para poder aplicar un esquema de traducción hay 
que construir el árbol sintáctico y después aplicar las acciones empotradas
en las reglas en el orden de recorrido primero-profundo. Por supuesto, si 
la gramática es ambigua una frase podría tener dos árboles y la ejecución de las
acciones para ellos podría dar lugar a diferentes resultados. Si se quiere
evitar la multiplicidad de resultados (interpretaciones semánticas)
es necesario precisar de que árbol sintáctico concreto se esta hablando.

Por ejemplo, si en la regla $A \rightarrow \alpha \beta $
insertamos un fragmento de código:

\begin{center}
$A \rightarrow \alpha \{ action \} \beta $
\end{center}

La acción $\{ action \}$ se ejecutará después de todas las acciones
asociadas con el recorrido del subárbol de $\alpha$ y antes que todas
las acciones asociadas con el recorrido del subárbol $\beta$.

El siguiente esquema de traducción recibe como entrada una expresión en infijo
y produce como salida su traducción a postfijo para expresiones aritmeticas con sólo 
restas de números:

\vspace{0.5cm}
\begin{tabular}{ll}
$expr   \rightarrow expr_1  -  NUM$  & \verb|{ expr.TRA = expr[1].TRA+" "+NUM.VAL+" - "}| \\
$expr   \rightarrow NUM$             & \verb|{ expr.TRA = NUM.VAL }|
\end{tabular}
\vspace{0.5cm}

Las apariciones de variables sintácticas en una regla de producción se indexan
como se ve en el ejemplo, para distinguir de que nodo del árbol de análisis estamos
hablando. Cuando hablemos del atributo de un nodo utilizaremos el punto (\verb|.|). 
Aquí \verb|VAL| es un atributo de los nodos de tipo $NUM$ denotando
su valor numérico y para accederlo escribiremos \verb|NUM.VAL|.
Análogamente \verb|expr.TRA| denota el atributo \red{traducción} de
los nodos de tipo $expr$.

\begin{exercise}
Muestre la secuencia de acciones a la
que da lugar el esquema de traducción anterior 
para la frase 7 -5 -4.
\end{exercise}

En este ejemplo, el cómputo del atributo \verb|expr.TRA| depende de los atributos
en los nodos hijos, o lo que es lo mismo, depende de los atributos de los símbolos
en la parte derecha de la regla de producción. Esto ocurre a menudo y motiva la siguiente
definición:

\begin{definition}
Un atributo tal que su valor en todo nodo del árbol sintáctico
puede ser computado en términos de los atributos de los hijos del nodo se dice
que es un \cei{atributo sintetizado}.
\end{definition}

\section{Eliminación de la Recursión por la Izquierda en un Esquema de Traducción}
\label{section:eliminarecesquem}
La eliminación de la recursión por la izquierda es sólo un paso: debe 
ser extendida a esquemas de traducción, 
de manera que no sólo se preserve el lenguaje
sino la secuencia de acciones. Supongamos que tenemos un esquema de
traducción de la forma:

\vspace{0.25cm}
\begin{tabular}{ll}
$A   \rightarrow A \alpha$  & \verb|{ alpha_action }|\\
$A   \rightarrow A \beta$   & \verb|{ beta_action }|\\
$A   \rightarrow \gamma$    & \verb|{ gamma_action }|
\end{tabular}
\vspace{0.25cm}

\noindent para una sentencia como $\gamma \beta \alpha$ la secuencia de
acciones será: 

\begin{center}
\verb|gamma_action  beta_action alpha_action|
\end{center}

¿Cómo construir un esquema de traducción para la gramática resultante
de eliminar la recursión por la izquierda que ejecute las acciones
asociadas en el mismo orden?. Supongamos para simplificar,
que las acciones no dependen
de atributos ni computan atributos, sino que actúan sobre
variables globales. En tal caso, la siguiente
ubicación de las acciones da lugar a que se ejecuten en el mismo
orden:

\vspace{0.25cm}
\begin{tabular}{l}
$A   \rightarrow \gamma$ \verb|{ gamma_action }| $R$\\
$R   \rightarrow \beta$ \verb| { beta_action }| $R$\\
$R   \rightarrow \alpha$ \verb| { alpha_action }| $R$\\
$R   \rightarrow \epsilon$  
\end{tabular}

Si hay atributos en juego, la estrategia para construir un
esquema de traducción equivalente para la gramática resultante
de eliminar la recursividad por la izquierda se complica.


\sectionpractica{Analizador Descendente Predictivo Recursivo}
\label{practica:pl0}

Partiendo del analizador sintáctico descendente predictivo recursivo para la gramática
descrita en la sección \ref{table:gramaticasimple}

\parrafo{Donde}
Puede encontrar la versión de la que partir en

\begin{itemize}
\item Despliegue en \Heroku{}:
\htmladdnormallink{http://predictiveparser.herokuapp.com/}{http://predictiveparser.herokuapp.com/}
\item Repositorio en GitHub:
\htmladdnormallink{https://github.com/crguezl/prdcalc}{https://github.com/crguezl/prdcalc}
\item
\begin{verbatim}
[~/javascript/PLgrado/predictiveRD/prdcalc(develop)]$ pwd -P
/Users/casiano/local/src/javascript/PLgrado/predictiveRD/prdcalc
[~/javascript/PLgrado/predictiveRD/prdcalc(develop)]$ git remote -v
heroku  git@heroku.com:predictiveparser.git (fetch)
heroku  git@heroku.com:predictiveparser.git (push)
origin  git@github.com:crguezl/prdcalc.git (fetch)
origin  git@github.com:crguezl/prdcalc.git (push)
\end{verbatim}
\end{itemize}

\parrafo{Tareas}
Añada:
\begin{itemize}
\item Extienda y modifique el analizador para que acepte el lenguaje 
descrito por la gramática EBNF del 
\wikip{lenguaje PL/0}{Recursive\_descent\_parser} que se describe en la 
entrada de la Wikipedia \blue{Recursive descent parser}
\begin{verbatim}
program = block "." .
 
 block =
     ["const" ident "=" number {"," ident "=" number} ";"]
     ["var" ident {"," ident} ";"]
     {"procedure" ident ";" block ";"} statement .
 
 statement =
     ident ":=" expression
     | "call" ident
     | "begin" statement {";" statement } "end"
     | "if" condition "then" statement
     | "while" condition "do" statement .
 
 condition =
     "odd" expression
     | expression ("="|"#"|"<"|"<="|">"|">=") expression .
 
 expression = ["+"|"-"] term {("+"|"-") term} .
 
 term = factor {("*"|"/") factor} .
 
 factor =
     ident
     | number
     | "(" expression ")" .
\end{verbatim}
\item
\red{Procure que el arbol generado refleje la asociatividad 
correcta para las diferencias y las divisiones}. 

%\parrafo{Construyendo Árboles con la Asociatividad Correcta}
\begin{itemize}
\item
{\bf El Problema de la Asociativad a Izquierdas y la Recursión por la Izquierda}

Supongamos que añadimos el operador \verb|-| al código de nuestra práctica. 

Para ello, podemos extender nuestro gramática  con una regla
de producción como esta:
\begin{center}
\vspace{0.25cm}
\begin{tabular}{|l|}
expression   $\rightarrow$ term '+' expression $|$term '-' expression $|$ term\\
\end{tabular}
\end{center}
\vspace{0.25cm}

Al poner \verb|expression| a la derecha evitamos la temida \red{recursión infinita}
del correspondiente analizador.

Esta elección da lugar a un código como el que sigue:
\begin{verbatim}
  expression = ->
    result = term()
    if lookahead and lookahead.type is "+"
      ....
    if lookahead and lookahead.type is "-" 
      match "-" 
      right = expression()
      result =
        type: "-" 
        left: result
        right: right
\end{verbatim}
Pero cuando le damos como entrada \verb|a = 4-2-1| produce el siguiente AST:
\begin{verbatim}
{
  "type": "=",
  "left": {
    "type": "ID",
    "value": "a"
  },
  "right": {
    "type": "-",
    "left": {
      "type": "NUM",
      "value": 4
    },
    "right": {
      "type": "-",
      "left": {
        "type": "NUM",
        "value": 2
      },
      "right": {
        "type": "NUM",
        "value": 1
      }
    }
  }
}
\end{verbatim}
que se corresponde con esta parentización: \verb|a = (4 - (2 - 1))|

\red{Este árbol no se corresponde con la asociatividad a izquierdas  del operador}
\verb|-|. Es un árbol que refleja una asociación a derechas produciendo 
como resultado \verb|a = 3|.


\item
{\bf Solución}


Un lenguaje generado por una gramática recursiva por la izquierda 
con dos reglas de la forma:
\vspace{0.25cm}
\begin{center}
\begin{tabular}{ll}
$A   \rightarrow A \alpha$  & \verb|{ alpha_action }|\\
$A   \rightarrow \gamma$    & \verb|{ gamma_action }|
\end{tabular}
\end{center}
Es 

\begin{center}
$\gamma \alpha *$.
\end{center}
\vspace{0.25cm}
Por tanto el método asociado con $A$ podría reescribirse como sigue:
\begin{verbatim}
A = () -> 
  gamma() # imitar gamma
  gamma_action() # acción semántica asociada con gamma
  while lookahead and lookahead.type belongs to  FIRST(alpha)
    alpha() # imitar alpha
    alpha_action()
\end{verbatim}

Así pues una técnica es eliminar la recursión por la izquierda en
\verb#expression -> expression ADDOP term | term#
 por su equivalente
 \verb|expression -> term (ADDOP term)*| e implantarlo
mediante un bucle en el que se va construyendo el árbol de análisis 
sintáctico abstracto (AST) de manera que se asocie a izquierdas:
\begin{verbatim}
 expression = ->
    result = term()
    while lookahead and lookahead.type is "ADDOP"
      type = lookahead.value
      match "ADDOP"
      right = term()
      result =
        type: type
        left: result
        right: right
    result
\end{verbatim}
Aquí el token \verb|ADDOP| esta por las dos operaciones aditivas:
\begin{verbatim}
 tokens =
    WHITES: /\s+/g
    ID: /[a-zA-Z_]\w*/g
    NUM: /\b\d+(\.\d*)?([eE][+-]?\d+)?\b/g
    STRING: /('(\\.|[^'])*'|"(\\.|[^"])*")/g
    ONELINECOMMENT: /\/\/.*/g
    MULTIPLELINECOMMENT: /\/[*](.|\n)*?[*]\//g
    COMPARISONOPERATOR: /[<>=!]=|[<>]/g
    ADDOP: /[+-]/g
    ONECHAROPERATORS: /([*\/=()&|;:,{}[\]])/g
\end{verbatim}
\end{itemize}
\item
No es necesario que el lenguaje sea \red{exactamente igual} pero debería 
ser parecido. Tener
los mismos constructos.
\item
\blue{Añada al lenguaje la sentencia} \verb|"if" condition "then" statement "else" statement|
\item
%\item
%Complete el template \slim{} traduciendo la parte que está actualmente en
%\wikip{erb}{ERuby} a \slim{} (fichero \verb|views/home.slim|)
\item
Use \coffeescript{} para escribir el código (vea el fichero
\htmladdnormallink{views/main.coffee}{https://github.com/crguezl/prdcalc/blob/master/views/main.coffee})
\item
%Use \slim{} para las vistas
Use 
\htmladdnormallink{Jade}{http://jade-lang.com/}
para las vistas
\item
Usa \sass{} para las hojas de estilo
\item
Despliegue la aplicación en \Heroku{}
\item Añada pruebas
\end{itemize}

%\parrafo{Sinatra}
%
%Véase el fichero
%  \htmladdnormallink{main.rb}{https://github.com/crguezl/prdcalc/blob/master/main.rb}.
%
%\begin{enumerate}
%\item
%\htmladdnormallink{Filters}{http://www.sinatrarb.com/intro.html\#Filters}
%\item
%\htmladdnormallink{Helpers}{http://www.sinatrarb.com/intro.html\#Helpers}
%  \begin{enumerate}
%  \item El helper \verb|css| es usado en 
%  \htmladdnormallink{views/layout.slim}{https://github.com/crguezl/prdcalc/blob/master/views/layout.slim}
%  \item
%  El helper \verb|current?| es usado en 
%  \htmladdnormallink{views/nav.slim}{https://github.com/crguezl/prdcalc/blob/master/views/nav.slim} para añadir la clase \verb|current| a la página que esta siendo visitada.
%\item El estilo de la entrada de la página actual es modificado en el fichero de estilo
%  \htmladdnormallink{views/styles.scss}{https://github.com/crguezl/prdcalc/blob/master/views/styles.scss}
%\begin{verbatim}
%nav a.current {
%  background: lighten($black, 50%);
%}
%\end{verbatim}
%El método \htmladdnormallink{lighten}{http://sass-lang.com/documentation/Sass/Script/Functions.html\#lighten-instance\_method} es proveído por \sass{}.
%  \end{enumerate}
%\item
%\htmladdnormallink{Views / Templates}{http://www.sinatrarb.com/intro.html\#Views\%20/\%20Templates}
%\end{enumerate}

\parrafo{Express.JS}
\begin{itemize}
\item
\htmladdnormallink{http://expressjs.com/}{http://expressjs.com/}
\end{itemize}

\parrafo{Sass}

Véase el fichero
  \htmladdnormallink{views/styles.scss}{https://github.com/crguezl/prdcalc/blob/master/views/styles.scss}.

\begin{enumerate}
\item
\sass{}
\item
\htmladdnormallink{Sass Basics}{http://sass-lang.com/guide}
\item css2sass en GitHub 
(\htmladdnormallink{https://github.com/jpablobr/css2sass}{https://github.com/jpablobr/css2sass})
y despliegue en Heroku
(\htmladdnormallink{http://css2sass.heroku.com/}{http://css2sass.heroku.com/})
\end{enumerate}

%\parrafo{Slim}
%Véanse los ficheros \verb|views/*.slim|:
%\begin{itemize}
%\item
%\htmladdnormallink{views/layout.slim}{https://github.com/crguezl/prdcalc/blob/master/views/layout.slim}
%\item
%\htmladdnormallink{views/home.slim}{https://github.com/crguezl/prdcalc/blob/master/views/home.slim}
%\item
%\htmladdnormallink{views/nav.slim}{https://github.com/crguezl/prdcalc/blob/master/views/nav.slim}
%\end{itemize}
%
%\begin{enumerate}
%\item
%\slim{}
%\item
%\htmladdnormallink{Slim docs}{http://rdoc.info/gems/slim/frames}
%\item
%\htmladdnormallink{html2slim}{https://github.com/slim-template/html2slim}
%\item
%\htmladdnormallink{2011.12.16 Tech Talk: Slim Templates de Big Nerd Ranch}{https://vimeo.com/33802242} (Vimeo)
%\end{enumerate}

\parrafo{Jade}

\begin{itemize}
\item
\htmladdnormallink{http://jade-lang.com/}{http://jade-lang.com/}
\item
\htmladdnormallink{http://jade-lang.com/tutorial/}{http://jade-lang.com/tutorial/}
\item
\htmladdnormallink{http://jade-lang.com/reference/}{http://jade-lang.com/reference/}
\item
Este repo
\htmladdnormallink{https://github.com/crguezl/jadeexample}{https://github.com/crguezl/jadeexample}
con un ejemplo sencillo
\item
\htmladdnormallink{Learning the Jade Templating Engine Syntax}{http://cssdeck.com/labs/learning-the-jade-templating-engine-syntax}
\item
\htmladdnormallink{New way to inline css}{http://stackoverflow.com/questions/21765107/new-way-to-inline-css} Jade StackOverflow
\end{itemize}

\parrafo{CoffeeScript}

\begin{enumerate}
\item
\coffeescript{}
\item
\htmladdnormallink{CoffeeScript Cookbook}{http://coffeescriptcookbook.com/}
\item
\htmladdnormallink{js2coffee.org}{http://js2coffee.org/}
\end{enumerate}

