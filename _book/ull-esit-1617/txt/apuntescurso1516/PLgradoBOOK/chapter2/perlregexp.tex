\chapter{Expresiones Regulares en Perl}
\label{chapter:regulares}

\section{Introducción}
Los rudimentos de las expresiones regulares pueden encontrarse
en los trabajos pioneros de McCullogh y Pitts (1940) sobre redes neuronales.
El lógico Stephen Kleene definió formalmente el algebra que denominó
\emph{conjuntos regulares} y desarrollo una notación para la descripción de dichos conjuntos, las \emph{expresiones regulares}.

Durante las décadas de 1960 y 1970 hubo un desarrollo formal de las expresiones regulares.
Una de las priemras publicaciones que utilizan las expresiones
regulares en un marco informático es el artículo de 1968 de Ken
Thompson \emph{Regular Expression Search Algorithm} en el que describe
un compilador de expresiones regulares que produce código objeto para
un IBM 7094.
Este compilador dió lugar al editor \emph{qed}, en el cual se basó el
editor de Unix
\emph{ed}. Aunque las expresiones regulares de este último no eran
tan sofisticadas como las de \emph{qed}, fueron las primeras en ser
utilizadas en un contexto no académico.
Se dice que el comando global \verb|g| en su formato \verb|g/re/p| que utilizaba 
para imprimir (opción \verb|p|) las líneas que casan con la expresión regular  \verb|re|
dió lugar a un programa separado al que se denomino \man{grep}.

Las expresiones regulares facilitadas por las primeras versiones de estas herramientas 
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
positivo \verb|+| o del operador opcional \verb|?|. 
Por eso, posteriormente, se han introducido los metacaracteres \verb|\+| y \verb|\?|.
Existían numerosas limitaciones en dichas versiones, por ej. \verb|$| sólo significa ``final
de línea'' al final de la expresión regular. Eso  dificulta expresiones como 
\begin{verbatim}
grep 'cierre$\|^Las' viq.tex
\end{verbatim}
Sin embargo, la mayor parte de las versiones
actuales resuelven correctamente estos problemas:
\begin{verbatim}
nereida:~/viq> grep 'cierre$\|^Las' viq.tex
Las expresiones regulares facilitadas por las primeras versiones de estas herramientas
eran limitadas. Por ejemplo, se disponía del cierre de Kleene \verb|*| pero no del cierre
nereida:~/viq>
\end{verbatim}
De hecho AT\&T Bell  labs añadió numerosas funcionalidades,
como por ejemplo, el uso de \verb|\{min, max\}|, tomada de \emph{lex}.
Por esa época, Alfred Aho escribió \emph{egrep} que, no sólo proporciona un conjunto
mas rico de operadores sino que mejoró la implementación.
Mientras que el \emph{grep} de Ken Thompson usaba un autómata finito no determinista
(NFA), la versión de \emph{egrep}
de Aho usa un autómata finito determinista (DFA).

En 1986 Henry Spencer desarrolló la librería \emph{regex} para el lenguaje \verb|C|, que 
proporciona un conjunto consistente de funciones que permiten el manejo de expresiones
regulares. Esta librería ha contribuido a ``homogeneizar'' la sintáxis y semántica 
de las diferentes herramientas que utilizan expresiones regulares (como \emph{awk},
\emph{lex}, \emph{sed}, \ldots).

\parrafo{Véase También}

\begin{itemize}
\item
La sección
{\it Expresiones Regulares en Otros Lenguajes}
\ref
{section:otroslenguajes}
\item
\htmladdnormallink
{Regular Expressions Cookbook. Jan Goyvaerts, Steven Levithan}
{http://oreilly.com/catalog/9780596520687/preview.html}
\item
\htmladdnormallink
{PCRE (Perl Compatible Regular Expressions) en la Wikipedia}
{http://en.wikipedia.org/wiki/Perl\_Compatible\_Regular\_Expressions}
\item
\htmladdnormallink{PCRE (Perl Compatible Regular Expressions)}
{http://www.pcre.org/pcre.txt}
\item
\htmladdnormallink
{Java Regular Expressions}
{http://java.sun.com/docs/books/tutorial/essential/regex/}
\item
\htmladdnormallink
{C\# Regular Expressions}
{http://oreilly.com/lpt/a/2299}
\item
\htmladdnormallink
{.NET Framework Regular Expressions}
{http://msdn.microsoft.com/en-us/library/hs600312(VS.71).aspx}
\end{itemize}

\subsection{Un ejemplo sencillo}
\label{section:ejemplo}
%%%%%%%%%%%%%%%listinginput: Input from: "../src/convert.pl"

\parrafo{Matching en Contexto Escalar}


\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n c2f.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print "Enter a temperature (i.e. 32F, 100C):\n";
  5    my $input = <STDIN>;
  6    chomp($input);
  7  
  8    if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
  9      warn "Expecting a temperature, so don't understand \"$input\".\n";
 10    }
 11    else {
 12      my $InputNum = $1;
 13      my $type = $3;
 14      my ($celsius, $farenheit);
 15      if ($type eq "C" or $type eq "c") {
 16        $celsius = $InputNum;
 17        $farenheit = ($celsius * 9/5)+32;
 18      }
 19      else {
 20        $farenheit = $InputNum;
 21        $celsius = ($farenheit -32)*5/9;
 22      }
 23      printf "%.2f C = %.2f F\n", $celsius, $farenheit;
 24    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n c2f.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">&lt;STDIN&gt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> !~ <span class="synStatement">m/</span><span class="synConstant">^</span><span class="synSpecial">([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])</span><span class="synConstant">$</span><span class="synStatement">/i</span>) {
<span class="synLinenum">    9</span>     <span class="synStatement">warn</span> <span class="synConstant">&quot;Expecting a temperature, so don't understand </span><span class="synSpecial">\&quot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\&quot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   12</span>     <span class="synStatement">my</span> <span class="synIdentifier">$InputNum</span> = <span class="synIdentifier">$1</span>;
<span class="synLinenum">   13</span>     <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$3</span>;
<span class="synLinenum">   14</span>     <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>);
<span class="synLinenum">   15</span>     <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;C&quot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;c&quot;</span>) {
<span class="synLinenum">   16</span>       <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   17</span>       <span class="synIdentifier">$farenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   18</span>     }
<span class="synLinenum">   19</span>     <span class="synStatement">else</span> {
<span class="synLinenum">   20</span>       <span class="synIdentifier">$farenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>       <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$farenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   22</span>     }
<span class="synLinenum">   23</span>     <span class="synStatement">printf</span> <span class="synConstant">&quot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$farenheit</span>;
<span class="synLinenum">   24</span>   }
</pre>

\end{rawhtml}
%}}}


Véase también:

\begin{itemize}
\item \verb|perldoc| \perldoc{perlrequick}
\item \verb|perldoc| \perldoc{perlretut}
\item \verb|perldoc| \perldoc{perlre}
\item \verb|perldoc| \perldoc{perlreref}
\end{itemize}

Ejecución con el depurador:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wd c2f.pl
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h' for help, or `man perldebug' for more help.
main::(c2f.pl:4):       print "Enter a temperature (i.e. 32F, 100C):\n";
DB<1> c 8
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB<2> n
main::(c2f.pl:12):        my $InputNum = $1;
DB<2> x ($1, $2, $3)
0  32
1  undef
2  'F'
DB<3> use YAPE::Regex::Explain
DB<4> p YAPE::Regex::Explain->new('([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$')->explain
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: '-', '+' (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: '0' to '9' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       '.'
----------------------------------------------------------------------
      [0-9]*                   any character of: '0' to '9' (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you're using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and " ") (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: 'C', 'F'
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$  <span  class="dbuser">perl -wd c2f.pl</span>
Loading DB routines from perl5db.pl version 1.28
Editor support available.
Enter h or `h h' for help, or `man perldebug' for more help.
main::(c2f.pl:4):       print "Enter a temperature (i.e. 32F, 100C):\n";
DB<1>  <span  class="dbuser">c 8</span>
Enter a temperature (i.e. 32F, 100C):
32F
main::(c2f.pl:8):       if ($input !~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/i) {
DB<2>  <span  class="dbuser">n</span>
main::(c2f.pl:12):        my $InputNum = $1;
DB<2>  <span  class="dbuser">x ($1, $2, $3)</span>
0  32
1  undef
2  'F'
DB<3>  <span  class="dbuser">use YAPE::Regex::Explain</span>
DB<4>  <span  class="dbuser">p YAPE::Regex::Explain->new('([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$')->explain</span>
The regular expression:
(?-imsx:([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$)
matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?-imsx:                 group, but do not capture (case-sensitive)
                         (with ^ and $ matching normally) (with . not
                         matching \n) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [-+]?                    any character of: '-', '+' (optional
                             (matching the most amount possible))
----------------------------------------------------------------------
    [0-9]+                   any character of: '0' to '9' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
    (                        group and capture to \2 (optional
                             (matching the most amount possible)):
----------------------------------------------------------------------
      \.                       '.'
----------------------------------------------------------------------
      [0-9]*                   any character of: '0' to '9' (0 or
                               more times (matching the most amount
                               possible))
----------------------------------------------------------------------
    )?                       end of \2 (NOTE: because you're using a
                             quantifier on this capture, only the
                             LAST repetition of the captured pattern
                             will be stored in \2)
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  \s*                      whitespace (\n, \r, \t, \f, and " ") (0 or
                           more times (matching the most amount
                           possible))
----------------------------------------------------------------------
  (                        group and capture to \3:
----------------------------------------------------------------------
    [CF]                     any character of: 'C', 'F'
----------------------------------------------------------------------
  )                        end of \3
----------------------------------------------------------------------
  $                        before an optional \n, and the end of the
                           string
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------
</pre>
\end{rawhtml}
%}}}

\label{section:dolar1}
Dentro de una expresión regular es necesario 
referirse a los textos que casan con el primer, paréntesis,
segundo, etc. como \verb|\1|, \verb|\2,| etc. La notación 
\verb|$1| se refieré a lo que casó con el primer paréntesis
en el último \emph{matching}, no en el actual. Veamos un ejemplo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $a = "hola juanito";
   5    my $b = "adios anita";
   6  
   7    $a =~ /(ani)/;
   8    $b =~ s/(adios) *($1)/\U$1 $2/;
   9    print "$b\n";
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n dollar1slash1.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a</span> = <span class="synConstant">&quot;hola juanito&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$b</span> = <span class="synConstant">&quot;adios anita&quot;</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synIdentifier">$a</span> =~<span class="synStatement"> /</span><span class="synSpecial">(</span><span class="synConstant">ani</span><span class="synSpecial">)</span><span class="synStatement">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$b</span> =~ <span class="synStatement">s/</span><span class="synSpecial">(</span><span class="synConstant">adios</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">*(</span><span class="synIdentifier">$1</span><span class="synSpecial">)</span><span class="synStatement">/</span><span class="synSpecial">\U</span><span class="synIdentifier">$1</span><span class="synConstant"> </span><span class="synIdentifier">$2</span><span class="synStatement">/</span>;
<span class="synLinenum">    9</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
</pre>

\end{rawhtml}
%}}}
Observe como el \verb|$1| que aparece en la cadena de reemplazo (línea 8)
se refiere a la cadena \verb|adios|
mientras que el \verb|$1| en la primera parte contiene \verb|ani|:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./dollar1slash1.pl
ADIOS ANIta
\end{verbatim}

\begin{exercise}
Indique cuál es la salida del programa anterior si se sustituye la línea 8 por
\begin{verbatim}
$b =~ s/(adios) *(\1)/\U$1 $2/;
\end{verbatim}
\end{exercise}

\parrafo{Número de Paréntesis}

El número de paréntesis con memoria no está limitado:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
            123456789ABCDEF
DB<1> $x = "123456789AAAAAA"
                   1  2  3  4  5  6  7  8  9 10 11  12
DB<2> $r = $x =~ /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/; print "$r\n$10\n$11\n"
1
A
A
\end{verbatim}

Véase el siguiente párrafo de \perldoc{perlre} (sección Capture buffers):
\begin{it}
\begin{quotation}
There is no limit to the number of captured substrings that you may
use. However Perl also uses \verb#\10#, \verb#\11#, etc. as aliases for \verb#\010#, \verb#\011#,
etc. (Recall that \verb#0# means octal, so \verb#\011# is the character at number \verb#9# in
your coded character set; which would be the 10th character, a horizontal
tab under ASCII.) Perl resolves this ambiguity by interpreting \verb#\10# as
a backreference only if at least \verb#10# left parentheses have opened before
it. Likewise \verb#\11# is a backreference only if at least \verb#11# left parentheses
have opened before it. And so on. \verb#\1# through \verb#\9# are always interpreted
as backreferences.
\end{quotation}
\end{it}

\parrafo{Contexto de Lista}

Si se utiliza en un contexto que requiere una lista,
el ``pattern match'' retorna una lista consistente en
las subexpresiones casadas mediante los paréntesis,
esto es \verb|$1|, \verb|$2|, \verb|$3|, \ldots. 
Si no hubiera emparejamiento se retorna la lista vacía.
Si lo hubiera pero no hubieran paréntesis se retorna la lista 
\verb|($&)|.

%%%%%%%%%%%%%%%listinginput: Input from: "../src/escapes.pl"
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ cat -n escapes.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $foo = "one two three four five\nsix seven";
     5  my ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/);
     6  print "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n";
     7
     8  # This is 'almost' the same than:
     9  ($F1, $F2, $Etc) = split(/\s+/, $foo, 3);
    10  print "Split: F1 = $F1, F2 = $F2, Etc = $Etc\n";
\end{verbatim}
Observa el resultado de la ejecución:
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ ./escapes.pl
List Context: F1 = one, F2 = two, Etc = three four five
Split: F1 = one, F2 = two, Etc = three four five
six seven
\end{verbatim}

\parrafo{El modificador {\tt s}}

La opción \verb|s| usada en una regexp 
hace que el punto \verb|'.'| case con el retorno
de carro:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ perl -wd ./escapes.pl
main::(./escapes.pl:4): my $foo = "one two three four five\nsix seven";
DB<1> c 9
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(' ',$foo, 3);
DB<2> ($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)
DB<3> p "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n"
List Context: F1 = one, F2 = two, Etc = three four five
six seven
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/src/perl/perltesting$  <span  class="dbuser">perl -wd ./escapes.pl</span>
main::(./escapes.pl:4): my $foo = "one two three four five\nsix seven";
DB<1>  <span  class="dbuser">c 9</span>
List Context: F1 = one, F2 = two, Etc = three four five
main::(./escapes.pl:9): ($F1, $F2, $Etc) = split(' ',$foo, 3);
DB<2>  <span  class="dbuser">($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/s)</span>
DB<3>  <span  class="dbuser">p "List Context: F1 = $F1, F2 = $F2, Etc = $Etc\n"</span>
List Context: F1 = one, F2 = two, Etc = three four five
six seven
</pre>
\end{rawhtml}
%}}}


La opción \verb|/s| hace que \verb|.| se empareje con 
un \verb|\n|.
Esto es, casa con cualquier carácter.

Veamos otro ejemplo, que imprime los nombres de los ficheros que
contienen cadenas que casan con un patrón dado, incluso si este
aparece disperso en varias líneas:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/smodifier.pl"
\begin{latexonly}
\begin{verbatim}
   1   #!/usr/bin/perl -w
   2   #use: 
   3   #smodifier.pl 'expr' files
   4   #prints the names of the files that match with the give expr
   5   undef $/; # input record separator
   6   my $what = shift @ARGV;
   7   while(my $file = shift @ARGV) {
   8     open(FILE, "<$file");
   9     $line =  <FILE>;
  10     if ($line =~ /$what/s) {
  11       print "$file\n";
  12     }
  13   }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span>  <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>  <span class="synComment">#use: </span>
<span class="synLinenum">    3</span>  <span class="synComment">#smodifier.pl 'expr' files</span>
<span class="synLinenum">    4</span>  <span class="synComment">#prints the names of the files that match with the give expr</span>
<span class="synLinenum">    5</span>  <span class="synStatement">undef</span> <span class="synIdentifier">$/</span>; <span class="synComment"># input record separator</span>
<span class="synLinenum">    6</span>  <span class="synStatement">my</span> <span class="synIdentifier">$what</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>;
<span class="synLinenum">    7</span>  <span class="synStatement">while</span>(<span class="synStatement">my</span> <span class="synIdentifier">$file</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span>) {
<span class="synLinenum">    8</span>    <span class="synStatement">open</span>(<span class="synIdentifier">FILE</span>, <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$file</span><span class="synConstant">&quot;</span>);
<span class="synLinenum">    9</span>    <span class="synIdentifier">$line</span> =  <span class="synIdentifier">&lt;FILE&gt;</span>;
<span class="synLinenum">   10</span>    <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$what</span><span class="synStatement">/s</span>) {
<span class="synLinenum">   11</span>      <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$file</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   12</span>    }
<span class="synLinenum">   13</span>  }
</pre>

\end{rawhtml}
%}}}

\noindent Ejemplo de uso:

\begin{verbatim}
> smodifier.pl 'three.*three' double.in split.pl doublee.pl
double.in
doublee.pl 
\end{verbatim}

Vea la sección \ref{section:repetidas} para ver los contenidos 
del fichero \verb|double.in|. En dicho fichero,
el patrón \verb|three.*three| aparece repartido entre
varias líneas.


\parrafo{El modificador {\tt m}}

El modificador \verb|s| se suele usar conjuntamente con el modificador 
\verb|m|. He aquí lo que dice
la seccion {\it Using character classes} de \pd{perlretut}{Using-character-classes}
al respecto:

\begin{it}
\begin{quotation}
\begin{itemize}
    \item \verb|m| modifier (\verb|//m|): Treat string as a set of multiple lines. 
      \verb|'.'| matches any character except \verb"\n". 
      \verb|^| and \verb|$| are able to match at the start or end of any line within the string.
    \item
      both \verb|s| and \verb|m| modifiers (\verb|//sm|): Treat string as a single long line, but detect multiple lines. 
      \verb|'.'| matches any character, even \verb"\n" . 
      \verb|^| and \verb|$| , however, are able to match at the start or end of any line within the string.
\end{itemize}

Here are examples of //s and //m in action:

\begin{verbatim}
   1. $x = "There once was a girl\nWho programmed in Perl\n";
   2.
   3. $x =~ /^Who/; # doesn't match, "Who" not at start of string
   4. $x =~ /^Who/s; # doesn't match, "Who" not at start of string
   5. $x =~ /^Who/m; # matches, "Who" at start of second line
   6. $x =~ /^Who/sm; # matches, "Who" at start of second line
   7.
   8. $x =~ /girl.Who/; # doesn't match, "." doesn't match "\n"
   9. $x =~ /girl.Who/s; # matches, "." matches "\n"
  10. $x =~ /girl.Who/m; # doesn't match, "." doesn't match "\n"
  11. $x =~ /girl.Who/sm; # matches, "." matches "\n"
\end{verbatim}

Most of the time, the default behavior is what is wanted, but \verb|//s| and
\verb|//m| are occasionally very useful. If \verb|//m| is being used, the start of the
string can still be matched with \verb|\A| and the end of the string can still
be matched with the anchors \verb|\Z| (matches both the end and the newline
before, like \verb|$|), and \verb|\z| (matches only the end):

\begin{verbatim}
   1. $x =~ /^Who/m; # matches, "Who" at start of second line
   2. $x =~ /\AWho/m; # doesn't match, "Who" is not at start of string
   3.
   4. $x =~ /girl$/m; # matches, "girl" at end of first line
   5. $x =~ /girl\Z/m; # doesn't match, "girl" is not at end of string
   6.
   7. $x =~ /Perl\Z/m; # matches, "Perl" is at newline before end
   8. $x =~ /Perl\z/m; # doesn't match, "Perl" is not at end of string
\end{verbatim}
\end{quotation}
\end{it}
Normalmente el carácter \verb|^| casa solamente con el comienzo de la
cadena y el carácter \verb|$| con el final. Los \verb|\n| empotrados
no casan
con \verb|^| ni \verb|$|. El modificador \verb|/m| modifica esta
conducta. De este modo \verb|^| y  \verb|$| casan con cualquier frontera
de línea interna. Las anclas \verb|\A| y \verb|\Z| se utilizan entonces
para casar con
el comienzo y final de la cadena.
Véase un ejemplo:
\begin{verbatim}
nereida:~/perl/src> perl -de 0
  DB<1> $a = "hola\npedro"
  DB<2> p "$a"
hola
pedro
  DB<3> $a =~ s/.*/x/m
  DB<4> p $a
x
pedro
  DB<5> $a =~ s/^pedro$/juan/
  DB<6> p "$a"
x
pedro
  DB<7> $a =~ s/^pedro$/juan/m
  DB<8>  p "$a"
x
juan
\end{verbatim}


\parrafo{El conversor de temperaturas reescrito usando contexto de lista}

Reescribamos el ejemplo anterior usando un contexto de lista:

\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
  1    #!/usr/bin/perl -w
  2    use strict;
  3  
  4    print "Enter a temperature (i.e. 32F, 100C):\n";
  5    my $input = <STDIN>;
  6    chomp($input);
  7  
  8    my ($InputNum, $type);
  9  
 10    ($InputNum, $type) = $input =~ m/^
 11                                        ([-+]?[0-9]+(?:\.[0-9]*)?) # Temperature
 12                                        \s*
 13                                        ([cCfF]) # Celsius or Farenheit
 14                                     $/x;
 15  
 16    die "Expecting a temperature, so don't understand \"$input\".\n" unless defined($InputNum);
 17  
 18    my ($celsius, $fahrenheit);
 19    if ($type eq "C" or $type eq "c") {
 20      $celsius = $InputNum;
 21      $fahrenheit = ($celsius * 9/5)+32;
 22    }
 23    else {
 24      $fahrenheit = $InputNum;
 25      $celsius = ($fahrenheit -32)*5/9;
 26    }
 27    printf "%.2f C = %.2f F\n", $celsius, $fahrenheit;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n c2f_list.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">print</span> <span class="synConstant">&quot;Enter a temperature (i.e. 32F, 100C):</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = <span class="synIdentifier">&lt;STDIN&gt;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>);
<span class="synLinenum">    9</span> 
<span class="synLinenum">   10</span>   (<span class="synIdentifier">$InputNum</span>, <span class="synIdentifier">$type</span>) = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m/</span><span class="synConstant">^</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                      </span><span class="synSpecial">([-+]?[0-9]+(?:\.[0-9]*)?)</span><span class="synConstant"> # Temperature</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                      </span><span class="synSpecial">\s*</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">([cCfF])</span><span class="synConstant"> # Celsius or Farenheit</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   $</span><span class="synStatement">/x</span>;
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span>   <span class="synStatement">die</span> <span class="synConstant">&quot;Expecting a temperature, so don't understand </span><span class="synSpecial">\&quot;</span><span class="synIdentifier">$input</span><span class="synSpecial">\&quot;</span><span class="synConstant">.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span> <span class="synStatement">unless</span> <span class="synStatement">defined</span>(<span class="synIdentifier">$InputNum</span>);
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span>   <span class="synStatement">my</span> (<span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>);
<span class="synLinenum">   19</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;C&quot;</span> <span class="synStatement">or</span> <span class="synIdentifier">$type</span> <span class="synStatement">eq</span> <span class="synConstant">&quot;c&quot;</span>) {
<span class="synLinenum">   20</span>     <span class="synIdentifier">$celsius</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   21</span>     <span class="synIdentifier">$fahrenheit</span> = (<span class="synIdentifier">$celsius</span> * <span class="synConstant">9</span>/<span class="synConstant">5</span>)<span class="synConstant">+32</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   24</span>     <span class="synIdentifier">$fahrenheit</span> = <span class="synIdentifier">$InputNum</span>;
<span class="synLinenum">   25</span>     <span class="synIdentifier">$celsius</span> = (<span class="synIdentifier">$fahrenheit</span> <span class="synConstant">-32</span>)*<span class="synConstant">5</span>/<span class="synConstant">9</span>;
<span class="synLinenum">   26</span>   }
<span class="synLinenum">   27</span>   <span class="synStatement">printf</span> <span class="synConstant">&quot;%.2f C = %.2f F</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>, <span class="synIdentifier">$celsius</span>, <span class="synIdentifier">$fahrenheit</span>;
</pre>

\end{rawhtml}
%}}}

\parrafo{La opción {\tt x}}

\label{section:x}
La opción \verb|/x| en una regexp permite utilizar comentarios y
espacios dentro de la expresión
regular. Los espacios dentro de la expresión regular dejan de ser significativos.
Si quieres conseguir un espacio que sea significativo, usa \verb|\s| o
bien escápalo.  Véase \pd{perlre}{Modifiers} y 
\pd{perlretut}{Building-a-regexp}.

\parrafo{Paréntesis sin memoria}

La notación \verb|(?: ... )| se usa para introducir paréntesis de agrupamiento sin memoria.
\verb|(?: ...)| 
Permite agrupar las expresiones tal y como lo hacen los 
paréntesis ordinarios. La diferencia es que no ``memorizan''
esto es no guardan nada en \verb|$1|, \verb|$2|, etc.
Se logra así una compilación mas eficiente. Veamos un ejemplo:
\begin{verbatim}
> cat groupingpar.pl
#!/usr/bin/perl

  my $a = shift;

  $a =~ m/(?:hola )*(juan)/;
  print "$1\n";
nereida:~/perl/src> groupingpar.pl 'hola juan'
juan
\end{verbatim}

\parrafo{Interpolación en los patrones: La opción {\tt o}}

El patrón regular puede contener variables, que serán interpoladas
(en tal caso, el patrón será recompilado).
Si quieres que dicho patrón se compile una sóla vez, usa la opción
\verb|/o|.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/mygrep.pl"
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mygrep.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die "Usage $0 regexp files ...\n";
     3  while (<>) {
     4    print "File $ARGV, rel. line $.: $_" if (/$what/o); # compile only once
     5  }
     6
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./mygrep.pl
Usage ./mygrep.pl regexp files ...
pl@nereida:~/Lperltesting$ ./mygrep.pl if labels.c
File labels.c, rel. line 7:        if (a < 10) goto LABEL;
\end{verbatim}

El siguiente texto es de \pd{perlretut}{Using-regular-expressions-in-Perl}:

\begin{it}
\begin{quotation}
If \verb|$pattern|  won't be changing over the lifetime of the script,
we can add the //o modifier, which directs Perl to only perform variable
substitutions once
\end{quotation}
\end{it}

Otra posibilidad es hacer una compilación previa usando el operador 
\verb|qr| (véase \pd{perlop}{Regexp-Quote-Like-Operators}).
La siguiente variante del programa anterior también compila el patrón
una sóla vez:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mygrep2.pl
     1  #!/usr/bin/perl -w
     2  my $what = shift @ARGV || die "Usage $0 regexp files ...\n";
     3  $what = qr{$what};
     4  while (<>) {
     5    print "File $ARGV, rel. line $.: $_" if (/$what/);
     6  }
\end{verbatim}

Véase 
\begin{itemize}
\item El nodo en perlmonks \pmm{269035}{/o is dead, long live qr//!} por \pmm{194920}{diotalevi}
\end{itemize}
  

\parrafo{Cuantificadores greedy}

El siguiente extracto de la sección {\it Matching Repetitions} en \pd{perlretut}{Matching-repetitions} 
ilustra la semántica {\it greedy} de los operadores de repetición \verb|*+{}?| etc.
\begin{it}
\begin{quotation}
For all of these quantifiers, Perl will try to match as much of the string
as possible, while still allowing the regexp to succeed. Thus with \verb#/a?.../#, 
Perl will first try to match the regexp with the a present; if that
fails, Perl will try to match the regexp without the a  present. For
the quantifier \verb|*| , we get the following:

\begin{verbatim}
   1. $x = "the cat in the hat";
   2. $x =~ /^(.*)(cat)(.*)$/; # matches,
   3. # $1 = 'the '
   4. # $2 = 'cat'
   5. # $3 = ' in the hat'
\end{verbatim}

Which is what we might expect, the match finds the only cat in the string and locks onto it. Consider, however, this regexp:

\begin{verbatim}
   1. $x =~ /^(.*)(at)(.*)$/; # matches,
   2. # $1 = 'the cat in the h'
   3. # $2 = 'at'
   4. # $3 = '' (0 characters match)
\end{verbatim}

One might initially guess that Perl would find the \verb|at| in \verb|cat| and stop
there, but that wouldn't give the longest possible string to the first
quantifier \verb|.*|. Instead, the first quantifier \verb|.*| grabs as much of the
string as possible while still having the regexp match. In this example,
that means having the \verb|at| sequence with the final \verb|at| in the string. 

The
other important principle illustrated here is that when there are two
or more elements in a regexp, the leftmost quantifier, if there is one,
gets to grab as much the string as possible, leaving the rest of the
regexp to fight over scraps. Thus in our example, the first quantifier
\verb|.*| grabs most of the string, while the second quantifier \verb|.*| gets the
empty string. Quantifiers that grab as much of the string as possible
are called maximal match or greedy quantifiers.

When a regexp can match a string in several different ways, we can use
the principles above to predict which way the regexp will match:

\begin{itemize}
    \item

      {\bf Principle 0:} Taken as a whole, any regexp will be matched at the earliest possible position in the string.
    \item

      {\bf Principle 1:} In an alternation \verb#a|b|c...# , the leftmost alternative that allows a match for the whole regexp will be the one used.
    \item

      {\bf Principle 2:} The maximal matching quantifiers \verb|?|, \verb|*|, \verb|+| and \verb|{n,m}| 
                   will in general match as much of the string as possible while still allowing the whole regexp to match.
    \item
      {\bf Principle 3:} If there are two or more elements in a regexp, the leftmost greedy quantifier, 
                   if any, will match as much of the string as possible while still allowing the whole regexp to match. 
                   The next leftmost greedy quantifier, if any, will try to match as much of 
                   the string remaining available to it as possible, while still allowing 
                   the whole regexp to match. And so on, until all the regexp elements are satisfied.
\end{itemize}

\end{quotation}
\end{it}

\parrafo{Regexp y Bucles Infinitos}

El siguiente párrafo está tomado de \pd{perlre}{Repeated-Patterns-Matching-a-Zero-length-Substring}:
\begin{it}
\begin{quote}
Regular expressions provide a terse and powerful programming language. As
with most other power tools, power comes together with the ability to
wreak havoc.

A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:

\begin{verbatim}
   1. 'foo' =~ m{ ( o? )* }x;
\end{verbatim}

The \verb|o?| matches at the beginning of \verb|'foo'| , and since the position in
the string is not moved by the match, \verb|o?| would match again and again
because of the \verb|*| quantifier.

 Another common way to create a similar cycle is with the looping modifier \verb|//g| :

\begin{verbatim}
   1. @matches = ( 'foo' =~ m{ o? }xg );
\end{verbatim}

or

\begin{verbatim}
   1. print "match: <$&>\n" while 'foo' =~ m{ o? }xg;
\end{verbatim}

or the loop implied by \verb|split()|.

... Perl allows such constructs, by forcefully breaking the infinite
loop. The rules for this are different for lower-level loops given by
the greedy quantifiers \verb|*+{}| , and for higher-level ones like the \verb|/g|
modifier or \verb|split()| operator.

The lower-level loops are interrupted (that is, the loop is broken)
when Perl detects that a repeated expression matched a zero-length
substring. Thus

\begin{verbatim}
   1.  m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
\end{verbatim}

is made equivalent to

\begin{verbatim}
   1.  m{ (?: NON_ZERO_LENGTH )*
   2.  |
   3.  (?: ZERO_LENGTH )?
   4.  }x;
\end{verbatim}

The higher level-loops preserve an additional state between iterations:
whether the last match was zero-length. To break the loop, the following
match after a zero-length match is prohibited to have a length of
zero. This prohibition interacts with backtracking (see Backtracking), and
so the second best match is chosen if the best match is of zero length.

For example:

\begin{verbatim}
   1. $_ = 'bar';
   2. s/\w??/<$&>/g;
\end{verbatim}

results in \verb|<><b><><a><><r><>| . At each position of the string the best
match given by non-greedy \verb|??| is the zero-length match, and the second
best match is what is matched by \verb|\w| . Thus zero-length matches alternate
with one-character-long matches.

Similarly, for repeated \verb|m/()/g| the second-best match is the match at
the position one notch further in the string.

The additional state of being matched with zero-length is associated with
the matched string, and is reset by each assignment to \verb|pos()|. Zero-length
matches at the end of the previous match are ignored during \verb|split|.
\end{quote}
\end{it}

\begin{exercise}
\begin{itemize}
\item
Explique la conducta del siguiente matching:
\begin{latexonly}
\begin{verbatim}
  DB<25> $c = 0

  DB<26>  print(($c++).": <$&>\n") while 'aaaabababab' =~ /a*(ab)*/g;
0: <aaaa>
1: <>
2: <a>
3: <>
4: <a>
5: <>
6: <a>
7: <>
8: <>
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
  DB&lt;25>  <span class="dbuser">$c = 0</span>

  DB&lt;26>  <span class="dbuser"> print(($c++).": &lt;$&>\n") while 'aaaabababab' =~ /a*(ab)*/g;</span>
0: &lt;aaaa>
1: &lt;>
2: &lt;a>
3: &lt;>
4: &lt;a>
5: &lt;>
6: &lt;a>
7: &lt;>
8: &lt;>
</pre>
\end{rawhtml}
%}}}
\end{itemize}
\end{exercise}

\parrafo{Cuantificadores {\it lazy}}

\label{section:nogreedy}
Las expresiones \emph{lazy} o \emph{no greedy} hacen que el NFA se detenga en la cadena mas corta que 
casa con la expresión. Se denotan como sus análogas \emph{greedy} añadiéndole el
postfijo \verb|?|:

\begin{itemize}
\item \verb|{n,m}?|
\item \verb|{n,}?|
\item \verb|{n}?|
\item \verb|*?|
\item \verb|+?|
\item \verb|??|
\end{itemize}

Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:
\begin{it}
\begin{quotation}
Sometimes greed is not good. At times, we would like quantifiers to match
a minimal piece of string, rather than a maximal piece. For this purpose,
Larry Wall created the minimal match or non-greedy quantifiers \verb|??| ,\verb|*?|, \verb|+?|, and \verb|{}?|. 
These are the usual quantifiers with a ? appended to
them. They have the following meanings:


\begin{itemize}
   \item
      \verb|a??| means: match 'a' 0 or 1 times. Try 0 first, then 1.
    \item

      \verb|a*?| means: match 'a' 0 or more times, i.e., any number of times, but as few times as possible
    \item

      \verb|a+?| means: match 'a' 1 or more times, i.e., at least once, but as few times as possible
    \item

      \verb|a{n,m}?| means: match at least n times, not more than m times, as few times as possible
    \item

      \verb|a{n,}?| means: match at least n times, but as few times as possible
    \item

      \verb|a{n}?| means: match exactly n times. Because we match exactly n times, a{n}? is equivalent to a{n} and is just there for notational consistency.
\end{itemize}

Let's look at the example above, but with minimal quantifiers:

\begin{verbatim}
   1. $x = "The programming republic of Perl";
   2. $x =~ /^(.+?)(e|r)(.*)$/; # matches,
   3. # $1 = 'Th'
   4. # $2 = 'e'
   5. # $3 = ' programming republic of Perl'
\end{verbatim}

The minimal string that will allow both the start of the string \verb|^| and
the alternation to match is \verb|Th| , with the alternation \verb#e|r# matching \verb|e|. 
The second quantifier \verb|.*| is free to gobble up the rest of the string.

\begin{verbatim}
   1. $x =~ /(m{1,2}?)(.*?)$/; # matches,
   2. # $1 = 'm'
   3. # $2 = 'ming republic of Perl'
\end{verbatim}

The first string position that this regexp can match is at the first
\verb'm' in programming . At this position, the minimal \verb|m{1,2}?| matches just
one \verb'm' . Although the second quantifier \verb|.*?| would prefer to match no
characters, it is constrained by the end-of-string anchor \verb|$| to match
the rest of the string.

\begin{verbatim}
   1. $x =~ /(.*?)(m{1,2}?)(.*)$/; # matches,
   2. # $1 = 'The progra'
   3. # $2 = 'm'
   4. # $3 = 'ming republic of Perl'
\end{verbatim}

In this regexp, you might expect the first minimal quantifier \verb|.*?| to match
the empty string, because it is not constrained by a \verb|^| anchor to match
the beginning of the word. Principle 0 applies here, however. Because it
is possible for the whole regexp to match at the start of the string, it
will match at the start of the string. Thus the first quantifier has to
match everything up to the first m. The second minimal quantifier matches
just one \verb|m| and the third quantifier matches the rest of the string.

\begin{verbatim}
   1. $x =~ /(.??)(m{1,2})(.*)$/; # matches,
   2. # $1 = 'a'
   3. # $2 = 'mm'
   4. # $3 = 'ing republic of Perl'
\end{verbatim}

Just as in the previous regexp, the first quantifier \verb|.??| can match
earliest at position \verb'a' , so it does. The second quantifier is greedy,
so it matches mm , and the third matches the rest of the string.

We can modify principle 3 above to take into account non-greedy quantifiers:

\begin{itemize}
    \item

      {\bf Principle 3:} If there are two or more elements in a regexp, the
      leftmost greedy (non-greedy) quantifier, if any, will match as much
      (little) of the string as possible while still allowing the whole
      regexp to match. The next leftmost greedy (non-greedy) quantifier,
      if any, will try to match as much (little) of the string remaining
      available to it as possible, while still allowing the whole regexp
      to match. And so on, until all the regexp elements are satisfied.
\end{itemize}
\end{quotation}
\end{it}

\begin{exercise}
Explique cuál será el resultado de el segundo comando de matching
introducido en el depurador: 
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
  DB<1> x ('1'x34) =~ m{^(11+)\1+$}
0  11111111111111111
  DB<2> x ('1'x34) =~ m{^(11+?)\1+$}
????????????????????????????????????
\end{verbatim}
\end{exercise}

\parrafo{Descripción detallada del proceso de matching}
Veamos en detalle lo que ocurre durante un matching.
Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:

\begin{it}
\begin{quotation}
Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example

\begin{verbatim}
   1. $x = "the cat in the hat";
   2. $x =~ /^(.*)(at)(.*)$/; # matches,
   3. # $1 = 'the cat in the h'
   4. # $2 = 'at'
   5. # $3 = '' (0 matches)
\end{verbatim}

\begin{enumerate}
    \item

      Start with the first letter in the string 't'.
    \item

      The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.
    \item

      'a' in the regexp element 'at' doesn't match the end of the string. Backtrack one character.
    \item

      'a' in the regexp element 'at' still doesn't match the last letter of the string 't', so backtrack one more character.
    \item

      Now we can match the 'a' and the 't'.
    \item

      Move on to the third element '.*'. Since we are at the end of the string and '.*' can match 0 times, assign it the empty string.
    \item

      We are done!
\end{enumerate}
\end{quotation}
\end{it}

\parrafo{Rendimiento}

La forma en la que se escribe una regexp puede dar lugar agrandes variaciones
en el rendimiento.
Repasemos lo que dice la sección Matching Repetitions en \pd{perlretut}{Matching-repetitions}:
\begin{it}
\begin{quotation}
Most of the time, all this moving forward and backtracking happens
quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string. A typical structure that blows up in your face is of the form

\begin{verbatim}
            /(a|b+)*/;
\end{verbatim}

The problem is the nested indeterminate quantifiers. 
There are many
different ways of partitioning a string of length n between the \verb|+| 
and \verb|*|: one repetition with \verb|b+| of length $n$, 
two repetitions with the first \verb|b+|
length $k$ and the second with length $n-k$, $m$ repetitions whose bits add
up to length $n$, etc. 

In fact there are an exponential number of ways
to partition a string as a function of its length. A regexp may get
lucky and match early in the process, but if there is no match, Perl
will try every possibility before giving up. So be careful with nested 
\verb|*|'s, \verb|{n,m}|'s, and \verb|+| 's. 

The book 
\htmladdnormallink{Mastering Regular Expressions}{http://books.google.es/books?id=NYEX-Q9evKoC\&dq=Mastering+Regular+Expressions\&printsec=frontcover\&source=bn\&hl=en\#v=onepage\&q=\&f=false} 
by Jeffrey Friedl \cite{friedl} gives a wonderful discussion of this and other efficiency issues.
\end{quotation}
\end{it}

\parrafo{Eliminación de Comentarios de un Programa C}
\label{parrfo:comments}

El siguiente ejemplo elimina los comentarios de un programa \verb|C|.
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n comments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die "Usage:\n$0 prog.c\n";
   5    open(my $PROGRAM,"<$progname") || die "can't find $progname\n";
   6    my $program = '';
   7    {
   8      local $/ = undef;
   9      $program = <$PROGRAM>;
  10    }
  11    $program =~ s{
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15    }[]gsx;
  16  
  17    print $program;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n comments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">&quot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$progname</span><span class="synConstant">&quot;</span>) || <span class="synStatement">die</span> <span class="synConstant">&quot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = &lt;<span class="synIdentifier">$PROGRAM</span>&gt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]gsx;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>

\end{rawhtml}
%}}}
Veamos un ejemplo de ejecución. Supongamos el fichero de entrada:
\begin{verbatim}
> cat hello.c
#include <stdio.h>
/* first
comment
*/
main() {
  printf("hello world!\n"); /* second comment */
}
\end{verbatim}

Entonces la ejecución con ese fichero de entrada produce
la salida:
\begin{verbatim}
> comments.pl hello.c
#include <stdio.h>
 
main() {
  printf("hello world!\n");
}
\end{verbatim}
Veamos la diferencia de comportamiento entre \verb|*| y \verb|*?|
en el ejemplo anterior:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/src/perl/perltesting$ perl5_10_1 -wde 0
main::(-e:1):   0
  DB<1>  use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*\*/)}; print "\n$1\n"
Compiling REx "(/\*.*\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT <*/> (9)
   9: CLOSE1 (11)
  11: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 <; /* 3c > <*/ }>       |  7:  EXACT <*/>(9)
  43 <; /* 3c */> < }>       |  9:  CLOSE1(11)
  43 <; /* 3c */> < }>       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: "(/\*.*\*/)"

  DB<2>  use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*?\*/)}; print "\n$1\n"
Compiling REx "(/\*.*?\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT <*/> (10)
  10: CLOSE1 (12)
  12: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*?\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*?\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:MINMOD(6)
   9 <() /*> < 1c */ { />    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 <* 1c > <*/ { /* 2c>    |  8:  EXACT <*/>(10)
  15 <1c */> < { /* 2c *>    | 10:  CLOSE1(12)
  15 <1c */> < { /* 2c *>    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: "(/\*.*?\*/)"

  DB<3>
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/src/perl/perltesting$  <span class="dbuser">perl5_10_1 -wde 0</span>
main::(-e:1):   0
  DB<1>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   STAR (7)
   6:     REG_ANY (0)
   7:   EXACT <*/> (9)
   9: CLOSE1 (11)
  11: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:STAR(7)
                                  REG_ANY can match 36 times out of 2147483647...
  41 <; /* 3c > <*/ }>       |  7:  EXACT <*/>(9)
  43 <; /* 3c */> < }>       |  9:  CLOSE1(11)
  43 <; /* 3c */> < }>       | 11:  END(0)
Match successful!

/* 1c */ { /* 2c */ return; /* 3c */
Freeing REx: "(/\*.*\*/)"

  DB<2>  <span class="dbuser"> use re 'debug'; 'main() /* 1c */ { /* 2c */ return; /* 3c */ }' =~ qr{(/\*.*?\*/)}; print "\n$1\n"</span>
Compiling REx "(/\*.*?\*/)"
Final program:
   1: OPEN1 (3)
   3:   EXACT </*> (5)
   5:   MINMOD (6)
   6:   STAR (8)
   7:     REG_ANY (0)
   8:   EXACT <*/> (10)
  10: CLOSE1 (12)
  12: END (0)
anchored "/*" at 0 floating "*/" at 2..2147483647 (checking floating) minlen 4
Guessing start of match in sv for REx "(/\*.*?\*/)" against "main() /* 1c */ { /* 2c */ return; /* 3c */ }"
Found floating substr "*/" at offset 13...
Found anchored substr "/*" at offset 7...
Starting position does not contradict /^/m...
Guessed: match at offset 7
Matching REx "(/\*.*?\*/)" against "/* 1c */ { /* 2c */ return; /* 3c */ }"
   7 <in() > </* 1c */ {>    |  1:OPEN1(3)
   7 <in() > </* 1c */ {>    |  3:EXACT </*>(5)
   9 <() /*> < 1c */ { />    |  5:MINMOD(6)
   9 <() /*> < 1c */ { />    |  6:STAR(8)
                                  REG_ANY can match 4 times out of 4...
  13 <* 1c > <*/ { /* 2c>    |  8:  EXACT <*/>(10)
  15 <1c */> < { /* 2c *>    | 10:  CLOSE1(12)
  15 <1c */> < { /* 2c *>    | 12:  END(0)
Match successful!

/* 1c */
Freeing REx: "(/\*.*?\*/)"

  DB<3>
</pre>
\end{rawhtml}
%}}}

Véase también la documentación en \pd{perlretut}{Matching-repetitions} y \pd{perlre}{Quantifiers}.

\parrafo{Negaciones y operadores {\it lazy}}
A menudo las expresiones
\verb|X[^X]*X|
y \verb|X.*?X|, donde \verb|X| es un carácter arbitrario se usan de forma casi equivalente.

\begin{itemize}
\item
La primera significa:

\begin{it}
Una cadena que no contiene \verb|X| en su interior y que está delimitada por \verb|X|s
\end{it}
\item
La segunda significa:

\begin{it}
Una cadena que comienza en \verb|X| y termina en la \verb|X| mas próxima a la \verb|X| de comienzo
\end{it}
\end{itemize}

Esta equivalencia se rompe si no se cumplen las hipótesis establecidas.

En el siguiente ejemplo se intentan detectar 
las cadenas entre comillas dobles que terminan en el signo de exclamación:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n negynogreedy.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3
     4  my $b = 'Ella dijo "Ana" y yo contesté: "Jamás!". Eso fué todo.';
     5  my $a;
     6  ($a = $b) =~ s/".*?!"/-$&-/;
     7  print "$a\n";
     8
     9  $b =~ s/"[^"]*!"/-$&-/;
    10  print "$b\n";
\end{verbatim}

Al ejecutar el programa obtenemos:
\begin{verbatim}
> negynogreedy.pl
Ella dijo -"Ana" y yo contesté: "Jamás!"-. Eso fué todo.
Ella dijo "Ana" y yo contesté: -"Jamás!"-. Eso fué todo.
\end{verbatim}

\parrafo{Copia y sustitución simultáneas}
\label{section:copia}
El operador de \emph{binding} \verb|=~| nos permite ``asociar'' la variable 
con la operación de casamiento o sustitución. Si se trata de una sustitución
y se quiere conservar la cadena, es necesario hacer una copia:
\begin{verbatim}
$d = $s;
$d =~ s/esto/por lo otro/;
\end{verbatim}
en vez de eso, puedes abreviar un poco usando la siguiente ``perla'':
\begin{verbatim}
($d = $s) =~ s/esto/por lo otro/;
\end{verbatim}
Obsérvese la asociación por la izquierda del operador de asignación.

\parrafo{Referencias a Paréntesis Previos}

Las referencias relativas permiten escribir expresiones
regulares mas reciclables.
Véase la documentación
en 
\pd{perlretut}{Relative-backreferences}:

\begin{it}
\begin{quotation}
Counting the opening parentheses to get the correct number for a
backreference is errorprone as soon as there is more than one capturing
group. A more convenient technique became available with Perl 5.10:
relative backreferences. To refer to the immediately preceding capture
group one now may write \verb|\g{-1}| , the next but last is available 
via \verb|\g{-2}|, and so on.

Another good reason in addition to readability and maintainability for
using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:

\begin{verbatim}
   1. $a99a = '([a-z])(\d)\2\1'; # matches a11a, g22g, x33x, etc.
\end{verbatim}

Now that we have this pattern stored as a handy string, we might feel
tempted to use it as a part of some other pattern:

\begin{verbatim}
   1. $line = "code=e99e";
   2. if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   3.   print "$1 is valid\n";
   4. } else {
   5.   print "bad line: '$line'\n";
   6. }
\end{verbatim}

But this doesn't match -- at least not the way one might expect. Only
after inserting the interpolated \verb|$a99a| and looking at the resulting full
text of the regexp is it obvious that the backreferences have backfired --
the subexpression \verb|(\w+)| has snatched number 1 and demoted the groups in
\verb|$a99a| by one rank. This can be avoided by using relative backreferences:

\begin{verbatim}
   1. $a99a = '([a-z])(\d)\g{-1}\g{-2}'; # safe for being interpolated
\end{verbatim}
\end{quotation}
\end{it}

El siguiente programa ilustra lo dicho:
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n backreference.pl
   1    use strict;
   2    use re 'debug';
   3  
   4    my $a99a = '([a-z])(\d)\2\1';
   5    my $line = "code=e99e";
   6    if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
   7      print "$1 is valid\n";
   8    } else {
   9      print "bad line: '$line'\n";
  10    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@millo:~/Lperltesting$ cat -n backreference.pl
<span class="synLinenum">    1</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>re <span class="synConstant">'debug'</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$a99a</span> = <span class="synConstant">'([a-z])(\d)\2\1'</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">&quot;code=e99e&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$line</span> =~<span class="synStatement"> /</span><span class="synConstant">^</span><span class="synSpecial">(\w+)</span><span class="synConstant">=</span><span class="synIdentifier">$a99a</span><span class="synConstant">$</span><span class="synStatement">/</span>){ <span class="synComment"># unexpected behavior!</span>
<span class="synLinenum">    7</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$1</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    8</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">    9</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;bad line: '</span><span class="synIdentifier">$line</span><span class="synConstant">'</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   10</span>   }
</pre>

\end{rawhtml}
%}}}
Sigue la ejecución:
\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wd backreference.pl
main::(backreference.pl:4):     my $a99a = '([a-z])(\d)\2\1';
  DB<1> c 6
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB<2> x ($line =~ /^(\w+)=$a99a$/)
  empty array
  DB<4> $a99a = '([a-z])(\d)\g{-1}\g{-2}'
  DB<5> x ($line =~ /^(\w+)=$a99a$/)
0  'code'
1  'e'
2  9
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
casiano@millo:~/Lperltesting$  <span class="dbuser">perl5.10.1 -wd backreference.pl</span>
main::(backreference.pl:4):     my $a99a = '([a-z])(\d)\2\1';
  DB<1>  <span class="dbuser">c 6</span>
main::(backreference.pl:6):     if ($line =~ /^(\w+)=$a99a$/){ # unexpected behavior!
  DB<2>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
  empty array
  DB<4>  <span class="dbuser">$a99a = '([a-z])(\d)\g{-1}\g{-2}'</span>
  DB<5>  <span class="dbuser">x ($line =~ /^(\w+)=$a99a$/)</span>
0  'code'
1  'e'
2  9
</pre>
\end{rawhtml}
%}}}

\parrafo{Usando Referencias con Nombre (Perl 5.10)}

El siguiente texto esta tomado de 
\pd{perlretut}{Named-backreferences}:

\begin{it}
\begin{quotation}
Perl 5.10 also introduced named capture buffers and named
backreferences. To attach a name to a capturing group, you write either
\verb#(?<name>...)# or \verb#(?'name'...)#. The backreference may then be written
as \verb#\g{name}# . 

It is permissible to attach the same name to more than
one group, but then only the leftmost one of the eponymous set can be
referenced. Outside of the pattern a named capture buffer is accessible
through the \verb|%+| hash.

Assuming that we have to match calendar dates which may be given in one
of the three formats \verb|yyyy-mm-dd|, \verb|mm/dd/yyyy| or \verb|dd.mm.yyyy|, 
we can write
three suitable patterns where we use \verb|'d'|, \verb|'m'| and \verb|'y'| respectively as the
names of the buffers capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:

\begin{verbatim}
   1.  $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
   2.  $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
   3.  $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
   4.  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
   5.    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
   6.      print "day=$+{d} month=$+{m} year=$+{y}\n";
   7.    }
   8.  }
\end{verbatim}

If any of the alternatives matches, the hash \verb|%+| 
is bound to contain the three key-value pairs.
\end{quotation}
\end{it}
En efecto, al ejecutar el programa:
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n namedbackreferences.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $fmt1 = '(?<y>\d\d\d\d)-(?<m>\d\d)-(?<d>\d\d)';
     5  my $fmt2 = '(?<m>\d\d)/(?<d>\d\d)/(?<y>\d\d\d\d)';
     6  my $fmt3 = '(?<d>\d\d)\.(?<m>\d\d)\.(?<y>\d\d\d\d)';
     7
     8  for my $d qw( 2006-10-21 15.01.2007 10/31/2005 ){
     9    if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
    10      print "day=$+{d} month=$+{m} year=$+{y}\n";
    11    }
    12  }
\end{verbatim}
Obtenemos la salida:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -w namedbackreferences.pl
day=21 month=10 year=2006
day=15 month=01 year=2007
day=31 month=10 year=2005
\end{verbatim}

Como se comentó:

\begin{it}
\begin{quotation}
... It is permissible to attach the same name to more than
one group, but then only the leftmost one of the eponymous set can be
referenced. 
\end{quotation}
\end{it}

Veamos un ejemplo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
DB<1>  # ... only the leftmost one of the eponymous set can be referenced
DB<2> $r = qr{(?<a>[a-c])(?<a>[a-f])}
DB<3> print $+{a} if 'ad' =~ $r
a
DB<4> print $+{a} if 'cf' =~ $r
c
DB<5> print $+{a} if 'ak' =~ $r

\end{verbatim}

Reescribamos el ejemplo de conversión de temperaturas usando
paréntesis con nombre:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n c2f_5_10v2.pl
 1  #!/usr/local/bin/perl5_10_1 -w
 2  use strict;
 3
 4  print "Enter a temperature (i.e. 32F, 100C):\n";
 5  my $input = <STDIN>;
 6  chomp($input);
 7
 8  $input =~ m/^
 9              (?<farenheit>[-+]?[0-9]+(?:\.[0-9]*)?)\s*[fF]
10              |
11              (?<celsius>[-+]?[0-9]+(?:\.[0-9]*)?)\s*[cC]
12           $/x;
13
14  my ($celsius, $farenheit);
15  if (exists $+{celsius}) {
16    $celsius = $+{celsius};
17    $farenheit = ($celsius * 9/5)+32;
18  }
19  elsif (exists $+{farenheit}) {
20    $farenheit = $+{farenheit};
21    $celsius = ($farenheit -32)*5/9;
22  }
23  else {
24    die "Expecting a temperature, so don't understand \"$input\".\n";
25  }
26
27  printf "%.2f C = %.2f F\n", $celsius, $farenheit;
\end{verbatim}

La función \perldocf{exists} retorna verdadero si existe la clave en el hash
y falso en otro caso.  

\parrafo{Grupos con Nombre y Factorización}

El uso de nombres hace mas robustas y mas factorizables
las expresiones regulares.
Consideremos la siguiente regexp que usa notación posicional:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x "abbacddc" =~ /(.)(.)\2\1/
0  'a'
1  'b'
\end{verbatim}
Supongamos que queremos reutilizar la regexp con repetición
\begin{verbatim}
  DB<2> x "abbacddc" =~ /((.)(.)\2\1){2}/
  empty array
\end{verbatim}
¿Que ha ocurrido? La introducción del nuevo paréntesis 
nos obliga a renombrar las referencias a las posiciones:
\begin{verbatim}
  DB<3> x "abbacddc" =~ /((.)(.)\3\2){2}/
0  'cddc'
1  'c'
2  'd'
  DB<4> "abbacddc" =~ /((.)(.)\3\2){2}/; print "$&\n"
abbacddc
\end{verbatim}
Esto no ocurre si utilizamos nombres. 
El operador \verb|\k<a>| sirve para hacer referencia
al valor que ha casado con el paréntesis con nombre \verb|a|:
\begin{verbatim}
  DB<5> x "abbacddc" =~ /((?<a>.)(?<b>.)\k<b>\k<a>){2}/
0  'cddc'
1  'c'
2  'd'
\end{verbatim}
El uso de grupos con nombre y 
\verb|\k|\footnote{
Una diferencia entre {\tt $\backslash k$} y {\tt $\backslash g$} es que el primero 
sólo admite un nombre como argumento  mientras que {\tt $\backslash g$}
admite enteros}
en lugar de referencias numéricas absolutas
hace que la regexp sea mas reutilizable.

\parrafo{LLamadas a expresiones regulares via paréntesis con memoria}

Es posible también llamar a la expresión regular
asociada con un paréntesis.

Este parrafo tomado de
\pd{perlre}{Extended-Patterns} 
explica el modo de uso:

\begin{it}
\verb|(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)|
\begin{quotation}

\verb|PARNO| is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture buffer to recurse to. 

....

Capture buffers contained by the pattern will have the value as determined by the outermost recursion.
....

If \verb|PARNO| {\bf is preceded by a plus or minus sign then it is assumed to
be relative, with negative numbers indicating preceding capture buffers
and positive ones following}. Thus \verb|(?-1)| refers to the most recently
declared buffer, and \verb|(?+1)| indicates the next buffer to be declared. 

{\bf Note
that the counting for relative recursion differs from that of relative
backreferences, in that with recursion unclosed buffers are included.}
\end{quotation}
\end{it}

Veamos un ejemplo:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x "AABB" =~ /(A)(?-1)(?+1)(B)/
0  'A'
1  'B'
  # Parenthesis:       1   2   2                  1
  DB<2> x 'ababa' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'ababa'
1  'a'
  DB<3> x 'bbabababb' =~ /^((?:([ab])(?1)\g{-1}|[ab]?))$/
0  'bbabababb'
1  'b'
\end{verbatim}

Véase también:
\begin{itemize}
\item
\htmladdnormallink
{Perl Training Australia: Regular expressions in Perl 5.10}
{http://perltraining.com.au/tips/2008-02-08.html}
\item
\htmladdnormallink
{Perl 5.10 Advanced Regular Expressions by Yves Orton}
{http://www.regex-engineer.org/slides/perl510_regex.html}
\item
\htmladdnormallink
{Gabor: Regular Expressions in Perl 5.10}
{http://szabgab.com/blog/2007/12/1198488988.html}
\end{itemize}

\parrafo{Reutilizando Expresiones Regulares}

La siguiente reescritura de nuestro ejemplo básico
utiliza el módulo \cpan{Regexp::Common} para factorizar
la expresión regular:

\begin{verbatim}
casiano@millo:~/src/perl/perltesting$ cat -n c2f_5_10v3.pl
 1  #!/soft/perl5lib/bin/perl5.10.1 -w
 2  use strict;
 3  use Regexp::Common;
 4
 5  print "Enter a temperature (i.e. 32F, 100C):\n";
 6  my $input = <STDIN>;
 7  chomp($input);
 8
 9  $input =~ m/^
10              (?<farenheit>$RE{num}{real})\s*[fF]
11              |
12              (?<celsius>$RE{num}{real})\s*[cC]
13           $/x;
14
15  my ($celsius, $farenheit);
16  if ('celsius' ~~ %+) {
17    $celsius = $+{celsius};
18    $farenheit = ($celsius * 9/5)+32;
19  }
20  elsif ('farenheit' ~~ %+) {
21    $farenheit = $+{farenheit};
22    $celsius = ($farenheit -32)*5/9;
23  }
24  else {
25    die "Expecting a temperature, so don't understand \"$input\".\n";
26  }
27
28  printf "%.2f C = %.2f F\n", $celsius, $farenheit;
\end{verbatim}

Véase:
\begin{itemize}
\item La documentación del módulo \cpan{Regexp::Common} por Abigail
\item Smart Matching: \htmladdnormallink
{Perl Training Australia: Smart Match}
{http://perltraining.com.au/tips/2008-04-18.html}
\item
Rafael García Suárez:
\pd{perlsyn}{Smart-matching-in-detail}
\item
\htmladdnormallink{Enrique Nell (Barcelona Perl Mongers): Novedades en Perl 5.10}{www.opensourceworldconference.com/papers/.../Nell\_370.pdf}
%\item
%\htmladdnormallink
%{Rafael García Suárez: Smart matching in detail}
%{http://search.cpan.org/~rgarcia/perl-5.10.0/pod/perlsyn.pod#Smart_matching_in_detail}
\end{itemize}


\parrafo{El Módulo Regexp::Common}

El módulo \cpan{Regexp::Common} provee un extenso número 
de expresiones regulares que son accesibles vía el hash \verb|%RE|.
sigue un ejemplo de uso:
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n regexpcommonsynopsis.pl
     1  use strict;
     2  use Perl6::Say;
     3  use Regexp::Common;
     4
     5  while (<>) {
     6      say q{a number}              if /$RE{num}{real}/;
     7
     8      say q{a ['"`] quoted string} if /$RE{quoted}/;
     9
    10      say q{a /.../ sequence}      if m{$RE{delimited}{'-delim'=>'/'}};
    11
    12      say q{balanced parentheses}  if /$RE{balanced}{'-parens'=>'()'}/;
    13
    14      die q{a #*@%-ing word}."\n"  if /$RE{profanity}/;
    15
    16  }
    17
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl regexpcommonsynopsis.pl
43
a number
"2+2 es" 4
a number
a ['"`] quoted string
x/y/z
a /.../ sequence
(2*(4+5/(3-2)))
a number
balanced parentheses
fuck you!
a #*@%-ing word
\end{verbatim}

El siguiente fragmento de la documentación 
de \cpan{Regexp::Common}
explica el modo simplificado de uso:

\begin{it}
\begin{quote}
To access a particular pattern, \verb|%RE| is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you specify:

\begin{verbatim}
        $RE{num}{real}
\end{verbatim}

and to access the pattern that matches integers:

\begin{verbatim}
        $RE{num}{int}
\end{verbatim}

Deeper layers of the hash are used to specify flags: 
arguments that modify
the resulting pattern in some way. 

\begin{itemize}
\item
The keys used to access these layers
are prefixed with a minus sign and may have a value; 
\item
if a value is given,
it's done by using a multidimensional key. 
\end{itemize}
For example, to access the
pattern that matches base-2 real numbers with embedded commas separating
groups of three digits (e.g. \verb|10,101,110.110101101|):

\begin{verbatim}
        $RE{num}{real}{-base => 2}{-sep => ','}{-group => 3}
\end{verbatim}

Through the magic of Perl, these flag layers may be specified in any
order (and even interspersed through the identifier keys!) so you could
get the same pattern with:

\begin{verbatim}
        $RE{num}{real}{-sep => ','}{-group => 3}{-base => 2}
\end{verbatim}

or:

\begin{verbatim}
        $RE{num}{-base => 2}{real}{-group => 3}{-sep => ','}
\end{verbatim}

or even:

\begin{verbatim}
        $RE{-base => 2}{-group => 3}{-sep => ','}{num}{real}
\end{verbatim}

etc.

Note, however, that the relative order of amongst the identifier keys is significant. That is:

\begin{verbatim}
        $RE{list}{set}
\end{verbatim}

would not be the same as:

\begin{verbatim}
        $RE{set}{list}
\end{verbatim}
\end{quote}
\end{it}

Veamos un ejemplo con el depurador:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
  DB<1> x 'numero: 10,101,110.110101101 101.1e-1 234' =~ m{($RE{num}{real}{-base => 2}{-sep => ','}{-group => 3})}g
0  '10,101,110.110101101'
1  '101.1e-1'
\end{verbatim}

La expresión regular para un número real es 
relativamente compleja:

\begin{verbatim}
casiano@millo:~/src/perl/perltesting$ perl5.10.1 -wd c2f_5_10v3.pl
main::(c2f_5_10v3.pl:5):     print "Enter a temperature (i.e. 32F, 100C):\n";
  DB<1> p $RE{num}{real}
(?:(?i)(?:[+-]?)(?:(?=[0123456789]|[.])(?:[0123456789]*)(?:(?:[.])(?:[0123456789]{0,}))?)(?:(?:[E])(?:(?:[+-]?)(?:[0123456789]+))|))
\end{verbatim}

Si se usa la opción \verb|-keep| el patrón proveído usa paréntesis con memoria:
\begin{verbatim}
casiano@millo:~/Lperltesting$ perl -MRegexp::Common -wde 0
main::(-e:1):   0
DB<2> x 'one, two, three, four, five' =~ /$RE{list}{-pat => '\w+'}/
0  1
DB<3> x 'one, two, three, four, five' =~ /$RE{list}{-pat => '\w+'}{-keep}/
0  'one, two, three, four, five'
1  ', '
\end{verbatim}
%Sigue un ejemplo de ejecución:
%
%\begin{verbatim}
%casiano@millo:~/Lperltesting$ env | grep -i perl
%MANPATH=:/soft/perl5lib/man/
%PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:/soft/perl5lib/lib/perl/5.8:/soft/perl5lib/share/perl/5.8/
%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:
%      /soft/perl5lib/bin:/soft/perl5lib/src/parrot-0.8.0/:/home/casiano/bin
%PWD=/home/casiano/Lperltesting
%casiano@millo:~/Lperltesting$ unset PERL5LIB
%casiano@millo:~/Lperltesting$ env | grep -i perl
%MANPATH=:/soft/perl5lib/man/
%PATH=.:/usr/lib/oracle/11.1.0.1/client/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:...:/soft/perl5lib/src/parrot-0.8.0/
%PWD=/home/casiano/Lperltesting
%casiano@millo:~/Lperltesting$ ./c2f_5_10v3.pl
%Can't locate Regexp/Common.pm in @INC (@INC contains: /soft/perl5lib/perl5_10_1/lib/5.10.1/i686-linux-thread-multi 
%                                                      /soft/perl5lib/perl5_10_1/lib/5.10.1 
%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1/i686-linux-thread-multi 
%                                                      /soft/perl5lib/perl5_10_1/lib/site_perl/5.10.1 .) 
%at ./c2f_5_10v3.pl line 3.
%BEGIN failed--compilation aborted at ./c2f_5_10v3.pl line 3.
%\end{verbatim}
%
%Reutilicemos la versión de la librería instalada para la 5.8.8:
%
%\begin{verbatim}
%casiano@millo:~/Lperltesting$ export PERL5LIB=/soft/perl5lib/share/perl/5.8.8/:/soft/perl5lib/lib/perl/5.8.8:...
%casiano@millo:~/Lperltesting$ perldoc -l Regexp::Common
%/soft/perl5lib/share/perl/5.8.8/Regexp/Common.pm
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%-32.0e-1f
%-19.56 C = -3.20 F
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%-0.0e-0c
%-0.00 C = 32.00 F
%casiano@millo:~/Lperltesting$ perl5.10.1 -I/soft/perl5lib/share/perl/5.8.8/ ./c2f_5_10v3.pl
%Enter a temperature (i.e. 32F, 100C):
%45
%Expecting a temperature, so don't understand "45".
%\end{verbatim}
%En general, no es buena idea mezclar librerías de diferentes instalaciones.

\parrafo{Smart Matching}

Perl 5.10 introduce el operador de smart matching.
El siguiente texto es tomado casi verbatim del site de la compañía 
\htmladdnormallink{Perl Training Australia}{http://perltraining.com.au/tips/2008-04-18.html}\footnote{
This Perl tip and associated text is copyright Perl Training Australia}:
\begin{it}
\begin{quotation}
Perl 5.10 introduces a new-operator, called smart-match, written \verb|~~|. As
the name suggests, smart-match tries to compare its arguments in an
intelligent fashion. Using smart-match effectively allows many complex
operations to be reduces to very simple statements.

Unlike many of the other features introduced in Perl 5.10, there's no
need to use the feature pragma to enable smart-match, as long as you're
using 5.10 it's available.

The smart-match operator is always commutative. That means that 
\verb|$x ~~ $y| works the same way as 
\verb|$y ~~ $x|. You'll never have to remember which
order to place to your operands with smart-match.
Smart-match in action.

As a simple introduction, we can use smart-match to do a simple string comparison between simple scalars. For example:

\begin{verbatim}
    use feature qw(say);

    my $x = "foo";
    my $y = "bar";
    my $z = "foo";

    say '$x and $y are identical strings' if $x ~~ $y;
    say '$x and $z are identical strings' if $x ~~ $z;    # Printed
\end{verbatim}

If one of our arguments is a number, then a numeric comparison is performed:

\begin{verbatim}
    my $num   = 100;
    my $input = <STDIN>;

    say 'You entered 100' if $num ~~ $input;
\end{verbatim}

This will print our message if our user enters 100, 100.00, +100, 1e2, or
any other string that looks like the number 100. 

We can also smart-match
against a regexp:

\begin{verbatim}
    my $input  = <STDIN>;

    say 'You said the secret word!' if $input ~~ /xyzzy/;
\end{verbatim}

Smart-matching with a regexp also works with saved regexps created with qr{}.

So we can use smart-match to act like eq, \verb|==| and 
\verb|=~|, so what? Well, it does much more than that. 

We can use smart-match to search a list:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB<2> print "You're a friend" if 'Pippin' ~~ @friends
You're a friend
  DB<3> print "You're a friend" if 'Mordok' ~~ @friends

\end{verbatim}

It's important to note that searching an array with smart-match is
extremely fast. It's faster than using grep, it's faster than using
\verb|first| from \cpan{Scalar::Util}, and it's faster than walking through the loop
with \verb|foreach|, even if you do know all the clever optimisations.

Esta es la forma típica de buscar un elemento en un array en 
versiones anteriores a la 5.10:
\begin{verbatim}
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB<1> use List::Util qw{first}
  DB<2> @friends = qw(Frodo Meriadoc Pippin Samwise Gandalf)
  DB<3> x first { $_ eq 'Pippin'} @friends
0  'Pippin'
  DB<4> x first { $_ eq 'Mordok'} @friends
0  undef
\end{verbatim}

We can also use smart-match to compare arrays:

\begin{verbatim}
  DB<4> @foo = qw(x y z xyzzy ninja)
  DB<5> @bar = qw(x y z xyzzy ninja)
  DB<7> print "Identical arrays" if @foo ~~ @bar
Identical arrays
  DB<8> @bar = qw(x y z xyzzy nOnjA)
  DB<9> print "Identical arrays" if @foo ~~ @bar
  DB<10>     
\end{verbatim}

And even search inside an array using a string:

\begin{verbatim}
 DB<11> x @foo = qw(x y z xyzzy ninja)
0  'x'
1  'y'
2  'z'
3  'xyzzy'
4  'ninja'
  DB<12> print "Array contains a ninja " if @foo ~~ 'ninja'
\end{verbatim}

or using a regexp:

\begin{verbatim}
  DB<13> print "Array contains magic pattern" if @foo ~~ /xyz/
Array contains magic pattern
  DB<14> print "Array contains magic pattern" if @foo ~~ /\d+/

\end{verbatim}

Smart-match works with array references, too\footnote{En este caso la conmutatividad no funciona}:

\begin{verbatim}
  DB<16> $array_ref = [ 1..10 ]
  DB<17> print "Array contains 10" if 10 ~~ $array_ref
Array contains 10
  DB<18> print "Array contains 10" if $array_ref ~~ 10
  DB<19>     
\end{verbatim}

En el caso de un número y un array devuelve cierto si el escalar aparece 
en un array anidado:

\begin{verbatim}
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say "ok" if 42 ~~  [23, 17, [40..50], 70];'
ok
casiano@millo:~/Lperltesting$ perl5.10.1 -E 'say "ok" if 42 ~~  [23, 17, [50..60], 70];'
casiano@millo:~/Lperltesting$                                                           
\end{verbatim}

Of course, we can use smart-match with more than just arrays and scalars,
it works with searching for the key in a hash, too!

\begin{verbatim}
  DB<19> %colour = ( sky   => 'blue', grass => 'green', apple => 'red',)
  DB<20> print "I know the colour" if 'grass' ~~ %colour
I know the colour
  DB<21> print "I know the colour" if 'cloud' ~~ %colour
  DB<22>
  DB<23> print "A key starts with 'gr'" if %colour ~~ /^gr/
A key starts with 'gr'
  DB<24> print "A key starts with 'clou'" if %colour ~~ /^clou/
  DB<25>
\end{verbatim}

You can even use it to see if the two hashes have identical keys:

\begin{verbatim}
  DB<26> print 'Hashes have identical keys' if %taste ~~ %colour;
Hashes have identical keys
\end{verbatim}
\end{quotation}
\end{it}

La conducta del operador de smart matching viene dada por la siguiente
tabla tomada de \pd{perlsyn}{Smart-matching-in-detail}:

\begin{it}
\begin{quotation}
The behaviour of a smart match depends on what type of thing its arguments
are. The behaviour is determined by the following table: 
the first
row that applies determines the match behaviour (which is thus mostly
determined by the type of the right operand). 
Note that the smart match
implicitly dereferences any non-blessed hash or array ref, so the "Hash"
and "Array" entries apply in those cases. (For blessed references, the
"Object" entries apply.)

Note that the "Matching Code" column is not always an exact rendition. For
example, the smart match operator short-circuits whenever possible,
but grep does not.

\begin{center}
\begin{verbatim}
 $a      $b        Type of Match Implied    Matching Code
 ======  =====     =====================    =============
 Any     undef     undefined                !defined $a

 Any     Object    invokes ~~ overloading on $object, or dies

 Hash    CodeRef   sub truth for each key[1] !grep { !$b->($_) } keys %$a
 Array   CodeRef   sub truth for each elt[1] !grep { !$b->($_) } @$a
 Any     CodeRef   scalar sub truth          $b->($a)

 Hash    Hash      hash keys identical (every key is found in both hashes)
 Array   Hash      hash slice existence     grep { exists $b->{$_} } @$a
 Regex   Hash      hash key grep            grep /$a/, keys %$b
 undef   Hash      always false (undef can't be a key)
 Any     Hash      hash entry existence     exists $b->{$a}

 Hash    Array     hash slice existence     grep { exists $a->{$_} } @$b
 Array   Array     arrays are comparable[2]
 Regex   Array     array grep               grep /$a/, @$b
 undef   Array     array contains undef     grep !defined, @$b
 Any     Array     match against an array element[3]
                                            grep $a ~~ $_, @$b

 Hash    Regex     hash key grep            grep /$b/, keys %$a
 Array   Regex     array grep               grep /$b/, @$a
 Any     Regex     pattern match            $a =~ /$b/

 Object  Any       invokes ~~ overloading on $object, or falls back:
 Any     Num       numeric equality         $a == $b
 Num     numish[4] numeric equality         $a == $b
 undef   Any       undefined                !defined($b)
 Any     Any       string equality          $a eq $b
\end{verbatim}
\end{center}

\end{quotation}
\end{it}

\parrafo{Ejercicios}

\begin{exercise}
\begin{itemize}
\item
Indique la salida del siguiente programa:
\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat twonumbers.pl
  2  $_ = "I have 2 numbers: 53147";
  3  @pats = qw{
  4    (.*)(\d*)
  5    (.*)(\d+)
  6    (.*?)(\d*)
  7    (.*?)(\d+)
  8    (.*)(\d+)$
  9    (.*?)(\d+)$
 10    (.*)\b(\d+)$
 11    (.*\D)(\d+)$
 12  };
 13  
 14  print "$_\n";
 15  for $pat (@pats) {
 16    printf "%-12s ", $pat;
 17    <>;
 18    if ( /$pat/ ) {
 19      print "<$1> <$2>\n";
 20    } else {
 21      print "FAIL\n";
 22    }
 23  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat twonumbers</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synIdentifier">$_</span><span class="synConstant"> = &quot;I have 2 numbers: 53147&quot;;</span>
<span class="synLinenum">    3</span> <span class="synIdentifier">@pats</span><span class="synConstant"> = qw{</span>
<span class="synLinenum">    4</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d*)</span>
<span class="synLinenum">    5</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span>
<span class="synLinenum">    6</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d*)</span>
<span class="synLinenum">    7</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span>
<span class="synLinenum">    8</span> <span class="synConstant">  </span><span class="synSpecial">(.*)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">    9</span> <span class="synConstant">  </span><span class="synSpecial">(.*?)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   10</span> <span class="synConstant">  </span><span class="synSpecial">(.*)\b(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   11</span> <span class="synConstant">  </span><span class="synSpecial">(.*\D)(\d+)</span><span class="synConstant">$</span>
<span class="synLinenum">   12</span> <span class="synConstant">};</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">print &quot;</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">&quot;;</span>
<span class="synLinenum">   15</span> <span class="synConstant">for </span><span class="synIdentifier">$pat</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@pats</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synLinenum">   16</span> <span class="synConstant">  printf &quot;%-12s &quot;, </span><span class="synIdentifier">$pat</span><span class="synConstant">;</span>
<span class="synLinenum">   17</span> <span class="synConstant">  &lt;&gt;;</span>
<span class="synLinenum">   18</span> <span class="synConstant">  if </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synStatement">/</span><span class="synIdentifier">$pat</span>/ ) {
<span class="synLinenum">   19</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$1</span><span class="synConstant">&gt; &lt;</span><span class="synIdentifier">$2</span><span class="synConstant">&gt;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   20</span>   } <span class="synStatement">else</span> {
<span class="synLinenum">   21</span>     <span class="synStatement">print</span> <span class="synConstant">&quot;FAIL</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   22</span>   }
<span class="synLinenum">   23</span> }
</pre>

\end{rawhtml}
%}}}
\end{itemize}

\end{exercise}


\subsection{Depuración de Expresiones Regulares}

Para obtener información sobre la forma en que es compilada una expresión regular
y como se produce el proceso de matching podemos usar la opción
\verb|'debug'| del módulo \verb|re|. La versión de Perl 5.10 da una información 
algo mas legible que la de las versiones anteriores:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5_10_1 -wde 0

Loading DB routines from perl5db.pl version 1.32
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(-e:1):   0
  DB<1> use re 'debug'; 'astr' =~ m{[sf].r}
Compiling REx "[sf].r"
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT <r> (15)
  15: END (0)
anchored "r" at 2 (checking anchored) stclass ANYOF[fs][] minlen 3
Guessing start of match in sv for REx "[sf].r" against "astr"
Found anchored substr "r" at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx "[sf].r" against "str"
   1 <a> <str>               |  1:ANYOF[fs][](12)
   2 <as> <tr>               | 12:REG_ANY(13)
   3 <ast> <r>               | 13:EXACT <r>(15)
   4 <astr> <>               | 15:END(0)
Match successful!
Freeing REx: "[sf].r"
\end{verbatim}

Si se usa la opción \verb|debug| de \verb|re| con 
objetos expresión regular, se obtendrá información durante el proceso de 
matching:
\begin{verbatim}
 DB<3> use re 'debug'; $re = qr{[sf].r}
Compiling REx "[sf].r"
Final program:
   1: ANYOF[fs][] (12)
  12: REG_ANY (13)
  13: EXACT <r> (15)
  15: END (0)
anchored "r" at 2 (checking anchored) stclass ANYOF[fs][] minlen 3

  DB<4> 'astr' =~ $re
Guessing start of match in sv for REx "[sf].r" against "astr"
Found anchored substr "r" at offset 3...
Starting position does not contradict /^/m...
start_shift: 2 check_at: 3 s: 1 endpos: 2
Does not contradict STCLASS...
Guessed: match at offset 1
Matching REx "[sf].r" against "str"
   1 <a> <str>               |  1:ANYOF[fs][](12)
   2 <as> <tr>               | 12:REG_ANY(13)
   3 <ast> <r>               | 13:EXACT <r>(15)
   4 <astr> <>               | 15:END(0)
Match successful!
\end{verbatim}

\subsection{Tablas de Escapes, Metacarácteres, Cuantificadores, Clases}
\label{section:abreviadas}
Sigue una sección de tablas con 
notaciones tomada de \perldoc{perlre}:

%\begin{tabular}{l|l}
%C\'{o}digo    & Significado \\
%\hline
%\verb|\d| & \verb|[0-9]|\\
%\verb|\D| & \verb|[^0-9]|\\
%\verb|\w| & \verb|[a-zA-Z0-9_]|\\
%\verb|\W| & \verb|[^a-zA-Z0-9_]|\\
%\verb|\s| & \verb|[ \t\n\r\f]|\\
%\verb|\S| & \verb|[^ \t\n\r\f]|\\
%\end{tabular}

\parrafo{Metacharacters}

The following metacharacters have their standard egrep-ish meanings:

\begin{verbatim}
   1. \ Quote the next metacharacter
   2. ^ Match the beginning of the line
   3. . Match any character (except newline)
   4. $ Match the end of the line (or before newline at the end)
   5. | Alternation
   6. () Grouping
   7. [] Character class
\end{verbatim}


\parrafo{Standard greedy quantifiers}

The following standard greedy quantifiers are recognized:

\begin{verbatim}
   1. * Match 0 or more times
   2. + Match 1 or more times
   3. ? Match 1 or 0 times
   4. {n} Match exactly n times
   5. {n,} Match at least n times
   6. {n,m} Match at least n but not more than m times
\end{verbatim}

\parrafo{Non greedy quantifiers}

The following non greedy quantifiers are recognized:

\begin{verbatim}
   1. *? Match 0 or more times, not greedily
   2. +? Match 1 or more times, not greedily
   3. ?? Match 0 or 1 time, not greedily
   4. {n}? Match exactly n times, not greedily
   5. {n,}? Match at least n times, not greedily
   6. {n,m}? Match at least n but not more than m times, not greedily
\end{verbatim}


\parrafo{Possesive quantifiers}

The following possesive quantifiers are recognized:

\begin{verbatim}
   1. *+ Match 0 or more times and give nothing back
   2. ++ Match 1 or more times and give nothing back
   3. ?+ Match 0 or 1 time and give nothing back
   4. {n}+ Match exactly n times and give nothing back (redundant)
   5. {n,}+ Match at least n times and give nothing back
   6. {n,m}+ Match at least n but not more than m times and give nothing back
\end{verbatim}

\parrafo{Escape sequences}

\begin{verbatim}
   1. \t tab (HT, TAB)
   2. \n newline (LF, NL)
   3. \r return (CR)
   4. \f form feed (FF)
   5. \a alarm (bell) (BEL)
   6. \e escape (think troff) (ESC)
   7. \033 octal char (example: ESC)
   8. \x1B hex char (example: ESC)
   9. \x{263a} long hex char (example: Unicode SMILEY)
  10. \cK control char (example: VT)
  11. \N{name} named Unicode character
  12. \l lowercase next char (think vi)
  13. \u uppercase next char (think vi)
  14. \L lowercase till \E (think vi)
  15. \U uppercase till \E (think vi)
  16. \E end case modification (think vi)
  17. \Q quote (disable) pattern metacharacters till \E
\end{verbatim}

\begin{exercise}
Explique la salida:
\begin{verbatim}
casiano@tonga:~$ perl -wde 0
main::(-e:1):   0
  DB<1> $x = '([a-z]+)'
  DB<2> x 'hola' =~ /$x/
0  'hola'
  DB<3> x 'hola' =~ /\Q$x/
  empty array
  DB<4> x '([a-z]+)' =~ /\Q$x/
0  1
\end{verbatim}
\end{exercise}

\parrafo{Character Classes and other Special Escapes}

\begin{verbatim}
   1. \w Match a "word" character (alphanumeric plus "_")
   2. \W Match a non-"word" character
   3. \s Match a whitespace character
   4. \S Match a non-whitespace character
   5. \d Match a digit character
   6. \D Match a non-digit character
   7. \pP Match P, named property. Use \p{Prop} for longer names.
   8. \PP Match non-P
   9. \X Match eXtended Unicode "combining character sequence",
  10.    equivalent to (?>\PM\pM*)
  11. \C Match a single C char (octet) even under Unicode.
  12.    NOTE: breaks up characters into their UTF-8 bytes,
  13.    so you may end up with malformed pieces of UTF-8.
  14.    Unsupported in lookbehind.
  15. \1 Backreference to a specific group.
  16. '1' may actually be any positive integer.
  17. \g1 Backreference to a specific or previous group,
  18. \g{-1} number may be negative indicating a previous buffer and may
  19.        optionally be wrapped in curly brackets for safer parsing.
  20. \g{name} Named backreference
  21. \k<name> Named backreference
  22. \K Keep the stuff left of the \K, don't include it in $&
  23. \v Vertical whitespace
  24. \V Not vertical whitespace
  25. \h Horizontal whitespace
  26. \H Not horizontal whitespace
  27. \R Linebreak
\end{verbatim}

\parrafo{Zero width assertions}

Perl defines the following zero-width assertions:

\begin{verbatim}
   1. \b Match a word boundary
   2. \B Match except at a word boundary
   3. \A Match only at beginning of string
   4. \Z Match only at end of string, or before newline at the end
   5. \z Match only at end of string
   6. \G Match only at pos() (e.g. at the end-of-match position
   7. of prior m//g)
\end{verbatim}


\subsubsection{The POSIX character class syntax}

The POSIX character class syntax:

\begin{verbatim}
   1. [:class:]
\end{verbatim}

is also available. Note that the \verb|[| and \verb|]| brackets are literal; 
they must always be used within a character class expression.

\begin{verbatim}
   1. # this is correct:
   2. $string =~ /[[:alpha:]]/;
   3.
   4. # this is not, and will generate a warning:
   5. $string =~ /[:alpha:]/;
\end{verbatim}

\parrafo{Available classes}

The available classes and their backslash equivalents (if available) are as follows:

\begin{verbatim}
   1. alpha
   2. alnum
   3. ascii
   4. blank
   5. cntrl
   6. digit \d
   7. graph
   8. lower
   9. print
  10. punct
  11. space \s 
  12. upper
  13. word \w 
  14. xdigit
\end{verbatim}


For example use \verb|[:upper:]| to match all the uppercase characters. 
Note that the \verb|[]| are part of the \verb|[::]|
construct, not part of the whole character class. For example:

\begin{verbatim}
   1. [01[:alpha:]%]
\end{verbatim}

matches zero, one, any alphabetic character, and the percent sign.

\parrafo{Equivalences to Unicode}

The following equivalences to Unicode 
\verb|\p{}| constructs and equivalent backslash 
character classes (if available), will hold:

\begin{verbatim}
   1. [[:...:]] \p{...} backslash
   2.
   3. alpha IsAlpha
   4. alnum IsAlnum
   5. ascii IsASCII
   6. blank
   7. cntrl IsCntrl
   8. digit IsDigit \d
   9. graph IsGraph
  10. lower IsLower
  11. print IsPrint 
  12. punct IsPunct 
  13. space IsSpace
  14. IsSpacePerl \s
  15. upper IsUpper
  16. word IsWord \w
  17. xdigit IsXDigit
\end{verbatim}

\parrafo{Negated character classes}

You can negate the \verb|[::]| character classes by prefixing 
the class name with a \verb|'^'|. This is a Perl extension. For example:

\begin{verbatim}
   1. POSIX traditional Unicode
   2.
   3. [[:^digit:]] \D \P{IsDigit}
   4. [[:^space:]] \S \P{IsSpace}
   5. [[:^word:]] \W \P{IsWord}
\end{verbatim}


\subsection{Variables especiales después de un emparejamiento}
\label{section:variablesmagicasereg}
Despues de un emparejamiento con éxito, las siguientes variables 
especiales quedan definidas:

\vspace{0.5cm}
\begin{tabular}{|l|l|}
\hline
\verb|$&| & El texto que casó\\
\hline
\verb|$`| & El texto que está a la izquierda de lo que casó\\
\hline
\verb|$'| & El texto que está a la derecha de lo que casó\\
\hline
\verb|$1, $2, $3|, etc. & Los textos capturados por los paréntesis\\
\hline
\verb|$+| & Una copia del \verb|$1, $2,| \ldots con número mas alto\\
\hline
\verb|@-| & Desplazamientos de las subcadenas que casan en \verb|$1| \ldots \\
\hline
\verb|@+| & Desplazamientos de los finales de las subcadenas  en \verb|$1| \ldots \\
\hline
\verb|$#-| & El índice del último paréntesis que casó\\
\hline
\verb|$#+| & El índice del último paréntesis en la última expresión regular\\
\hline
\end{tabular}

\parrafo{Las Variables de match, pre-match y post-mach}
\label{parrafo:prematch}

\vspace{0.5cm}
Ejemplo:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/matchvariables.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 if ("Hello there, neighbor" =~ /\s(\w+),/) {
   3   print "That was: ($`)($&)($').\n",
   4 }
\end{verbatim}

\begin{verbatim}
> matchvariables.pl
That was: (Hello)( there,)( neighbor).
\end{verbatim}

El uso de estas variables tenía un efecto negativo en el rendimiento de la
regexp. Véase
\perldoc{perlfaq6} la sección 
\verb|Why does using $&, $`, or $' slow my program down?|.
%\pd{perlfaq6}{Why-does-using-\$\&,-\$`,-or-\$'-slow-my-program-down?}
%\htmladdnormallink
%{perlfaq6}
%{http://search.cpan.org/~dapm/perl-5.10.1-RC2/pod/perlfaq6.pod}:

\begin{it}
\begin{quotation}
Once Perl sees that you need one of these variables anywhere in the
program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of
it to \verb|$`|, part to \verb|$&|, and part to \verb|$'|. 
Thus the penalty is most severe
with long strings and patterns that match often. Avoid \verb|$&|, \verb|$'|, and \verb|$`|
if you can, but if you can't, once you've used them at all, use them at
will because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the \verb|$&| variable is no
longer "expensive" the way the other two are.

Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.

Perl 5.10 added three specials, \verb|${^MATCH}|, \verb|${^PREMATCH}|, and \verb|${^POSTMATCH}|
to do the same job but without the global performance penalty. Perl
5.10 only sets these variables if you compile or execute the regular
expression with the \verb|/p| modifier.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat ampersandoldway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/;
my ($a, $b, $c) = ($`, $&, $');


cmpthese( -1, {
    oldway => sub { 'hola juan' =~ /ju/  },
});
pl@nereida:~/Lperltesting$ cat ampersandnewway.pl
#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
use strict;
use Benchmark qw(cmpthese timethese);

'hola juan' =~ /ju/p;
my ($a, $b, $c) = (${^PREMATCH}, ${^MATCH}, ${^POSTMATCH});


cmpthese( -1, {
    newway => sub { 'hola juan' =~ /ju/  },
});

pl@nereida:~/Lperltesting$ time ./ampersandoldway.pl
            Rate oldway
oldway 2991861/s     --

real    0m3.761s
user    0m3.740s
sys     0m0.020s
pl@nereida:~/Lperltesting$ time ./ampersandnewway.pl
            Rate newway
newway 8191999/s     --

real    0m6.721s
user    0m6.704s
sys     0m0.016s
\end{verbatim}

Véase 
\begin{itemize}
\item
\perldoc{perlvar} (busque por \verb|$MATCH|)
\end{itemize}


\parrafo{Texto Asociado con el Último Paréntesis}

La variable \verb|$+| contiene el texto que casó
con el último paréntesis en el patrón. Esto es útil
en situaciones en las cuáles una de un conjunto de alternativas 
casa, pero no sabemos cuál:

\begin{verbatim}
  DB<9> "Revision: 4.5" =~ /Version: (.*)|Revision: (.*)/ && ($rev = $+);
  DB<10> x $rev
0  4.5
  DB<11> "Version: 4.5" =~ /Version: (.*)|Revision: (.*)/ && ($rev = $+);
  DB<12> x $rev
0  4.5
\end{verbatim}

\parrafo{Los Offsets de los Inicios de los Casamientos: {\tt @-}}
\label{parrafo:iniciocas}

El vector \verb|@-| contiene los \emph{offsets} o desplazamientos
de los casamientos en la última expresión regular.
La entrada \verb|$-[0]| es el desplazamiento del último casamiento con éxito
y \verb|$-[n]| es el desplazamiento de la subcadena que casa
con el \verb|n|-ésimo paréntesis (o \verb|undef| si el párentesis
no casó). Por ejemplo:

\begin{verbatim}
#           012345678
DB<1> $z = "hola13.47"
DB<2> if ($z =~ m{a(\d+)(\.(\d+))?}) { print "@-\n"; }
3 4 6 7
\end{verbatim}
El resultado se interpreta como sigue:
\begin{itemize}
\item 3 = desplazamiento de comienzo de \verb|$& = a13.47| 
\item 4 = desplazamiento de comienzo de \verb|$1 = 13|
\item 6 = desplazamiento de comienzo de \verb|$2 = .|
\item 7 = desplazamiento de comienzo de \verb|$3 = 47|
\end{itemize}

Esto es lo que dice \perldoc{perlvar} sobre \verb|@-|:

\begin{it}\begin{quotation}
This array holds the offsets of the beginnings of the last successful
submatches in the currently active dynamic scope. \verb|$-[0]| is the offset
into the string of the beginning of the entire match. The nth element of
this array holds the offset of the nth submatch, so \verb|$-[1]| is the offset
where \verb|$1| begins, \verb|$-[2]| the offset where \verb|$2| begins, and so on.

    After a match against some variable \verb|$var|:

\begin{verbatim}
    $` is the same as substr($var, 0, $-[0])
    $& is the same as substr($var, $-[0], $+[0] - $-[0])
    $' is the same as substr($var, $+[0])
    $1 is the same as substr($var, $-[1], $+[1] - $-[1])
    $2 is the same as substr($var, $-[2], $+[2] - $-[2])
    $3 is the same as substr($var, $-[3], $+[3] - $-[3])
\end{verbatim}


\end{quotation}\end{it}

\parrafo{Desplazamientos de los Finales de los Emparejamientos: {\tt @+}}
\label{parrafo:fincas}

El array \verb|@+| contiene los desplazamientos de 
los finales de los emparejamientos.
La entrada \verb|$+[0]| contiene el desplazamiento del final de la cadena
del emparejamiento completo.
Siguiendo con el ejemplo anterior:
\begin{verbatim}
#            0123456789
DB<17> $z = "hola13.47x"
DB<18> if ($z =~ m{a(\d+)(\.)(\d+)?}) { print "@+\n"; }
9 6 7 9
\end{verbatim}
El resultado se interpreta como sigue:
\begin{itemize}
\item 9 = desplazamiento final de \verb|$& = a13.47x| 
\item 6 = desplazamiento final de \verb|$1 = 13|
\item 7 = desplazamiento final de \verb|$2 = .|
\item 9 = desplazamiento final de \verb|$3 = 47|
\end{itemize}

\parrafo{Número de paréntesis en la última regexp con éxito}

Se puede usar \verb|$#+| para determinar cuantos parentesis
había en el último emparejamiento que tuvo éxito.
\begin{verbatim}
  DB<29> $z = "h"
  DB<30> print "$#+\n" if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
3
  DB<31> $z = "ab"
  DB<32> print "$#+\n" if ($z =~ m{(a)(b)}) || ($z =~ m{(h)(.)?(.)?})
2
\end{verbatim}

\parrafo{Indice del Ultimo Paréntesis}
\label{parrafo:lastpar}

La variable \verb|$#-| contiene el índice del último paréntesis
que casó. Observe la siguiente ejecución con el depurador:
\begin{verbatim}
  DB<1> $x = '13.47'; $y = '125'
  DB<2> if ($y =~ m{(\d+)(\.(\d+))?}) { print "last par = $#-, content = $+\n"; }
last par = 1, content = 125
  DB<3> if ($x =~ m{(\d+)(\.(\d+))?}) { print "last par = $#-, content = $+\n"; }
last par = 3, content = 47
\end{verbatim}

\parrafo{{\tt @-} y {\tt @+} no tienen que tener el mismo tamaño}

En general no puede asumirse que \verb|@-| y \verb|@+| sean 
del mismo tamaño.
\begin{verbatim}
  DB<1> "a" =~ /(a)|(b)/; @a = @-; @b = @+
  DB<2> x @a
0  0
1  0
  DB<3> x @b
0  1
1  1
2  undef
\end{verbatim}

%\begin{exercise}
%Estudie el siguiente programa:
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ cat -n orton_mod1.pl
% 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
% 2  use v5.10;
% 3  use re 'debug';
% 4
% 5  my $input;
% 6
% 7  local $" = ", ";
% 8
% 9  $parser = qr/(?<foo>foo)((?&foo))/;
%10  $input = <>;
%11  chomp($input);
%12  if ($input =~ $parser) {
%13    say "matches: & = ($&) 1 = ($1) 2 = ($2)";
%14    say "At the very end:\n\@- = (@-)\t ".scalar(@-)
%15        ." items\t\$#- = $#-\n\@+ = (@+)\t ".scalar(@+)
%16        ." items\t\$#+ = $#+ \n";
%17  }
%18  __END__
%\end{verbatim}
%Explique el resultado de la ejecución del programa cuando 
%recibe la entrada \verb|foofoo|?
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ ./orton_mod1.pl
%Compiling REx "(?<foo>foo)((?&foo))"
%Final program:
%   1: OPEN1 'foo' (3)
%   3:   EXACT <foo> (5)
%   5: CLOSE1 'foo' (7)
%   7: OPEN2 (9)
%   9:   GOSUB1[-8] (12)
%  12: CLOSE2 (14)
%  14: END (0)
%anchored "foofoo" at 0 (checking anchored) minlen 6
%foofoo
%Guessing start of match in sv for REx "(?<foo>foo)((?&foo))" against "foofoo"
%Found anchored substr "foofoo" at offset 0...
%Guessed: match at offset 0
%Matching REx "(?<foo>foo)((?&foo))" against "foofoo"
%   0 <> <foofoo>             |  1:OPEN1 'foo'(3)
%   0 <> <foofoo>             |  3:EXACT <foo>(5)
%   3 <foo> <foo>             |  5:CLOSE1 'foo'(7)
%   3 <foo> <foo>             |  7:OPEN2(9)
%   3 <foo> <foo>             |  9:GOSUB1[-8](12)
%   3 <foo> <foo>             |  1:  OPEN1 'foo'(3)
%   3 <foo> <foo>             |  3:  EXACT <foo>(5)
%   6 <foofoo> <>             |  5:  CLOSE1 'foo'(7)
%                                    EVAL trying tail ... 0
%   6 <foofoo> <>             | 12:    CLOSE2(14)
%   6 <foofoo> <>             | 14:    END(0)
%Match successful!
%matches: & = (foofoo) 1 = (foo) 2 = (foo)
%At the very end:
%@- = (0, 0, 3)   3 items        $#- = 2
%@+ = (6, 3, 6)   3 items        $#+ = 2
%
%Freeing REx: "(?<foo>foo)((?&foo))"
%\end{verbatim}
%\end{exercise}

\parrafo{Véase También}

Para saber más sobre las variables especiales disponibles
consulte 

\begin{itemize}
\item \verb|perldoc| \perldoc{perlretut}
\item \verb|perldoc| \perldoc{perlvar}.
\end{itemize}

\subsection{Ambito Automático}

Como sabemos, ciertas variables (como \verb|$1|, \verb|$&| \ldots )
reciben autom\'aticamente un valor con cada operaci\'{o}n
de ``matching''.  

Considere el siguiente c\'{o}digo:
\begin{verbatim}
if (m/(...)/) {
  &do_something();
  print "the matched variable was $1.\n";
}
\end{verbatim}
Puesto que \verb|$1| es autom\'aticamente declarada \verb|local|
a la entrada de cada bloque, no importa lo que se haya
hecho en la funci\'{o}n \verb| &do_something()|, el valor de 
\verb|$1| en la sentencia \verb|print| es el correspondiente
al ``matching'' realizado en el \verb|if|.

\subsection{Opciones}
\label{section:opciones}
\begin{tabular}{l|l}
Modificador & Significado\\
\hline
e           & evaluar: evaluar el lado derecho de una sustitución como una expresión\\
g           & global: Encontrar todas las ocurrencias\\
i           & ignorar: no distinguir entre mayúsculas y minúsculas\\
m           & multilínea (\verb|^| y \verb|$| casan con \verb|\n| internos)\\
o           & optimizar: compilar una sola vez\\
s           & \verb|^| y \verb|$| ignoran \verb|\n| pero el punto \verb|.| ``casa'' con \verb|\n|\\
x           & extendida: permitir comentarios\\
\end{tabular}

\parrafo{El Modificador {\tt /g}}
\label{section:g}
La conducta de este modificador depende del contexto. En un contexto de
listas devuelve una lista con todas las subcadenas casadas
por todos los paréntesis en la expresión regular. Si no hubieran 
paréntesis devuelve una lista con todas las cadenas casadas
(como si hubiera paréntesis alrededor del patrón global).

%%%%%%%%%%%%%%%listinginput: Input from: "../src/glist.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 ($one, $five, $fifteen) = (`uptime` =~ /(\d+\.\d+)/g);
   3 print "$one, $five, $fifteen\n";
\end{verbatim}

Observe la salida:
\begin{verbatim}
> uptime
  1:35pm  up 19:22,  0 users,  load average: 0.01, 0.03, 0.00
> glist.pl
0.01, 0.03, 0.00 
\end{verbatim}

En un contexto escalar \verb|m//g| itera sobre la cadena, devolviendo
cierto cada vez que casa, y falso cuando deja de casar. En otras 
palabras, recuerda donde se quedo la última vez y se recomienza la búsqueda
desde ese punto. Se puede averiguar la posicion del emparejamiento
utilizando la función \cei{{\tt pos}}. 
Si por alguna razón modificas la cadena en cuestión, 
la posición de emparejamiento se reestablece al comienzo de la cadena.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/gscalar.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 # count sentences in a document
   3 #defined as ending in [.!?] perhaps with
   4 # quotes or parens on either side.
   5 $/ = ""; # paragraph mode
   6 while ($paragraph = <>) {
   7   print $paragraph;
   8   while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
   9     $sentences++;
  10   }
  11 }
  12 print "$sentences\n";
\end{verbatim}

Observe el uso de la variable especial \verb|$/|. 
Esta variable contiene el separador de registros en el fichero de 
entrada. Si se iguala a la cadena vacía usará las líneas 
en blanco como separadores. Se le puede dar el valor de una cadena multicarácter
para usarla como delimitador. Nótese que establecerla a \verb|\n\n|
es diferente de asignarla a \verb|""|. Si se deja \verb|undef|, 
la siguiente lectura leerá todo el fichero.

Sigue un ejemplo de ejecución. El programa se llama \verb|gscalar.pl|.
Introducimos el texto desde \verb|STDIN|. El programa escribe el
número de párrafos:

\begin{verbatim}
> gscalar.pl
este primer parrafo. Sera seguido de un
segundo parrafo.
 
"Cita de Seneca".
 
3 
\end{verbatim}

\parrafo{La opción {\tt e}: Evaluación del remplazo}
\label{section:regeval}
La opción \verb|/e| permite la evaluación como expresión perl de la
cadena de reemplazo (En vez de considerarla como una cadena delimitada 
por doble comilla).

%%%%%%%%%%%%%%%listinginput: Input from: "../src/replacement.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $_ = "abc123xyz\n";
   3 s/\d+/$&*2/e;
   4 print;
   5 s/\d+/sprintf("%5d",$&)/e;
   6 print;
   7 s/\w/$& x 2/eg;
   8 print;
\end{verbatim}
El resultado de la ejecución es:
\begin{verbatim}
> replacement.pl
abc246xyz
abc  246xyz
aabbcc  224466xxyyzz 
\end{verbatim}

Véase un ejemplo con anidamiento de {\tt /e}:
%%%%%%%%%%%%%%%listinginput: Input from: "../src/enested.pl"
\begin{verbatim}
   1 #!/usr/bin/perl 
   2 $a ="one";
   3 $b = "two";
   4 $_ = '$a $b';
   5 print "_ = $_\n\n";
   6 s/(\$\w+)/$1/ge;
   7 print "After 's/(\$\w+)/$1/ge' _ = $_\n\n";
   8 s/(\$\w+)/$1/gee;
   9 print "After 's/(\$\w+)/$1/gee' _ = $_\n\n";
\end{verbatim}
El resultado de la ejecución es:
\begin{verbatim} 
> enested.pl
_ = $a $b
 
After 's/($w+)/$b/ge' _ = $a $b
 
After 's/($w+)/$b/gee' _ = one two  
\end{verbatim}

He aqui una solución que hace uso de \verb|e| al siguiente ejercicio 
(véase 'Regex to add space after punctuation sign' en \perlmonk{319742})
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

\begin{verbatim}
s/(\d[,.]\d)|(,(?!\s))/$1 || "$2 "/ge; 
\end{verbatim}

Se hace uso de un lookahead negativo \verb|(?!\s)|.
Véase la sección \ref{subsection:lookaheadlookbehind} para entender como funciona
un lookahead negativo.

\section{Algunas Extensiones}

\subsection{Comentarios}
\verb|(?#text)| Un comentario. Se ignora \verb|text|. 
Si se usa la opción \verb|x| basta con poner \verb|#|.

\subsection{Modificadores locales}

Los modificadores de la conducta de una expresión regular pueden ser 
empotrados en una subexpresión usando el formato \verb|(?pimsx-imsx)|.

Véase el correspondiente texto {\it Extended Patterns} de 
\pd{perlre}{Extended-Patterns}:
\begin{it}
\begin{quotation}
One or more embedded pattern-match modifiers, to be turned on (or turned
off, if preceded by '\verb|-|' ) for the remainder of the pattern or the remainder
of the enclosing pattern group (if any). This is particularly useful
for dynamic patterns, such as those read in from a configuration file,
taken from an argument, or specified in a table somewhere. Consider
the case where some patterns want to be case sensitive and some do not:
The case insensitive ones merely need to include (?i) at the front of
the pattern. For example:

\begin{verbatim}
   1. $pattern = "foobar";
   2. if ( /$pattern/i ) { }
   3.
   4. # more flexible:
   5.
   6. $pattern = "(?i)foobar";
   7. if ( /$pattern/ ) { }
\end{verbatim}

These modifiers are restored at the end of the enclosing group. For example,

\begin{verbatim}
   1. ( (?i) blah ) \s+ \1
\end{verbatim}

will match \verb|blah| in any case, some spaces, and an exact (including the
case!) repetition of the previous word, assuming the \verb|/x| modifier, and
no \verb|/i| modifier outside this group.
\end{quotation}
\end{it}

El siguiente ejemplo extiende el ejemplo visto en
la sección
\ref{parrfo:comments}
eliminando los comentarios \verb|/* ... */| y \verb|// ... |
de un programa C. En dicho ejemplo se usaba el modificador \verb|s| 
para hacer que el punto casara con cualquier carácter:

\begin{latexonly}
\begin{verbatim}
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my $progname = shift @ARGV or die "Usage:\n$0 prog.c\n";
   5    open(my $PROGRAM,"<$progname") || die "can't find $progname\n";
   6    my $program = '';
   7    {
   8      local $/ = undef;
   9      $program = <$PROGRAM>;
  10    }
  11    $program =~ s{(?xs)
  12      /\*  # Match the opening delimiter
  13      .*?  # Match a minimal number of characters
  14      \*/  # Match the closing delimiter
  15      |
  16        (?-s)//.* # C++ // comments. No s modifier
  17    }[]g;
  18  
  19    print $program;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano@tonga:~/Lperltesting$ cat -n extendedcomments.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$progname</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@ARGV</span> <span class="synStatement">or</span> <span class="synStatement">die</span> <span class="synConstant">&quot;Usage:</span><span class="synSpecial">\n</span><span class="synIdentifier">$0</span><span class="synConstant"> prog.c</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">open</span>(<span class="synStatement">my</span> <span class="synIdentifier">$PROGRAM</span>,<span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$progname</span><span class="synConstant">&quot;</span>) || <span class="synStatement">die</span> <span class="synConstant">&quot;can't find </span><span class="synIdentifier">$progname</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">    6</span>   <span class="synStatement">my</span> <span class="synIdentifier">$program</span> = <span class="synConstant">''</span>;
<span class="synLinenum">    7</span>   {
<span class="synLinenum">    8</span>     <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">    9</span>     <span class="synIdentifier">$program</span> = &lt;<span class="synIdentifier">$PROGRAM</span>&gt;;
<span class="synLinenum">   10</span>   }
<span class="synLinenum">   11</span>   <span class="synIdentifier">$program</span> =~ <span class="synStatement">s{</span><span class="synSpecial">(?xs)</span>
<span class="synLinenum">   12</span> <span class="synConstant">    /</span><span class="synSpecial">\*</span><span class="synConstant">  # Match the opening delimiter</span>
<span class="synLinenum">   13</span> <span class="synConstant">    </span><span class="synSpecial">.*?</span><span class="synConstant">  # Match a minimal number of characters</span>
<span class="synLinenum">   14</span> <span class="synConstant">    </span><span class="synSpecial">\*</span><span class="synConstant">/  # Match the closing delimiter</span>
<span class="synLinenum">   15</span> <span class="synConstant">    |</span>
<span class="synLinenum">   16</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">-s</span><span class="synSpecial">)</span><span class="synConstant">//</span><span class="synSpecial">.*</span><span class="synConstant"> # C</span><span class="synSpecial">++</span><span class="synConstant"> // comments</span><span class="synSpecial">.</span><span class="synConstant"> No s modifier</span>
<span class="synLinenum">   17</span> <span class="synConstant">  </span><span class="synStatement">}</span>[]g;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>   <span class="synStatement">print</span> <span class="synIdentifier">$program</span>;
</pre>

\end{rawhtml}
%}}}
Sigue un ejemplo de ejecución. Usaremos como entrada el programa C:
\begin{verbatim}
casiano@tonga:~/Lperltesting$ cat -n ehello.c
     1  #include <stdio.h>
     2  /* first
     3  comment
     4  */
     5  main() { // A C++ comment
     6    printf("hello world!\n"); /* second comment */
     7  } // final comment
\end{verbatim}
Al ejecutar el programa eliminamos los comentarios:
\begin{verbatim}
casiano@tonga:~/Lperltesting$ extendedcomments.pl ehello.c | cat -n
     1  #include <stdio.h>
     2
     3  main() {
     4    printf("hello world!\n");
     5  }

\end{verbatim}


\subsection{Mirando hacia adetrás y hacia adelante}
\label{subsection:lookaheadlookbehind}

El siguiente fragmento esta 'casi' literalmente tomado
de \pd{perlretut}{Looking-ahead-and-looking-behind}:

\begin{it}

\parrafo{Las zero-width assertions como caso particular de mirar atrás-adelante}

In Perl regular expressions, most regexp elements 'eat up' a certain
amount of string when they match. For instance, the regexp element
\verb|[abc}]| eats up one character of the string when it matches, in the sense
that Perl moves to the next character position in the string after the
match. There are some elements, however, that don't eat up characters
(advance the character position) if they match. 

The examples we have seen
so far are the anchors. The anchor \verb|^| matches the beginning of the line,
but doesn't eat any characters. 

Similarly, the word boundary anchor
\verb|\b| matches wherever a character matching \verb|\w| is next to a character that
doesn't, but it doesn't eat up any characters itself. 

Anchors are examples
of \cei{zero-width assertions}. Zero-width, because they consume no characters,
and assertions, because they test some property of the string. 

In the
context of our walk in the woods analogy to regexp matching, most regexp
elements move us along a trail, but anchors have us stop a moment and
check our surroundings. If the local environment checks out, we can
proceed forward. But if the local environment doesn't satisfy us, we
must backtrack.

Checking the environment entails either looking ahead on the trail,
looking behind, or both. 

\begin{itemize}
\item
\verb|^| looks behind, to see that there are no
characters before. 
\item
\verb|$| looks ahead, to see that there are no characters
after. 
\item
\verb|\b| looks both ahead and behind, to see if the characters on either
side differ in their "word-ness".
\end{itemize}

The lookahead and lookbehind assertions are generalizations of the anchor
concept. 
Lookahead and lookbehind are zero-width assertions that let us
specify which characters we want to test for. 

\parrafo{Lookahead assertion}

The lookahead assertion
is denoted by \verb|(?=regexp)| and the lookbehind assertion is denoted by
\verb|(?<=fixed-regexp)|. 

En español, operador de ``trailing'' o ``mirar-adelante'' positivo. 
Por ejemplo, \verb|/\w+(?=\t)/| solo casa una palabra si va seguida de un tabulador, pero el tabulador no formará parte de \verb|$&|.
Ejemplo:
\begin{latexonly}
\begin{verbatim}
> cat -n lookahead.pl
   1  #!/usr/bin/perl
   2  
   3   $a = "bugs the rabbit";
   4   $b = "bugs the frog";
   5   if ($a =~ m{bugs(?= the cat| the rabbit)}i) { print "$a matches. \$& = $&\n"; }
   6   else { print "$a does not match\n"; }
   7   if ($b =~ m{bugs(?= the cat| the rabbit)}i) { print "$b matches. \$& = $&\n"; }
   8   else { print "$b does not match\n"; }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
> cat -n lookahead.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span> 
<span class="synLinenum">    3</span>  <span class="synIdentifier">$a</span> = <span class="synConstant">&quot;bugs the rabbit&quot;</span>;
<span class="synLinenum">    4</span>  <span class="synIdentifier">$b</span> = <span class="synConstant">&quot;bugs the frog&quot;</span>;
<span class="synLinenum">    5</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$a</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$a</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    6</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$a</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    7</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$b</span> =~ <span class="synStatement">m{</span><span class="synConstant">bugs</span><span class="synSpecial">(?=</span><span class="synConstant"> the cat| the rabbit</span><span class="synSpecial">)</span><span class="synStatement">}i</span>) { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synConstant"> matches. </span><span class="synSpecial">\$</span><span class="synConstant">&amp; = </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
<span class="synLinenum">    8</span>  <span class="synStatement">else</span> { <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">$b</span><span class="synConstant"> does not match</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>; }
</pre>

\end{rawhtml}
%}}}
Al ejecutar el programa obtenemos:
\begin{verbatim}
> lookahead.pl
bugs the rabbit matches. $& = bugs
bugs the frog does not match
>
\end{verbatim}

Some examples using the debugger\footnote{catnip: 
La nepeta cataria, también llamada menta de los gatos, de la familia del tomillo y la lavanda. 
Su perfume desencadena un comportamiento en el animal, similar al del celo}:

\begin{latexonly}
\begin{verbatim}
  DB<1>      #012345678901234567890
  DB<2> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<3> print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5> $x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos
  DB<6> x @catwords = ($x =~ /(?<=\s)cat\w+/g)
0  'catch'
1  'catnip'

  DB<7>      #012345678901234567890123456789
  DB<8> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<9> print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10> $x = "I catch the housecat 'Tom-cat' with catnip"
  DB<11> x  $x =~ /(?<=\s)cat(?=\s)/
  empty array
  DB<12> # doesn't match; no isolated 'cat' in middle of $x
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
  DB<1>  <span class="dbuser">     #012345678901234567890</span>
  DB<2>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<3>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x  =~ /cat(?=\s)/g</span>
(cat) (20)                    # matches 'cat' in 'housecat'

  DB<5>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip" # To reset pos</span>
  DB<6>  <span class="dbuser">x @catwords = ($x =~ /(?<=\s)cat\w+/g)</span>
0  'catch'
1  'catnip'

  DB<7>  <span class="dbuser">     #012345678901234567890123456789</span>
  DB<8>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<9>  <span class="dbuser">print "($&) (".pos($x).")\n" if $x =~ /\bcat\b/g</span>
(cat) (29) # matches 'cat' in 'Tom-cat'

  DB<10>  <span class="dbuser">$x = "I catch the housecat 'Tom-cat' with catnip"</span>
  DB<11>  <span class="dbuser">x  $x =~ /(?<=\s)cat(?=\s)/</span>
  empty array
  DB<12>  <span class="dbuser"># doesn't match; no isolated 'cat' in middle of $x</span>
</pre>
\end{rawhtml}
%}}}

\parrafo{A hard RegEx problem}

Véase el nodo {\it A hard RegEx problem} en \perlmonk{645882}. 
Un monje solicita:

\begin{it}
\begin{quotation}
Hi Monks,

I wanna to match this issues:

\begin{enumerate}
   \item The string length is between 3 and 10
   \item The string ONLY contains [0-9] or [a-z] or [A-Z], but
   \item The string must contain a number AND a letter at least 
\end{enumerate}

Pls help me check. Thanks
\end{quotation}
\end{it}

Solución:

\begin{verbatim}
casiano@millo:~$ perl -wde 0
main::(-e:1):   0
  DB<1> x 'aaa2a1' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
  DB<2> x 'aaaaaa' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<3> x '1111111' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<4> x '1111111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
  empty array
  DB<5> x '111bbbbb' =~  /\A(?=.*[a-z])(?=.*\d)\w{3,10}\z/i
0  1
\end{verbatim}

\parrafo{Los paréntesis looakehaed and lookbehind no capturan}

Note that the parentheses in \verb|(?=regexp)| and \verb|(?<=regexp)|
are non-capturing, since these are zero-width assertions. 

\parrafo{Limitaciones del lookbehind}

Lookahead
\verb|(?=regexp)| can match arbitrary regexps, but lookbehind 
\verb|(?<=fixed-regexp)|
only works for regexps of fixed width, i.e., a fixed number of characters
long. 

Thus \verb#(?<=(ab|bc))# is fine, but \verb#(?<=(ab)*)# is not. 

\parrafo{Negación de los operadores de lookahead y lookbehind}

The negated
versions of the lookahead and lookbehind assertions are denoted by
\verb|(?!regexp)| and \verb#(?<!fixed-regexp)# respectively. 
They evaluate true if
the regexps do not match:
\begin{verbatim}
    $x = "foobar";
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?<!\s)foo/;  # matches, there is no \s before 'foo'
\end{verbatim}

\parrafo{Ejemplo: split con lookahead y lookbehind}

Here is an example where a string containing blank-separated words,
numbers and single dashes is to be split into its components. 

Using \verb#/\s+/#
alone won't work, because spaces are not required between dashes, or a
word or a dash. Additional places for a split are established by looking
ahead and behind:
\begin{verbatim}
casiano@tonga:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $str = "one two - --6-8"
  DB<2> x @toks = split / \s+ | (?<=\S) (?=-) | (?<=-)  (?=\S)/x, $str
0  'one'
1  'two'
2  '-'
3  '-'
4  '-'
5  6
6  '-'
7  8
\end{verbatim}
\end{it}

\parrafo{Look Around en perlre}

El siguiente párrafo ha sido extraído \pd{pelre}{Look-Around-Assertions}.
Usémoslo como texto de repaso:
\begin{it}
\begin{quotation}
Look-around assertions are zero width patterns which match a specific
pattern without including it in \verb|$&|. Positive assertions match when their
subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.

\begin{itemize}
\item \verb|(?=pattern)|

A zero-width positive look-ahead assertion. For example, \verb|/\w+(?=\t)/| 
matches a word followed by a tab, without including the tab in \verb|$&|.

\item \verb|(?!pattern)|

A zero-width negative look-ahead assertion. For example \verb|/foo(?!bar)/| 
matches any occurrence of \verb"foo" that isn't followed by \verb"bar". 

Note however that look-ahead and look-behind are NOT the same thing. 
You cannot use this for look-behind.

If you are looking for a \verb"bar" that isn't preceded by a \verb"foo",
\verb|/(?!foo)bar/| will not do what you want. 

That's because the 
\verb#(?!foo)# is just saying that the next thing cannot be \verb"foo"
--and it's not, it's a \verb"bar", so \verb"foobar" will match. 

You would have to do something like \verb#/(?!foo)...bar/# for that. 

We say "like" because there's the case of your \verb"bar" not having
three characters before it. 

You could cover that this way:
\verb#/(?:(?!foo)...|^.{0,2})bar/#. Sometimes it's still easier just to say:

\begin{verbatim}
    if (/bar/ && $` !~ /foo$/)
\end{verbatim}

For look-behind see below.

\item \verb|(?<=pattern)|

A zero-width positive look-behind assertion. 

For example, \verb#/(?<=\t)\w+/#
matches a word that follows a tab, without including the tab in \verb|$&|. 
Works only for fixed-width look-behind.

\item \verb|\K| 

There is a special form of this construct, called \verb|\K| , which causes
the regex engine to 'keep' everything it had matched prior to the \verb|\K|
and not include it in \verb|$&|. This effectively provides variable length
look-behind. The use of \verb|\K| inside of another look-around assertion is
allowed, but the behaviour is currently not well defined.

For various reasons \verb|\K| may be significantly more efficient than the
equivalent \verb|(?<=...)| construct, and it is especially useful in situations
where you want to efficiently remove something following something else
in a string. For instance
\begin{verbatim}
  s/(foo)bar/$1/g;
\end{verbatim}

can be rewritten as the much more efficient
\begin{verbatim}
  s/foo\Kbar//g;
\end{verbatim}

Sigue una sesión con el depurador que ilustra la semántica
del operador:

\begin{verbatim}
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]/
& = <phab> 1 = <pha>
  DB<2> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /\K([^aeiou][a-z][aeiou])[a-z]/
& = <phab> 1 = <pha>
  DB<3> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou]\K[a-z][aeiou])[a-z]/
& = <hab> 1 = <pha>
  DB<4> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z]\K[aeiou])[a-z]/
& = <ab> 1 = <pha>
  DB<5> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])\K[a-z]/
& = <b> 1 = <pha>
  DB<6> print "& = <$&> 1 = <$1>\n" if "alphabet" =~ /([^aeiou][a-z][aeiou])[a-z]\K/
& = <> 1 = <pha>
  DB<7> @a = "alphabet" =~ /([aeiou]\K[^aeiou])/g; print "$&\n"
t
  DB<8> x @a
0  'al'
1  'ab'
2  'et'
\end{verbatim}

Otro ejemplo: eliminamos los blancos del final en una cadena:
\begin{verbatim}
  DB<23> $x = '  cadena entre blancos  '
  DB<24> ($y = $x) =~ s/.*\b\K.*//g
  DB<25> p "<$y>"
<  cadena entre blancos>
\end{verbatim}

\item \verb|(?<!pattern)| 

A zero-width negative look-behind assertion. 

For example \verb|/(?<!bar)foo/| matches any occurrence of 
 \verb"foo" that does not follow \verb"bar". Works only for fixed-width look-behind.
\end{itemize}

\end{quotation}
\end{it}


Veamos un ejemplo de uso. Se quiere
sustituir las extensiones \verb|.something| por \verb|.txt|
en cadenas que contienen una ruta a un fichero:

\begin{verbatim}
casiano@millo:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> ($b = $a = 'abc/xyz.something') =~ s{\.[^.]*$}{.txt}
  DB<2> p $b
abc/xyz.txt
  DB<3> ($b = $a = 'abc/xyz.something') =~ s/\.\K[^.]*$/txt/;
  DB<4> p $b
abc/xyz.txt
  DB<5> p $a
abc/xyz.something
\end{verbatim}

Véase también:
\begin{itemize}
\item \cpan{Regexp::Keep} por Jeff Pinyan 
\item El nodo {\it positive look behind regexp mystery} en \perlmonk{701618}
\end{itemize}

\parrafo{Operador de predicción negativo: Última ocurrencia}

Escriba una expresión regular que encuentre la última aparición de la cadena \verb|foo|
en una cadena dada.
\begin{verbatim}
  DB<6> x ($a = 'foo foo bar bar foo bar bar') =~ /foo(?!.*foo)/g; print pos($a)."\n"
19
  DB<7> x ($a = 'foo foo bar bar foo bar bar') =~ s/foo(?!.*foo)/\U$&/
0  1
  DB<8> x $a
0  'foo foo bar bar FOO bar bar'
\end{verbatim}


\parrafo{Diferencias entre mirar adelante negativo y mirar adelante con clase negada}

Aparentemente el operador ``mirar-adelante'' negativo es parecido a usar el operador ``mirar-adelante'' positivo
con la negación de una clase. 

\begin{center}
\begin{tabular}{p{4cm}|p{4cm}}
\hline
\begin{verbatim}
/regexp(?![abc])/
\end{verbatim}
&
\begin{verbatim}
/regexp(?=[^abc])/
\end{verbatim}\\
\hline
\end{tabular}
\end{center}

Sin embargo existen al menos dos diferencias:

\begin{itemize}
\item
Una negación de una clase debe casar algo para tener éxito. Un `mirar-adelante'' negativo
tiene éxito si, en particular no logra casar con algo. 
Por ejemplo:

\verb|\d+(?!\.)| casa con \verb|$a = '452'|, mientras que \verb|\d+(?=[^.])| lo hace, pero porque 
\verb|452| es \verb|45| seguido de un carácter que no es el punto:
\begin{verbatim}
> cat lookaheadneg.pl
#!/usr/bin/perl

 $a = "452";
 if ($a =~ m{\d+(?=[^.])}i) { print "$a casa clase negada. \$& = $&\n"; }
 else { print "$a no casa\n"; }
 if ($a =~ m{\d+(?!\.)}i) { print "$a casa predicción negativa. \$& = $&\n"; }
 else { print "$b no casa\n"; }
nereida:~/perl/src> lookaheadneg.pl
452 casa clase negada. $& = 45
452 casa predicción negativa. $& = 452
\end{verbatim}
\item
Una clase negada casa un único carácter. Un `mirar-adelante'' negativo
puede tener longitud arbitraria.
\end{itemize}

\parrafo{AND y AND NOT} 

Otros dos ejemplos: 

\begin{itemize}
\item
\verb|^(?![A-Z]*$)[a-zA-Z]*$| 

casa con líneas formadas por secuencias de
letras tales que no todas son mayúsculas.
(Obsérvese el uso de las anclas).

\item
\verb|^(?=.*?esto)(?=.*?eso)| 

casan con cualquier línea en la que aparezcan 
\verb|esto| y \verb|eso|. Ejemplo:
\begin{verbatim}
> cat estoyeso.pl
#!/usr/bin/perl

 my $a = shift;

 if ($a =~ m{^(?=.*?esto)(?=.*?eso)}i) { print "$a matches.\n"; }
 else { print "$a does not match\n"; }

>estoyeso.pl 'hola eso y esto'
hola eso y esto matches.
> estoyeso.pl 'hola esto y eso'
hola esto y eso matches.
> estoyeso.pl 'hola aquello y eso'
hola aquello y eso does not match
> estoyeso.pl 'hola esto y aquello'
hola esto y aquello does not match
\end{verbatim}
El ejemplo muestra que la interpretación es que cada 
operador mirar-adelante se interpreta siempre a partir de
la posición actual de búsqueda. La expresión regular anterior
es básicamente equivalente a \verb|(/esto/ && /eso/)|.
\item
\verb|(?!000)(\d\d\d)| 

casa con cualquier cadena de tres dígitos que no
sea la cadena \verb|000|.
\end{itemize}

\parrafo{Lookahead negativo versus lookbehind}

Nótese que el ``mirar-adelante'' negativo
no puede usarse fácilmente para imitar un ``mirar-atrás'',
esto es, que no se puede imitar la conducta de
\verb|(?<!foo)bar| mediante
algo como \verb|(/?!foo)bar|. Tenga en cuenta que:

\begin{itemize}

\item
Lo que 
dice \verb|(?!foo)| es que los tres caracteres que siguen no puede ser \verb"foo".  

\item
Así, \verb|foo| no pertenece a \verb|/(?!foo)bar/|, pero
\verb|foobar| pertenece a  \verb|(?!foo)bar/| porque \verb|bar| es una cadena
cuyos tres siguientes caracteres son \verb|bar| y no son \verb|foo|.

\item
Si quisieramos conseguir algo parecido a \verb|(?<!foo)bar| usando un lookahead negativo
tendríamos que escribir algo asi como
\verb|/(?!foo)...bar/| que casa con una cadena de tres caracteres que no sea \verb|foo| seguida de 
\verb|bar| (pero que tampoco es exactamente equivalente):
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n foobar.pl
     1  use v5.10;
     2  use strict;
     3
     4  my $a = shift;
     5
     6  for my $r (q{(?<!foo)bar}, q{(?!foo)bar}, q{(?!foo)...bar}) {
     7    if ($a =~ /$r/) {
     8      say "$a casa con $r"
     9    }
    10    else {
    11      say "$a no casa con $r"
    12    }
    13  }
\end{verbatim}

\item
Al ejecutar con diferentes entradas el programa anterior vemos que la solución 
\verb|q{(?!foo)...bar}| se apróxima mas a \verb|(q{(?<!foo)bar}|:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl foobar
foobar no casa con (?<!foo)bar
foobar casa con (?!foo)bar
foobar no casa con (?!foo)...bar

pl@nereida:~/Lperltesting$ perl5.10.1 foobar.pl bar
bar casa con (?<!foo)bar
bar casa con (?!foo)bar
bar no casa con (?!foo)...bar
\end{verbatim}

\begin{exercise}
Explique porqué \verb|bar| casa con \verb|(?<!foo)bar| pero no con \verb|(?!foo)...bar|.
¿Sabría encontrar una expresión regular mas apropiada usando lookahead negativo?
\end{exercise}

\item
En realidad, posiblemente sea mas legible una solución como:
\begin{verbatim}
        if (/bar/ and $` !~ /foo$/) 
\end{verbatim}
o aún mejor (véase \ref{parrafo:prematch}):
\begin{verbatim}
        if (/bar/p && ${^PREMATCH} =~ /foo$/)
\end{verbatim}
El siguiente programa puede ser utilizado para ilustrar la equivalencia:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n foobarprematch.pl
 1  use v5.10;
 2  use strict;
 3
 4  $_ = shift;
 5
 6  if (/bar/p && ${^PREMATCH} =~ /foo$/) {
 7    say "$_ no cumple ".q{/bar/p && ${^PREMATCH} =~ /foo$/};
 8  }
 9  else {
10    say "$_ cumple ".q{/bar/p && ${^PREMATCH} =~ /foo$/};
11  }
12  if (/(?<!foo)bar/) {
13    say "$_ casa con (?<!foo)bar"
14  }
15  else {
16    say "$_ no casa con (?<!foo)bar"
17  }
\end{verbatim}
Siguen dos ejecuciones:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl bar
bar cumple /bar/p && ${^PREMATCH} =~ /foo$/
bar casa con (?<!foo)bar
pl@nereida:~/Lperltesting$ perl5.10.1 foobarprematch.pl foobar
foobar no cumple /bar/p && ${^PREMATCH} =~ /foo$/
foobar no casa con (?<!foo)bar
\end{verbatim}
\end{itemize}

\parrafo{Ejercicios}

\begin{exercise}
\begin{itemize}
\item Escriba una sustitución que reemplaze todas las apariciones
de \verb|foo| por \verb|foo,| usando \verb|\K| o lookbehind
%0\begin{verbatim}
%0casiano@millo:~$ perl5.10.1 -wdE 0
%0main::(-e:1):   0
%0  DB<1> ($a = 'bar foo foobar bar barfoo bar baz') =~ s/foo\K/,/g
%0  DB<2> p $a
%0bar foo, foo,bar bar barfoo, bar baz
%0\end{verbatim}
\item Escriba una sustitución que reemplaze todas las apariciones
de \verb|lookahead| por \verb|look-ahead| usando lookaheads y lookbehinds
%\begin{verbatim}
%casiano@millo:~$ perl5.10.1 -wdE 0
%  DB<3> ($a = 'bar lookahead bar barlookahead bar baz') =~ s/look\K(?=ahead)/-/g
%  DB<4> p $a
%bar look-ahead bar barlook-ahead bar baz
%\end{verbatim}
\item
Escriba una expresión regular que capture todo lo que hay 
entre las cadenas \verb|foo| y \verb|bar| siempre que no se incluya la
palabra \verb|baz|
%\begin{verbatim}
%/foo  # Match starting at foo
% (         # Capture
% (?:       # Complex expression:
%   (?!baz) #   make sure we're not at the beginning of baz 
%   .       #   accept any character
% )*        # any number of times
% )         # End capture
% bar  # and ending at bar
%/x;
%\end{verbatim}
\item
¿Cuál es la salida?
\begin{verbatim}
  DB<1> x 'abc' =~ /(?=(.)(.)(.))a(b)/
\end{verbatim}
%\begin{verbatim}
%  DB<13> x 'abc' =~ /(?=(.)(.)(.))a(b)/
%0  'a'
%1  'b'
%2  'c'
%3  'b'
%\end{verbatim}
\item
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos.
%\begin{verbatim}
%  DB<1> $a = 'ab,cd,e,02,34,56,ef,273,457,c'
%  DB<4> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<5> p $b
%ab, cd, e, 02,34,56, ef, 273,457, c
%  DB<6> $a = 'ab,cd,e,02,34,56,ef,273,457,c,'
%  DB<7> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<9> p "<$b>"
%<ab, cd, e, 02,34,56, ef, 273,457, c, >
%  DB<10> $a = ',ab,cd,e,02,34,56,ef,273,457,c,'
%  DB<11> ($b = $a) =~ s{(?<!\d),|,(?!\d)}{, }g
%  DB<12> p "<$b>"
%<, ab, cd, e, 02,34,56, ef, 273,457, c, >
%  DB<13>
%\end{verbatim}
\item
Se quiere poner un espacio en blanco después de la aparición de cada coma:
\begin{verbatim}
s/,/, /g;
\end{verbatim}
pero se quiere que la sustitución no tenga lugar si la coma esta incrustada entre
dos dígitos. Además se pide que si hay ya un espacio después de la coma,
no se duplique

%\begin{verbatim}
%  DB<25> p $a
%,ab, cd, e,02,34,56,ef,273,457,c,
%  DB<24> ($b = $a) =~ s{(?<!\d),(?!\s)|,(?!\s)(?!\d)}{, }g
%  DB<26> p $b
%, ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

%\begin{verbatim}
%  DB<32> $a = ',ab, cd, e,02,34,56,ef,273,457,c,'
%  DB<33> ($b = $a) =~ s{(?!\d,\d)(.,)(?!\s)}{$1 }g
%  DB<34> p $b
%,ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

%Con 5.10
%\begin{verbatim}
%>> $a = ',ab, cd, e,02,34,56,ef,273,457,c,'
%>> #save deb
%  DB<6> ($b = $a) =~ s{(?!\d,\d)(.,\K)(?!\s)}{ }g
%  DB<7> p $b
%,ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}


%Abigail http://www.perlmonks.org/?node_id=319742
%\begin{verbatim}
%  DB<40> p $a
%,ab, cd, e,02,34,56,ef,273,457,c,
%  DB<41> ($b = $a) =~ s{(\d,\d)|(,(?!\s))}{$1 || "$2 "}ge
%  DB<42> p $b
%, ab, cd, e, 02,34,56, ef, 273,457, c,
%\end{verbatim}

\item
¿Cuál es la salida?
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ABC123.pl
  1  use warnings;
  2  use strict;
  3
  4  my $c = 0;
  5  my @p = ('^(ABC)(?!123)', '^(\D*)(?!123)',);
  6
  7  for my $r (@p) {
  8    for my $s (qw{ABC123 ABC445}) {
  9      $c++;
 10      print "$c: '$s' =~ /$r/ : ";
 11      <>;
 12      if ($s =~ /$r/) {
 13        print " YES ($1)\n";
 14      }
 15      else {
 16        print " NO\n";
 17      }
 18    }
 19  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n ABC123</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  use warnings;</span>
<span class="synConstant">     2  use strict;</span>
<span class="synConstant">     3</span>
<span class="synConstant">     4  my </span><span class="synIdentifier">$c</span><span class="synConstant"> = 0;</span>
<span class="synConstant">     5  my </span><span class="synIdentifier">@p</span><span class="synConstant"> = </span><span class="synSpecial">(</span><span class="synConstant">'^</span><span class="synSpecial">(</span><span class="synConstant">ABC</span><span class="synSpecial">)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">', '^</span><span class="synSpecial">(\D*)(?!</span><span class="synConstant">123</span><span class="synSpecial">)</span><span class="synConstant">',</span><span class="synSpecial">)</span><span class="synConstant">;</span>
<span class="synConstant">     6</span>
<span class="synConstant">     7  for my </span><span class="synIdentifier">$r</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synIdentifier">@p</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     8    for my </span><span class="synIdentifier">$s</span><span class="synConstant"> </span><span class="synSpecial">(</span><span class="synConstant">qw{ABC123 ABC445}</span><span class="synSpecial">)</span><span class="synConstant"> {</span>
<span class="synConstant">     9      </span><span class="synIdentifier">$c</span><span class="synSpecial">++</span><span class="synConstant">;</span>
<span class="synConstant">    10      print &quot;</span><span class="synIdentifier">$c</span><span class="synConstant">: '</span><span class="synIdentifier">$s</span><span class="synConstant">' =~ </span><span class="synStatement">/</span><span class="synIdentifier">$r</span>/ : <span class="synConstant">&quot;;</span>
<span class="synConstant">    11      &lt;&gt;;</span>
<span class="synConstant">    12      if (</span><span class="synIdentifier">$s</span><span class="synConstant"> =~ /</span><span class="synIdentifier">$r</span><span class="synConstant">/) {</span>
<span class="synConstant">    13        print &quot;</span> YES (<span class="synIdentifier">$1</span>)\n<span class="synConstant">&quot;;</span>
<span class="synConstant">    14      }</span>
<span class="synConstant">    15      else {</span>
<span class="synConstant">    16        print &quot;</span> NO\n<span class="synConstant">&quot;;</span>
<span class="synConstant">    17      }</span>
<span class="synConstant">    18    }</span>
<span class="synConstant">    19  }</span>
</pre>

\end{rawhtml}
%}}}
%\begin{verbatim}
%pl@nereida:~/Lperltesting$ perl ABC123.pl
%1: 'ABC123' =~ /^(ABC)(?!123)/ :
% NO
%2: 'ABC445' =~ /^(ABC)(?!123)/ :
% YES (ABC)
%3: 'ABC123' =~ /^(\D*)(?!123)/ :
% YES (AB)
%4: 'ABC445' =~ /^(\D*)(?!123)/ :
% YES (ABC)
%\end{verbatim}
\end{itemize}
\end{exercise}

\subsection{Definición de Nombres de Patrones}
Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 

\parrafo{Lo que dice {\tt perlretut} sobre la definición de nombres de patrones}

Citando la sección {\it Defining named patterns}
en el documento \pd{perlretut}{Defining-named-patterns} para
perl5.10:

\begin{it}
\begin{quotation}
Some regular expressions use identical subpatterns in several
places. Starting with Perl 5.10, it is possible to define named
subpatterns in a section of the pattern so that they can be called up by
name anywhere in the pattern. 
This syntactic pattern for this definition group is
\verb|"(?(DEFINE)(?<name>pattern)...)"|  
An
insertion of a named pattern is written as \verb"(?&name)".
\end{quotation}
\end{it}

Veamos un ejemplo que define el lenguaje de los números en punto flotante:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n definingnamedpatterns.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3
 4  my $regexp = qr{
 5     ^ (?<num>
 6               (?&osg)[\t\ ]* (?: (?&int)(?&dec)? | (?&dec) )
 7       )
 8       (?: [eE]
 9       (?<exp> (?&osg)(?&int)) )?
10     $
11        (?(DEFINE)
12         (?<osg>[-+]?)         # optional sign
13         (?<int>\d++)          # integer
14         (?<dec>\.(?&int))     # decimal fraction
15        )
16  }x;
17
18  my $input = <>;
19  chomp($input);
20  my @r;
21  if (@r = $input =~ $regexp) {
22    my $exp = $+{exp} || '';
23    say "$input matches: (num => '$+{num}', exp => '$exp')";
24  }
25  else {
26    say "does not match";
27  }
\end{verbatim}
\perldoc{perlretut} comenta sobre este ejemplo:
\begin{it}
\begin{quotation}
The example above illustrates this feature.
The three subpatterns that
are used more than once are the optional sign, 
the digit sequence for
an integer 
and the decimal fraction. The \verb|DEFINE| 
group at the end of
the pattern contains their definition. Notice that the decimal fraction
pattern is the first place where we can reuse the integer pattern.
\end{quotation}
\end{it}


\parrafo{Lo que dice {\tt perlre} sobre la definición de patrones}

Curiosamente, \verb|(DEFINE)| se considera un caso particular de 
las expresiones regulares condicionales de la forma \verb|(?(condition)yes-pattern)|
(véase la sección \ref{subsection:regexpcondicionales}).
Esto es lo que dice \pd{perlre}{Extended-Patterns} al respecto:
\begin{it}
\begin{quotation}
A special form is the \verb|(DEFINE)|  predicate, which never executes
directly its yes-pattern, and does not allow a no-pattern. This allows
to define subpatterns which will be executed only by using the recursion
mechanism. This way, you can define a set of regular expression rules
that can be bundled into any pattern you choose.

It is recommended that for this usage you put the \verb|DEFINE| block at the
end of the pattern, and that you name any subpatterns defined within it.

Also, it's worth noting that patterns defined this way probably will not
be as efficient, as the optimiser is not very clever about handling them.

An example of how this might be used is as follows:

\begin{verbatim}
   1. /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
   2.        (?(DEFINE)
   3.          (?<NAME_PAT>....)
   4.          (?<ADRESS_PAT>....)
   5. )/x
\end{verbatim}

Note that {\bf capture buffers matched inside of recursion are not accessible
after the recursion returns}, so the extra layer of capturing buffers is
necessary. Thus \verb|$+{NAME_PAT}| would not be defined even though 
\verb|$+{NAME}|
would be.
\end{quotation}
\end{it}

\parrafo{Lo que dice {\tt perlvar} sobre patrones con nombre}
Esto es lo que dice \perldoc{perlvar} respecto a las variables implicadas \verb|%+|
y \verb|%-|. Con respecto a el hash \verb|%+|:

\begin{it}
\begin{quotation}
\begin{itemize}
\item \verb|%LAST_PAREN_MATCH|, \verb|%+|

Similar to \verb|@+| , the \verb|%+| hash allows access to the named capture buffers,
should they exist, in the last successful match in the currently active
dynamic scope.

For example, \verb|$+{foo}| is equivalent to \verb|$1| after the following match:

\begin{verbatim}
   1. 'foo' =~ /(?<foo>foo)/;
\end{verbatim}

The keys of the \verb|%+| hash list only the names of buffers that have
captured (and that are thus associated to defined values).

The underlying behaviour of \verb|%+| is provided by the \cpan{Tie::Hash::NamedCapture} 
module.

Note: \verb|%-| and \verb|%+| are tied views into a common internal
hash associated with the last successful regular expression. Therefore
mixing iterative access to them via \verb|each| may have unpredictable
results. Likewise, if the last successful match changes, then the results
may be surprising.

\item \verb|%-|

Similar to \verb|%+| , this variable allows access to the named capture
buffers in the last successful match in the currently active dynamic
scope. {\bf To each capture buffer name found in the regular expression,
it associates a reference to an array containing the list of values
captured by all buffers with that name (should there be several of them),
in the order where they appear}.

Here's an example:

\begin{verbatim}
   1. if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
   2.   foreach my $bufname (sort keys %-) {
   3.     my $ary = $-{$bufname};
   4.     foreach my $idx (0..$#$ary) {
   5.       print "\$-{$bufname}[$idx] : ",
   6.             (defined($ary->[$idx]) ? "'$ary->[$idx]'" : "undef"),
   7.             "\n";
   8.     }
   9.   }
  10. }
\end{verbatim}

would print out:

\begin{verbatim}
   1. $-{A}[0] : '1'
   2. $-{A}[1] : '3'
   3. $-{B}[0] : '2'
   4. $-{B}[1] : '4'
\end{verbatim}

The keys of the \verb|%-| hash correspond to all buffer names found in
the regular expression.

\end{itemize}
\end{quotation}
\end{it}

\subsection{Patrones Recursivos}

Perl 5.10 introduce la posibilidad de definir 
subpatrones en una sección del patrón. 
Citando la versión del documento \perldoc{perlretut} para
perl5.10:

\begin{it}
\begin{quotation}
This feature (introduced in Perl 5.10) significantly extends the power
of Perl’s pattern matching.  By referring to some other capture group
anywhere in the
pattern with the construct \verb"(?group-ref)", the pattern within the
referenced group is used as an independent subpattern in place of the
group reference itself.
Because the group reference may be contained within the group it refers
to, it is now possible to apply pattern matching to tasks that hitherto
required a
recursive parser.

...

In \verb"(?...)" both absolute and relative backreferences may be used.  
The entire pattern can be reinserted with \verb"(?R)" or \verb"(?0)".  If you prefer to name your
buffers, you can use \verb"(?&name)" to recurse into that buffer.
\end{quotation}
\end{it}

\parrafo{Palíndromos}
\label{parrafo:palabrapalindromos}

Véase un ejemplo que reconoce los palabra-palíndromos (esto es, 
la lectura directa y la inversa  de la cadena
pueden diferir en los signos de puntuación):

\begin{latexonly}
\begin{verbatim}
casiano@millo:~/Lperltesting$ cat -n palindromos.pl
  1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  2  use v5.10;
  3
  4  my $regexp = qr/^(\W*
  5                       (?:
  6                             (\w) (?1) \g{-1}  # palindromo estricto
  7                           |
  8                             \w?               # no recursiva
  9                       )
 10                    \W*)$/ix;
 11
 12  my $input = <>;
 13  chomp($input);
 14  if ($input =~ $regexp) {
 15    say "$input is a palindrome";
 16  }
 17  else {
 18    say "does not match";
 19  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
casiano<span class="synIdentifier">@millo</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat -n palindromos</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synConstant">     1  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
     <span class="synConstant">3</span>
     <span class="synConstant">4</span>  <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span>
<span class="synConstant">     5                       </span><span class="synSpecial">(?:</span>
<span class="synConstant">     6                             </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\g</span><span class="synConstant">{-1}  # palindromo estricto</span>
<span class="synConstant">     7                           |</span>
<span class="synConstant">     8                             </span><span class="synSpecial">\w?</span><span class="synConstant">               # no recursiva</span>
<span class="synConstant">     9                       </span><span class="synSpecial">)</span>
<span class="synConstant">    10                    </span><span class="synSpecial">\W*)</span><span class="synConstant">$/ix</span>;
    <span class="synConstant">11</span>
    <span class="synConstant">12</span>  <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
    <span class="synConstant">13</span>  <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
    <span class="synConstant">14</span>  <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
    <span class="synConstant">15</span>    say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
    <span class="synConstant">16</span>  }
    <span class="synConstant">17</span>  <span class="synStatement">else</span> {
    <span class="synConstant">18</span>    say <span class="synConstant">&quot;does not match&quot;</span>;
    <span class="synConstant">19</span>  }
</pre>

\end{rawhtml}
%}}}


\begin{exercise}
¿Cuál es el efecto del modificador \verb|i|
en la regexp \verb#qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix#?
\end{exercise}


Siguen algunos ejemplos de ejecución\footnote{
\begin{itemize}
\item saippuakauppias: Vendedor de jabón (suomi)
\item yam: batata (inglés)
\item cam: leva
\end{itemize}
}
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a canal: Panama!
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cam, a yak, a yam, a canal – Panama!
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
saippuakauppias
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ ./palindromos.pl
dfghjgfd
does not match
pl@nereida:~/Lperltesting$ ./palindromos.pl
...,;;;;
...,;;;; is a palindrome
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a canal: Panama!</span>
A man, a plan, a canal: Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cam, a yak, a yam, a canal – Panama!</span>
A man, a plan, a cam, a yak, a yam, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama!</span>
A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal – Panama! is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">saippuakauppias</span>
saippuakauppias is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./palindromos.pl</span>
<span class="dbuser">dfghjgfd</span>
does not match
<span class="dbuser">pl@nereida:~/Lperltesting$ ./palindromos.pl</span>
<span class="dbuser">...,;;;;</span>
...,;;;; is a palindrome
</pre>
\end{rawhtml}
%}}}

\parrafo{Lo que dice {\tt perlre} sobre recursividad}


\begin{it}
\begin{quotation}
\verb|(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)|

Similar to \verb|(??{ code })| (véase la sección
\ref{subsection:tiempodematching})
except it does not involve compiling any code,
instead it treats the contents of a capture buffer as an independent
pattern that must match at the current position. Capture buffers
contained by the pattern will have the value as determined by the
outermost recursion.

\verb|PARNO| is a sequence of digits (not starting with 0) whose value
reflects the paren-number of the capture buffer to recurse to. 

\verb|(?R)|
recurses to the beginning of the whole pattern. \verb|(?0)| is an alternate
syntax for \verb|(?R)|. 

If \verb|PARNO| is preceded by a plus or minus sign then it
is assumed to be relative, with negative numbers indicating preceding
capture buffers and positive ones following. Thus (?-1) refers to the
most recently declared buffer, and (?+1) indicates the next buffer to
be declared. 

Note that the counting for relative recursion differs from
that of relative backreferences, in that with recursion unclosed buffers
are included.
\end{quotation}
\end{it}
Hay una diferencia fundamental entre \verb|\g{-1}| y \verb|(?-1)|.
El primero significa {\it lo que casó con el último paréntesis}.
El segundo significa que se debe {\it llamar a la expresión regular 
que define el último paréntesis}. Véase un ejemplo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1>  x ($a = "12 aAbB 34") =~ s/([aA])(?-1)(?+1)([bB])/-\1\2-/g
0  1
  DB<2> p $a
12 -aB- 34
\end{verbatim}

En \perldoc{perlre} también se comenta sobre este punto:
\begin{it}\begin{quotation} 
If there is no corresponding capture buffer defined, then it is a fatal
error. Recursing deeper than 50 times without consuming any input string
will also result in a fatal error. The maximum depth is compiled into
perl, so changing it requires a custom build.
\end{quotation}
\end{it}


\parrafo{Paréntesis Equilibrados}

El siguiente programa (inspirado en uno
que aparece en \perldoc{perlre})
reconoce una llamada a una función \verb|foo()|
que puede contener una secuencia de expresiones con paréntesis equilibrados
como argumento:

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat perlrebalancedpar.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
  3  use v5.10;
  4  use strict;
  5  
  6  my $regexp = qr{ (                      # paren group 1 (full function)
  7                  foo
  8                     (                    # paren group 2 (parens)
  9                       \(
 10                          (               # paren group 3 (contents of parens)
 11                             (?:
 12                                  [^()]+  # Non-parens
 13                                |
 14                                  (?2) # Recurse to start of paren group 2
 15                             )*
 16                          )               # 3
 17                       \)
 18                      )                   # 2
 19                )                         # 1
 20      }x;
 21  
 22  my $input = <>;
 23  chomp($input);
 24  my @res = ($input =~ /$regexp/);
 25  if (@res) {
 26    say "<$&> is balanced\nParen: (@res)";
 27  }
 28  else {
 29    say "does not match";
 30  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat perlrebalancedpar</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span>  <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(</span><span class="synConstant">                      # paren group 1 </span><span class="synSpecial">(</span><span class="synConstant">full function</span><span class="synSpecial">)</span>
<span class="synLinenum">    7</span> <span class="synConstant">                foo</span>
<span class="synLinenum">    8</span> <span class="synConstant">                   </span><span class="synSpecial">(</span><span class="synConstant">                    # paren group 2 </span><span class="synSpecial">(</span><span class="synConstant">parens</span><span class="synSpecial">)</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">\(</span>
<span class="synLinenum">   10</span> <span class="synConstant">                        </span><span class="synSpecial">(</span><span class="synConstant">               # paren group 3 </span><span class="synSpecial">(</span><span class="synConstant">contents of parens</span><span class="synSpecial">)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                </span><span class="synSpecial">[^()]+</span><span class="synConstant">  # Non-parens</span>
<span class="synLinenum">   13</span> <span class="synConstant">                              |</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                </span><span class="synSpecial">(?</span><span class="synConstant">2</span><span class="synSpecial">)</span><span class="synConstant"> # Recurse to start of paren group 2</span>
<span class="synLinenum">   15</span> <span class="synConstant">                           </span><span class="synSpecial">)*</span>
<span class="synLinenum">   16</span> <span class="synConstant">                        </span><span class="synSpecial">)</span><span class="synConstant">               # 3</span>
<span class="synLinenum">   17</span> <span class="synConstant">                     </span><span class="synSpecial">\)</span>
<span class="synLinenum">   18</span> <span class="synConstant">                    </span><span class="synSpecial">)</span><span class="synConstant">                   # 2</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span><span class="synConstant">                         # 1</span>
<span class="synLinenum">   20</span> <span class="synConstant">    }x</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">my</span> <span class="synIdentifier">@res</span> = (<span class="synIdentifier">$input</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$regexp</span><span class="synStatement">/</span>);
<span class="synLinenum">   25</span> <span class="synStatement">if</span> (<span class="synIdentifier">@res</span>) {
<span class="synLinenum">   26</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; is balanced</span><span class="synSpecial">\n</span><span class="synConstant">Paren: (</span><span class="synIdentifier">@res</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   27</span> }
<span class="synLinenum">   28</span> <span class="synStatement">else</span> {
<span class="synLinenum">   29</span>   say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   30</span> }
</pre>

\end{rawhtml}
%}}}
Al ejecutar obtenemos:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./perlrebalancedpar.pl
foo(bar(baz)+baz(bop))
<foo(bar(baz)+baz(bop))> is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$  <span class="dbuser">./perlrebalancedpar.pl</span>
<span class="dbuser">foo(bar(baz)+baz(bop))</span>
&lt;foo(bar(baz)+baz(bop))&gt; is balanced
Paren: (foo(bar(baz)+baz(bop)) (bar(baz)+baz(bop)) bar(baz)+baz(bop))
</pre>
\end{rawhtml}
%}}}



Como se comenta en \perldoc{perlre} es conveniente usar 
índices relativos si se quiere tener una expresión regular reciclable:

\begin{it}
\begin{quotation}
The following shows how using negative indexing can make it easier to
embed recursive patterns inside of a \verb|qr//| construct for later use:

\begin{verbatim}
   1. my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
   2. if (/foo $parens \s+ + \s+ bar $parens/x) {
   3.   # do something here...
   4. }
\end{verbatim}
\end{quotation} 
\end{it}
Véase la sección 
\ref{subsection:cuantificadoresposesivos}
para comprender el uso de los operadores posesivos como \verb|++|.

\parrafo{Capturando los bloques de un programa}
\label{parrafo:bloquesanidados}

El siguiente programa presenta una heurística 
para determinar los bloques de un programa:

\begin{latexonly}
\begin{verbatim}
  1    pl@nereida:~/Lperltesting$ cat blocks.pl
  2    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3    use v5.10;
  4    use strict;
  5    #use re 'debug';
  6    
  7    my $rb = qr{(?x)
  8        (
  9          \{               # llave abrir
 10             (?:
 11                 [^{}]++   # no llaves
 12             |
 13                  [^{}]*+  # no llaves
 14                  (?1)     # recursivo
 15                  [^{}]*+  # no llaves
 16             )*+
 17           \}              # llave cerrar
 18        )
 19      };
 20    
 21    local $/ = undef;
 22    my $input = <>;
 23    my@blocks = $input =~ m{$rb}g;
 24    my $i = 0;
 25    say($i++.":\n$_\n===") for @blocks;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span>   pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocks</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">  #!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span>   <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span>   
<span class="synLinenum">    7</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">      </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">        </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">           </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">               </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">           |</span>
<span class="synLinenum">   13</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   14</span> <span class="synConstant">                </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">     # recursivo</span>
<span class="synLinenum">   15</span> <span class="synConstant">                </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">  # no llaves</span>
<span class="synLinenum">   16</span> <span class="synConstant">           </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   17</span> <span class="synConstant">         </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">    }</span>;
<span class="synLinenum">   20</span>   
<span class="synLinenum">   21</span>   <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   25</span>   say(<span class="synIdentifier">$i</span>++.<span class="synConstant">&quot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===&quot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

\end{rawhtml}
%}}}

Veamos una ejecución. Le daremos como entrada el siguiente programa:
Al ejecutar el programa con esta entrada obtenemos:

\begin{tabular}{|p{8cm}|p{8cm}|}
\hline
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n blocks.c
     1  main() { /* 1 */
     2    { /* 2 */ }
     3    { /* 3 */ }
     4  }
     5
     6  f(){  /* 4 */
     7    {   /* 5 */
     8      { /* 6 */ }
     9    }
    10    {   /* 7 */
    11      { /* 8 */ }
    12    }
    13  }
    14
    15  g(){ /* 9 */
    16  }
    17
    18  h() {
    19  {{{}}}
    20  }
    21  /* end h */
\end{verbatim}
&
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 blocks.pl blocks.c
0:
{ /* 1 */
  { /* 2 */ }
  { /* 3 */ }
}
===
1:
{  /* 4 */
  {   /* 5 */
    { /* 6 */ }
  }
  {   /* 7 */
    { /* 8 */ }
  }
}
===
2:
{ /* 9 */
}
===
3:
{
{{{}}}
}
===
\end{verbatim}
\\
\hline
\end{tabular}

\parrafo{Reconocimiento de Lenguajes Recursivos: Un subconjunto de \LaTeX{}}
\label{subsection:regexp510lenrec}

La posibilidad de combinar en las expresiones regulares Perl 5.10 
la recursividad con los constructos \verb|(?<name>...)| 
y \verb|?&name)| así como las secciones \verb|(?(DEFINE) ...)|
permiten la escritura de expresiones regulares que reconocen lenguajes recursivos. 
El siguiente 
ejemplo muestra un reconocedor de un subconjunto del lenguaje 
\LaTeX{} (véase \wikip{la entrada LaTeX en la wikipedia}{LaTeX}):

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat latex5_10.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use strict;
  4  use v5.10;
  5  
  6  my $regexp = qr{
  7      \A(?&File)\z
  8  
  9      (?(DEFINE)
 10          (?<File>     (?&Element)*+\s*
 11          )
 12  
 13          (?<Element>  \s* (?&Command)
 14                    |  \s* (?&Literal)
 15          )
 16  
 17          (?<Command>  \\ \s* (?<L>(?&Literal)) \s* (?<Op>(?&Options)?) \s* (?<A>(?&Args))
 18             (?{
 19                say "command: <$+{L}> options: <$+{Op}> args: <$+{A}>"
 20             })
 21          )
 22  
 23          (?<Options>  \[ \s* (?:(?&Option) (?:\s*,\s* (?&Option) )*)? \s* \]
 24          )
 25  
 26          (?<Args>     (?: \{ \s* (?&Element)* \s* \} )*
 27          )
 28  
 29          (?<Option>   \s* [^][\$&%#_{}~^\s,]+
 30          )
 31  
 32          (?<Literal>  \s* ([^][\$&%#_{}~^\s]+)
 33          )
 34      )
 35  }xms;
 36  
 37  my $input = do{ local $/; <>};
 38  if ($input =~ $regexp) {
 39    say "$@: matches:\n$&";
 40  }
 41  else {
 42    say "does not match";
 43  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat latex5_10</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    7</span> <span class="synConstant">    </span><span class="synSpecial">\A(?</span><span class="synConstant">&amp;File</span><span class="synSpecial">)\z</span>
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synConstant">    </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;File&gt;     </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Element</span><span class="synSpecial">)*+\s*</span>
<span class="synLinenum">   11</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> 
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Element&gt;  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Command</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                  |  </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">)</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">)</span>
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Command&gt;  </span><span class="synSpecial">\\</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Literal</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;Op&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Options</span><span class="synSpecial">)?)</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;A&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&amp;Args</span><span class="synSpecial">))</span>
<span class="synLinenum">   18</span> <span class="synConstant">           </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   19</span> <span class="synConstant">              say &quot;command: &lt;</span><span class="synIdentifier">$+</span><span class="synConstant">{L}</span>&gt; options: &lt;<span class="synIdentifier">$+</span>{Op}&gt; args: &lt;<span class="synIdentifier">$+</span>{A}&gt;<span class="synConstant">&quot;</span>
<span class="synLinenum">   20</span> <span class="synConstant">           })</span>
<span class="synLinenum">   21</span> <span class="synConstant">        )</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span> <span class="synConstant">        (?&lt;Options&gt;  </span><span class="synSpecial">\[</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?:(?&amp;Option) (?:</span><span class="synSpecial">\s</span><span class="synConstant">*,</span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Option) )*)? </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">\]</span>
<span class="synLinenum">   24</span> <span class="synConstant">        )</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">        (?&lt;Args&gt;     (?: </span><span class="synSpecial">&#92;{</span><span class="synConstant"> </span><span class="synSpecial">\s</span><span class="synConstant">* (?&amp;Element)* </span><span class="synSpecial">\s</span><span class="synConstant">* </span><span class="synSpecial">&#92;}</span><span class="synConstant"> )*</span>
<span class="synLinenum">   27</span> <span class="synConstant">        )</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        (?&lt;Option&gt;   </span><span class="synSpecial">\s</span><span class="synConstant">* [^][</span><span class="synSpecial">\$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">,]+</span>
<span class="synLinenum">   30</span> <span class="synConstant">        )</span>
<span class="synLinenum">   31</span> 
<span class="synLinenum">   32</span> <span class="synConstant">        (?&lt;Literal&gt;  </span><span class="synSpecial">\s</span><span class="synConstant">* ([^][</span><span class="synSpecial">\$</span><span class="synConstant">&amp;%#_{}~^</span><span class="synSpecial">\s</span><span class="synConstant">]+)</span>
<span class="synLinenum">   33</span> <span class="synConstant">        )</span>
<span class="synLinenum">   34</span> <span class="synConstant">    )</span>
<span class="synLinenum">   35</span> <span class="synConstant">}xms;</span>
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span> <span class="synConstant">my </span><span class="synIdentifier">$input</span><span class="synConstant"> = do{ local </span><span class="synIdentifier">$/</span><span class="synConstant">; &lt;&gt;};</span>
<span class="synLinenum">   38</span> <span class="synConstant">if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$regexp</span><span class="synConstant">) {</span>
<span class="synLinenum">   39</span> <span class="synConstant">  say &quot;</span><span class="synIdentifier">$@</span>: matches:\n<span class="synIdentifier">$&amp;</span><span class="synConstant">&quot;;</span>
<span class="synLinenum">   40</span> <span class="synConstant">}</span>
<span class="synLinenum">   41</span> <span class="synConstant">else {</span>
<span class="synLinenum">   42</span> <span class="synConstant">  say &quot;</span>does <span class="synStatement">not</span> match<span class="synConstant">&quot;;</span>
<span class="synLinenum">   43</span> <span class="synConstant">}</span>
</pre>

\end{rawhtml}
%}}}


Añadimos una acción semántica al final de la aceptación de un \verb|<Command>|.

\begin{verbatim}
         (?<Command>  \\ \s* (?<L>(?&Literal)) \s* (?<Op>(?&Options)?) \s* (?<A>(?&Args)?)
            (?{
               say "command: <$+{L}> options: <$+{Op}> args: <$+{A}>"
            })
         )
\end{verbatim}
Esta acción es ejecutada pero no afecta al proceso de análisis.
(véase la sección
\ref{subsection:codigoenregexp} para mas información sobre las acciones semánticas
en medio de una regexp).
La acción se limita a mostrar que ha casado con cada una de las tres componentes:
el comando, las opciones y los argumentos.

Los paréntesis adicionales, como en \verb|(?<L>(?&Literal))| son necesarios 
para guardar lo que casó.

Cuando se ejecuta produce la siguiente salida\footnote{
\begin{itemize}
\item peasy:A disagreeable taste of very fresh green peas
\item easy peasy: 
\begin{enumerate}
  \item (uk) very easy (short for easy-peasy-lemon-squeezy) 
  \item         
  the first half of a rhyming phrase with several alternate second halves,
  all of which connote an activity or a result that is, respectively,
  simple to perform or achieve.

\begin{it}
\begin{verse}
  Tie your shoes? Why that's easy peasy lemon squeezy!\\
  Beat your meat? Why that's easy peasy Japanesey!\\
  As a red-stater, condemn books and films without having read or seen them? Why that's easy peasy puddin'n'pie!\\
\end{verse}
\end{it}
  \item
  It comes from a 1970's british TV commercial for Lemon Squeezy
  detergent. They were with a little girl who points out dirty greasy
  dishes to an adult (mom or relative) and then this adult produces
  Lemon Squeezy and they clean the dishes quickly. At the end of the
  commercial the girl says {\it Easy Peasy Lemon Squeezy}.

  Today it is a silly way to state something was or will be very easy. 
\end{enumerate}
\end{itemize}
}: % end footnote
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat prueba.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba.tex
command: <documentclass> options: <[a4paper,11pt]> args: <{article}>
command: <usepackage> options: <> args: <{latexsym}>
command: <author> options: <> args: <{D. Conway}>
command: <LaTeX> options: <> args: <{}>
command: <title> options: <> args: <{Parsing \LaTeX{}}>
command: <begin> options: <> args: <{document}>
command: <maketitle> options: <> args: <>
command: <tableofcontents> options: <> args: <>
command: <section> options: <> args: <{Description}>
command: <emph> options: <> args: <{necessarily}>
command: <footnote> options: <> args: <{But not\\ \emph{necessarily} simple}>
command: <end> options: <> args: <{document}>
: matches:
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
In fact it's easy peasy to do.
\end{document}

\end{verbatim}
La siguiente entrada \verb|prueba3.tex| no pertenece
al lenguaje definido por el patrón regular,
debido a la presencia de la cadena \verb|$In$|
en la última línea:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat prueba3.tex
\documentclass[a4paper,11pt]{article}
\usepackage{latexsym}
\author{D. Conway}
\title{Parsing \LaTeX{}}
\begin{document}
\maketitle
\tableofcontents
\section{Description}
\comm{a}{b}
...is easy \footnote{But not\\ \emph{necessarily} simple}.
$In$ fact it's easy peasy to do.
\end{document}

pl@nereida:~/Lperltesting$ ./latex5_10.pl prueba3.tex
command: <documentclass> options: <[a4paper,11pt]> args: <{article}>
command: <usepackage> options: <> args: <{latexsym}>
command: <author> options: <> args: <{D. Conway}>
command: <LaTeX> options: <> args: <{}>
command: <title> options: <> args: <{Parsing \LaTeX{}}>
command: <begin> options: <> args: <{document}>
command: <maketitle> options: <> args: <>
command: <tableofcontents> options: <> args: <>
command: <section> options: <> args: <{Description}>
command: <comm> options: <> args: <{a}{b}>
command: <emph> options: <> args: <{necessarily}>
command: <footnote> options: <> args: <{But not\\ \emph{necessarily} simple}>
does not match
\end{verbatim}

\begin{exercise}
Obsérvese el uso del cuantificador posesivo en:
\begin{verbatim}
 10          (?<File>     (?&Element)*+\s*
 11          )
\end{verbatim}
¿Que ocurrre si se quita el posesivo 
y se vuelve a ejecutar \verb|$ ./latex5_10.pl prueba3.tex|?
\end{exercise}

\parrafo{Reconocimiento de Expresiones Aritméticas}

Véase el nodo \pmm{585167}{Complex regex for maths formulas}
en perlmonks
para la formulación del problema. Un monje pregunta:

\begin{it}\begin{quotation} 
Hiya monks,

Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...

There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than \verb|a-z,A-Z,0-9,+,-,*,/,(,)| can be used

Can anyone offer a hand on how best to tackle this problem?

many thanks 
\end{quotation}\end{it} 

La solución parte de que una {\it expresión} es o bien un {\it término} o bien 
un {\it término} seguido de una operador y un {\it término}, esto es:

\begin{itemize}
\item \verb|termino|
\item \verb|termino op termino op termino| \ldots
\end{itemize}
que puede ser unificado como \verb|termino (op termino)*|.
  
Un {\it término} es un número o un identificador o una {\it expresión}
entre paréntesis, esto es:

\begin{itemize}
\item \verb|numero|
\item \verb|identificador|
\item \verb| ( expresión ) |
\end{itemize}
 
 La siguiente expresión regular recursiva sigue esta idea:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    local our ($skip, $term, $expr);
  7    $skip = qr/\s*/;
  8    $expr = qr{ (?<EXPR>
  9                       (?<TERM>              # An expression is a TERM  ...
 10                              $skip (?<ID>[a-zA-Z]+)
 11                            | $skip (?<INT>[1-9]\d*)
 12                            | $skip \(
 13                              $skip  (?&EXPR)
 14                              $skip \)
 15                       ) (?: $skip           # possibly followed by a sequence of ...
 16                             (?<OP>[-+*/])
 17                             (?&TERM)        # ... operand TERM pairs
 18                         )*
 19                )
 20              }x;
 21    my $re = qr/^ $expr $skip \z/x;
 22    sub is_valid { shift =~ /$re/o }
 23  
 24    my @test = ( '(a + 3)', '(3 * 4)+(b + x)', '(5 - a)*z',
 25                  '((5 - a))*((((z)))+2)', '3 + 2', '!3 + 2', '3 + 2!',
 26                  '3 a', '3 3', '3 * * 3',
 27                  '2 - 3 * 4',  '2 - 3 + 4',
 28                );
 29    foreach (@test) {
 30      say("$_:");
 31      say(is_valid($_) ? "\n<$_> is valid" : "\n<$_> is not valid")
 32    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressionsna.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    7</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">    8</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">    9</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span>
<span class="synLinenum">   11</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;INT&gt;</span><span class="synSpecial">[1-9]\d*)</span>
<span class="synLinenum">   12</span> <span class="synConstant">                          | </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\(</span>
<span class="synLinenum">   13</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">&amp;EXPR</span><span class="synSpecial">)</span>
<span class="synLinenum">   14</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\)</span>
<span class="synLinenum">   15</span> <span class="synConstant">                     </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant">           # possibly followed by a sequence of </span><span class="synSpecial">...</span>
<span class="synLinenum">   16</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&lt;OP&gt;</span><span class="synSpecial">[-+*/])</span>
<span class="synLinenum">   17</span> <span class="synConstant">                           </span><span class="synSpecial">(?</span><span class="synConstant">&amp;TERM</span><span class="synSpecial">)</span><span class="synConstant">        # </span><span class="synSpecial">...</span><span class="synConstant"> operand TERM pairs</span>
<span class="synLinenum">   18</span> <span class="synConstant">                       </span><span class="synSpecial">)*</span>
<span class="synLinenum">   19</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   20</span> <span class="synConstant">            }x</span>;
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   22</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   25</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   26</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   28</span>               );
<span class="synLinenum">   29</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   30</span>     say(<span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant">:&quot;</span>);
<span class="synLinenum">   31</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid&quot;</span> : <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid&quot;</span>)
<span class="synLinenum">   32</span>   }
</pre>

\end{rawhtml}
%}}}
Podemos usar acciones semánticas empotradas para 
ver la forma en la que trabaja la expresión regular
(véase la sección
\ref{subsection:codigoenregexp}):

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3    use strict;
  4    use warnings;
  5  
  6    use re 'eval'; # to allow Eval-group at runtime
  7  
  8    local our ($skip, $term, $expr);
  9    $skip = qr/\s*/;
 10    $expr = qr{ (?<EXPR>
 11                       (?<TERM>              # An expression is a TERM  ...
 12                              $skip (?<ID>[a-zA-Z]+)  (?{ print "[ID $+{ID}] "  })
 13                            | $skip (?<INT>[1-9]\d*)  (?{ print "[INT $+{INT}] " })
 14                            | $skip \(                (?{ print "[(] " })
 15                              $skip  (?&EXPR)
 16                              $skip \)                (?{ print "[)] " })
 17                       ) (?: $skip           # possibly followed by a sequence of ...
 18                             (?<OP>[-+*/])            (?{ print "[OP $+{OP}] " })
 19                             (?&TERM)        # ... operand TERM pairs
 20                         )*
 21                )
 22              }x;
 23    my $re = qr/^ $expr $skip \z/x;
 24    sub is_valid { shift =~ /$re/o }
 25  
 26    my @test = ( '(a + 3)', '(3 * 4)+(b + x)', '(5 - a)*z',
 27                  '((5 - a))*((((z)))+2)', '3 + 2', '!3 + 2', '3 + 2!',
 28                  '3 a', '3 3', '3 * * 3',
 29                  '2 - 3 * 4',  '2 - 3 + 4',
 30                );
 31    foreach (@test) {
 32      say("$_:");
 33      say(is_valid($_) ? "\n<$_> is valid" : "\n<$_> is not valid")
 34    }
\end{verbatim}
\end{latexonly}
%{{{ simpleexpressions.pl
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n simpleexpressions.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>   <span class="synIdentifier">$skip</span> = <span class="synConstant">qr/</span><span class="synSpecial">\s*</span><span class="synConstant">/</span>;
<span class="synLinenum">   10</span>   <span class="synIdentifier">$expr</span> = <span class="synConstant">qr{ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;EXPR&gt;</span>
<span class="synLinenum">   11</span> <span class="synConstant">                     </span><span class="synSpecial">(?</span><span class="synConstant">&lt;TERM&gt;              # An expression is a TERM  </span><span class="synSpecial">...</span>
<span class="synLinenum">   12</span> <span class="synConstant">                            </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;ID&gt;</span><span class="synSpecial">[a-zA-Z]+)</span><span class="synConstant">  </span><span class="synSpecial">(?</span><span class="synConstant">{ print &quot;</span><span class="synSpecial">[ID $+{ID}]</span><span class="synConstant"> &quot;  }</span>)
<span class="synLinenum">   13</span>                           | <span class="synIdentifier">$skip</span> (?<span class="synIdentifier">&lt;INT&gt;</span>[<span class="synConstant">1-9</span>]\d*)  (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[INT </span><span class="synIdentifier">$+</span><span class="synConstant">{INT}] &quot;</span> })
<span class="synLinenum">   14</span>                           | <span class="synIdentifier">$skip</span> \(                (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[(] &quot;</span> })
<span class="synLinenum">   15</span>                             <span class="synIdentifier">$skip</span>  (?<span class="synIdentifier">&amp;EXPR</span>)
<span class="synLinenum">   16</span>                             <span class="synIdentifier">$skip</span> \)                (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[)] &quot;</span> })
<span class="synLinenum">   17</span>                      ) (?: <span class="synIdentifier">$skip</span>           <span class="synComment"># possibly followed by a sequence of ...</span>
<span class="synLinenum">   18</span>                            (?<span class="synIdentifier">&lt;OP&gt;</span>[-+*/])            (?{ <span class="synStatement">print</span> <span class="synConstant">&quot;[OP </span><span class="synIdentifier">$+</span><span class="synConstant">{OP}] &quot;</span> })
<span class="synLinenum">   19</span>                            (?<span class="synIdentifier">&amp;TERM</span>)        <span class="synComment"># ... operand TERM pairs</span>
<span class="synLinenum">   20</span>                        )*
<span class="synLinenum">   21</span>               )
<span class="synLinenum">   22</span>             }x;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$re</span> = <span class="synConstant">qr/^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant">/x</span>;
<span class="synLinenum">   24</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid </span>{ <span class="synStatement">shift</span> =~<span class="synStatement"> /</span><span class="synIdentifier">$re</span><span class="synStatement">/o</span> }
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">@test</span> = ( <span class="synConstant">'(a + 3)'</span>, <span class="synConstant">'(3 * 4)+(b + x)'</span>, <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   27</span>                 <span class="synConstant">'((5 - a))*((((z)))+2)'</span>, <span class="synConstant">'3 + 2'</span>, <span class="synConstant">'!3 + 2'</span>, <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   28</span>                 <span class="synConstant">'3 a'</span>, <span class="synConstant">'3 3'</span>, <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   29</span>                 <span class="synConstant">'2 - 3 * 4'</span>,  <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   30</span>               );
<span class="synLinenum">   31</span>   <span class="synStatement">foreach</span> (<span class="synIdentifier">@test</span>) {
<span class="synLinenum">   32</span>     say(<span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant">:&quot;</span>);
<span class="synLinenum">   33</span>     say(is_valid(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is valid&quot;</span> : <span class="synConstant">&quot;</span><span class="synSpecial">\n</span><span class="synConstant">&lt;</span><span class="synIdentifier">$_</span><span class="synConstant">&gt; is not valid&quot;</span>)
<span class="synLinenum">   34</span>   }
</pre>

\end{rawhtml}
%}}}

Ejecución:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./simpleexpressions.pl
(a + 3):
[(] [ID a] [OP +] [INT 3] [)]
<(a + 3)> is valid
(3 * 4)+(b + x):
[(] [INT 3] [OP *] [INT 4] [)] [OP +] [(] [ID b] [OP +] [ID x] [)]
<(3 * 4)+(b + x)> is valid
(5 - a)*z:
[(] [INT 5] [OP -] [ID a] [)] [OP *] [ID z]
<(5 - a)*z> is valid
((5 - a))*((((z)))+2):
[(] [(] [INT 5] [OP -] [ID a] [)] [)] [OP *] [(] [(] [(] [(] [ID z] [)] [)] [)] [OP +] [INT 2] [)]
<((5 - a))*((((z)))+2)> is valid
3 + 2:
[INT 3] [OP +] [INT 2]
<3 + 2> is valid
!3 + 2:

<!3 + 2> is not valid
3 + 2!:
[INT 3] [OP +] [INT 2]
<3 + 2!> is not valid
3 a:
[INT 3]
<3 a> is not valid
3 3:
[INT 3]
<3 3> is not valid
3 * * 3:
[INT 3] [OP *]
<3 * * 3> is not valid
2 - 3 * 4:
[INT 2] [OP -] [INT 3] [OP *] [INT 4]
<2 - 3 * 4> is valid
2 - 3 + 4:
[INT 2] [OP -] [INT 3] [OP +] [INT 4]
<2 - 3 + 4> is valid
\end{verbatim}

\subsection{Cuantificadores Posesivos}
\label{subsection:cuantificadoresposesivos}

Por defecto, cuando un subpatrón con un cuantificador impide que 
el patrón global tenga éxito, se produce un backtrack.
Hay ocasiones en las que esta conducta 
da lugar a ineficiencia.

Perl 5.10 provee los cuantificadores posesivos:
Un cuantificador posesivo actúa como un cuantificador greedy
pero no se produce backtracking.

\begin{tabular}{|p{2cm}|l}
\hline
    \verb|*+| &     Casar 0 o mas veces y no retroceder\\
\hline
    \verb|++| &     Casar 1 o mas veces y no retroceder\\
\hline
    \verb|?+| &     Casar 0 o 1 veces y no retroceder\\
\hline
    \verb|{n}+| &   Casar exactamente n veces y no retroceder (redundante)\\
\hline
    \verb|{n,}+| &  Casar al menos n veces y no retroceder\\
\hline
    \verb|{n,m}+| & Casar al menos n veces y no mas de m veces y no retroceder\\
\hline
\end{tabular}
Por ejemplo, la cadena \verb|'aaaa'| no casa con \verb|/(a++a)/| porque no 
hay retroceso después de leer las 4 aes:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x 'aaaa' =~ /(a+a)/
0  'aaaa'
  DB<2> x 'aaaa' =~ /(a++a)/
  empty array
\end{verbatim}

\parrafo{Cadenas Delimitadas por Comillas Dobles}

Los operadores posesivos sirven para poder escribir expresiones regulares mas eficientes
en aquellos casos en los que sabemos que el retroceso no conducirá a nuevas soluciones, como
es el caso del reconocimiento de las cadenas delimitadas por 
comillas dobles:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./quotedstrings.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
     2  use v5.10;
     3
     4  my $regexp = qr/
     5    "             # double quote
     6    (?:           # no memory
     7        [^"\\]++  # no " or escape: Don't backtrack
     8      | \\.       # escaped character
     9    )*+
    10    "             # end double quote
    11  /x;
    12
    13  my $input = <>;
    14  chomp($input);
    15  if ($input =~ $regexp) {
    16    say "$& is a string";
    17  }
    18  else {
    19    say "does not match";
    20  }
\end{verbatim}

\parrafo{Paréntesis Posesivos}

Los paréntesis posesivos \verb|(?> ...)| dan lugar a un reconocedor 
que rechaza las demandas de retroceso. 
De hecho, los operadores posesivos pueden ser reescritos 
en términos de los paréntesis posesivos:
La notación \verb|X++| es equivalente a \verb|(?>X+)|.

\parrafo{Paréntesis Balanceados}

El siguiente ejemplo reconoce el lenguaje de los paréntesis balanceados:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./balancedparenthesis.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3
 4  my $regexp =
 5      qr/^(
 6             [^()]*+ # no hay paréntesis, no backtrack
 7            \(
 8                (?>        # subgrupo posesivo
 9                   [^()]++ # no hay paréntesis, + posesivo, no backtrack
10                  |(?1)    # o es un paréntesis equilibrado
11                )*
12             \)
13             [^()]*+ # no hay paréntesis
14           )$/x;
15
16  my $input = <>;
17  chomp($input);
18  if ($input =~ $regexp) {
19    say "$& is a balanced parenthesis";
20  }
21  else {
22    say "does not match";
23  }
\end{verbatim}
Cuando se ejecuta produce una salida como:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5)*2
(2*(3+4)-5)*2 is a balanced parenthesis
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
(2*(3+4)-5))*2
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
2*(3+4
does not match
pl@nereida:~/Lperltesting$ ./balancedparenthesis.pl
4*(2*(3+4)-5)*2
4*(2*(3+4)-5)*2 is a balanced parenthesis
\end{verbatim}

\parrafo{Encontrando los bloques de un programa}

El uso de los operadores posesivos nos permite reescribir 
la solución al problema de encontrar los bloques maximales
de un código dada en la
sección
\ref{parrafo:bloquesanidados}
de la siguiente manera:

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat blocksopti.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
  3  use v5.10;
  4  use strict;
  5  #use re 'debug';
  6  
  7  my $rb = qr{(?x)
  8      (
  9        \{               # llave abrir
 10           (?:
 11               [^{}]++   # no llaves
 12           |
 13               (?1)      # recursivo
 14               [^{}]*+   # no llaves
 15           )*+
 16         \}              # llave cerrar
 17      )
 18    };
 19  
 20  local $/ = undef;
 21  my $input = <>;
 22  my@blocks = $input =~ m{$rb}g;
 23  my $i = 0;
 24  say($i++.":\n$_\n===") for @blocks;
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat blocksopti</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span>
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synComment">#use re 'debug';</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$rb</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span>
<span class="synLinenum">    8</span> <span class="synConstant">    </span><span class="synSpecial">(</span>
<span class="synLinenum">    9</span> <span class="synConstant">      </span><span class="synSpecial">&#92;{</span><span class="synConstant">               # llave abrir</span>
<span class="synLinenum">   10</span> <span class="synConstant">         </span><span class="synSpecial">(?:</span>
<span class="synLinenum">   11</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]++</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   12</span> <span class="synConstant">         |</span>
<span class="synLinenum">   13</span> <span class="synConstant">             </span><span class="synSpecial">(?</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">      # recursivo</span>
<span class="synLinenum">   14</span> <span class="synConstant">             </span><span class="synSpecial">[^{}]*+</span><span class="synConstant">   # no llaves</span>
<span class="synLinenum">   15</span> <span class="synConstant">         </span><span class="synSpecial">)*+</span>
<span class="synLinenum">   16</span> <span class="synConstant">       </span><span class="synSpecial">&#92;}</span><span class="synConstant">              # llave cerrar</span>
<span class="synLinenum">   17</span> <span class="synConstant">    </span><span class="synSpecial">)</span>
<span class="synLinenum">   18</span> <span class="synConstant">  }</span>;
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synStatement">undef</span>;
<span class="synLinenum">   21</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   22</span> <span class="synStatement">my</span><span class="synIdentifier">@blocks</span> = <span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rb</span><span class="synStatement">}g</span>;
<span class="synLinenum">   23</span> <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synConstant">0</span>;
<span class="synLinenum">   24</span> say(<span class="synIdentifier">$i</span>++.<span class="synConstant">&quot;:</span><span class="synSpecial">\n</span><span class="synIdentifier">$_</span><span class="synSpecial">\n</span><span class="synConstant">===&quot;</span>) <span class="synStatement">for</span> <span class="synIdentifier">@blocks</span>;
</pre>

\end{rawhtml}
%}}}

\parrafo{Véase también}

\begin{itemize}
\item
\htmladdnormallink
{Possessive Quantifiers}
{http://www.regular-expressions.info/possessive.html}
en 
\htmladdnormallink
{http://www.regular-expressions.info/}
{http://www.regular-expressions.info/tutorial.html}
\item 
Nodo \emph{Possessive Quantifiers in Perl 5.10 regexps} en \perlmonk{793521}
\item 
perldoc \perldoc{perlre}
\end{itemize}

\subsection{Perl 5.10: Numeración de los Grupos en Alternativas}

A veces conviene tener una forma de acceso 
uniforme a la lista proporcionada por los paréntesis con memoria.
Por ejemplo, la siguiente expresión regular reconoce el 
lenguaje de las horas en notaciones civil y militar:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> '23:12' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "1->$1 2->$2\n"
1->23 2->12

  DB<2> '2312' =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/; print "3->$3 4->$4\n"
3->23 4->12
\end{verbatim}
Parece inconveniente tener los resultados en variables distintas.
El constructo \verb#(?| ...)# hace que los paréntesis se enumeren
relativos a las alternativas:

\begin{verbatim}
  DB<3> '2312' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1->$1 2->$2\n"
1->23 2->12

  DB<4> '23:12' =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))/; print "1->$1 2->$2\n"
1->23 2->12
\end{verbatim}
Ahora en ambos casos \verb|$1| y \verb|$2| contienen las horas y minutos.

%\subsection{Grupos de Captura de Enumeración en Alternativas}
%
%El siguiente texto tomado de la sección 
%Alternative capture group numbering
%de
%\pd{perlretut}{Alternative-capture-group-numbering}
%explica el propósito de esta extensión:
%
%\begin{it}
%\begin{quotation}
%Yet another capturing group numbering technique (also as from Perl
%5.10) deals with the problem of referring to groups within a set of
%alternatives. Consider a pattern for matching a time of the day, civil
%or military style:
%
%\begin{verbatim}
%   1. if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
%   2. # process hour and minute
%   3. }
%\end{verbatim}
%
%Processing the results requires an additional if statement to determine
%whether \verb|$1| and \verb|$2| or \verb|$3| and \verb|$4| contain the goodies. It would be easier if
%we could use buffer numbers 1 and 2 in second alternative as well, and
%this is exactly what the parenthesized construct \verb#(?|...)#, set around an
%alternative achieves. Here is an extended version of the previous pattern:
%
%\begin{verbatim}
%   1. if ( $time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/ ){
%   2. print "hour=$1 minute=$2 zone=$3\n";
%   3. }
%\end{verbatim}
%
%Within the alternative numbering group, buffer numbers start at the same
%position for each alternative. After the group, numbering continues with
%one higher than the maximum reached across all the alternatives.
%\end{quotation}
%\end{it}


\subsection{Ejecución de Código dentro de una Expresión Regular}
\label{subsection:codigoenregexp}

Es posible introducir código Perl dentro de una expresión regular.
Para ello se usa la notación \verb|(?{code})|.

El siguiente texto esta tomado de \pd{perlretut}{A-bit-of-magic:-executing-Perl-code-in-a-regular-expression}:

\begin{it}\begin{quote} 
Normally, regexps are a part of Perl expressions. Code evaluation
expressions turn that around by allowing arbitrary Perl code to be a
part of a regexp. A code evaluation expression is denoted (?{code}),
with code a string of Perl statements.

Be warned that this feature is considered experimental, and may be
changed without notice.

Code expressions are zero-width assertions, and the value they return
depends on their environment. 

There are two possibilities: either the
code expression is used as a conditional in a conditional expression
\verb|(?(condition)...)|, or it is not. 
\begin{itemize}
\item \begin{quote} 
If the code expression is a conditional,
the code is evaluated and the result (i.e., the result of the last
statement) is used to determine truth or falsehood. 

\end{quote} \item \begin{quote} If the code expression
is not used as a conditional, the assertion always evaluates true and
the result is put into the special variable \verb|$^R| . The variable \verb|$^R| can
then be used in code expressions later in the regexp
\end{quote}
\end{itemize}
\end{quote}\end{it} 

\parrafo{Resultado de la última ejecución}

Las expresiones de código son \cei{zero-width assertions}: no consumen entrada.
El resultado de la ejecución se salva en la variable especial \verb|$^R|.

Veamos un ejemplo:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> $x = "abcdef"
  DB<2> $x =~ /abc(?{ "Hi mom\n" })def(?{ print $^R })$/
Hi mom
  DB<3> $x =~ /abc(?{ print "Hi mom\n"; 4 })def(?{ print "$^R\n" })/
Hi mom
4
  DB<4> $x =~ /abc(?{ print "Hi mom\n"; 4 })ddd(?{ print "$^R\n" })/ # does not match
  DB<5>                                 
\end{verbatim}
En el último ejemplo (línea \verb|DB<4>|) ninguno de los \verb|print| se ejecuta dado que no hay matching.

\parrafo{El Código empotrado no es interpolado}

Tomado de \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
This zero-width assertion evaluates any embedded Perl code. It always
succeeds, and its code  is not interpolated. Currently, the rules to
determine where the code  ends are somewhat convoluted.
\end{quote}\end{it}

\parrafo{Contenido del último paréntesis y la variable por defecto en acciones empotradas}

Tomado de \pd{perlre}{Extended-Patterns}:
\begin{it}\begin{quote}
\ldots{} can be used with the special variable \verb|$^N| to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $x = "The brown fox jumps over the lazy dog"
  DB<2> x $x =~ /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i
0  'brown'
1  'fox'
  DB<3> p "color=$color animal=$animal\n"
color=brown animal=fox
  DB<4> $x =~ /the (\S+)(?{ print (substr($_,0,pos($_)))."\n" }) (\S+)/i
The brown
\end{verbatim}

Inside the \verb|(?{...})| block, \verb|$_| refers to the string the
regular expression is matching against. You can also use \verb|pos()| to know
what is the current position of matching within this string.
\end{quote}\end{it}

\parrafo{Los cuantificadores y el código empotrado}

Si se usa un cuantificador sobre un código empotrado,
actúa como un bucle:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> $x = "aaaa"
  DB<2>  $x =~ /(a(?{ $c++ }))*/
  DB<3> p $c
4
  DB<4> $y = "abcd"
  DB<5> $y =~ /(?:(.)(?{ print "-$1-\n" }))*/
-a-
-b-
-c-
-d-
\end{verbatim}

\parrafo{Ámbito}

Tomado (y modificado el ejemplo) de \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
\ldots The code  is properly scoped in the following sense: If the
assertion is backtracked (compare \pd{perlre}{Backtracking}), all changes introduced
after localization are undone, so that

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  use strict;

  our ($cnt, $res);

  sub echo {
 local our $pre = substr($_,0,pos($_));
 local our $post = (pos($_) < length)? (substr($_,1+pos($_))) : '';

 print("$pre(count = $cnt)$post\n");
  }

  $_ = 'a' x 8;
  m<
 (?{ $cnt = 0 }) # Initialize $cnt.
 (
   a
   (?{
     local $cnt = $cnt + 1; # Update $cnt, backtracking-safe.
     echo();
   })
 )*
 aaaa
 (?{ $res = $cnt }) # On success copy to non-localized
 # location.
  >x;

  print "FINAL RESULT: cnt = $cnt res =$res\n";
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat embededcodescope.pl
  <span class="synStatement">use strict</span>;

  <span class="synStatement">our</span> (<span class="synIdentifier">$cnt</span>, <span class="synIdentifier">$res</span>);

<span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> echo </span>{
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$pre</span> = <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">0</span>,<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>));
    <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$post</span> = (<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>) &lt; <span class="synStatement">length</span>)? (<span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>,<span class="synConstant">1</span>+<span class="synStatement">pos</span>(<span class="synIdentifier">$_</span>))) : <span class="synConstant">''</span>;

    <span class="synStatement">print</span>(<span class="synConstant">&quot;</span><span class="synIdentifier">$pre</span><span class="synConstant">(count = </span><span class="synIdentifier">$cnt</span><span class="synConstant">)</span><span class="synIdentifier">$post</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>);
  }

  <span class="synIdentifier">$_</span> = <span class="synConstant">'a'</span> x <span class="synConstant">8</span>;
  m&lt;
    (?{ <span class="synIdentifier">$cnt</span> = <span class="synConstant">0</span> }) <span class="synComment"># Initialize $cnt.</span>
    (
      a
      (?{
        <span class="synStatement">local</span> <span class="synIdentifier">$cnt</span> = <span class="synIdentifier">$cnt</span> + <span class="synConstant">1</span>; <span class="synComment"># Update $cnt, backtracking-safe.</span>
        echo();
      })
    )*
    aaaa
    (?{ <span class="synIdentifier">$res</span> = <span class="synIdentifier">$cnt</span> }) <span class="synComment"># On success copy to non-localized</span>
    <span class="synComment"># location.</span>
  &gt;x;

  <span class="synStatement">print</span> <span class="synConstant">&quot;FINAL RESULT: cnt = </span><span class="synIdentifier">$cnt</span><span class="synConstant"> res =</span><span class="synIdentifier">$res</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
</pre>

\end{rawhtml}
%}}}

will set \verb|$res = 4| . Note that after the match, \verb|$cnt| returns to the
globally introduced value, because the scopes that restrict local
operators are unwound.
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.8.8 -w embededcodescope.pl
a(count = 1)aaaaaa
aa(count = 2)aaaaa
aaa(count = 3)aaaa
aaaa(count = 4)aaa
aaaaa(count = 5)aa
aaaaaa(count = 6)a
aaaaaaa(count = 7)
aaaaaaaa(count = 8)
FINAL RESULT: cnt = 0 res =4
\end{verbatim}
\end{quote}\end{it}

\parrafo{Caveats}

\begin{itemize}
\item
\begin{it}\begin{quote}
Due to an unfortunate implementation issue, the Perl code contained
in these blocks is treated as a compile time \wikip{closure}{/Closure\_(computer\_science)} that can have
seemingly bizarre consequences when used with \wikip{lexically scoped variables}{Static\_scoping\_.28also\_known\_as\_lexical\_scoping.29}
inside of subroutines or loops. There are various workarounds for this,
including simply using global variables instead. If you are using this
construct and strange results occur then check for the use of lexically
scoped variables.
\end{quote}\end{it}
\item
\begin{it}\begin{quote}
For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous \verb|use re 'eval'| pragma has been used (see \cpan{re}),
or the variables
contain results of \verb|qr//| operator (see \verb|"qr/STRING/imosx"| in 
\perldoc{perlop}).

This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns. For example:

\begin{verbatim}
   1. $re = <>;
   2. chomp $re;
   3. $string =~ /$re/;
\end{verbatim}

Before Perl knew how to execute interpolated code within a pattern, this
operation was completely safe from a security point of view, although
it could raise an exception from an illegal pattern. If you turn on the
\verb|use re 'eval'| , though, it is no longer secure, so you should only do
so if you are also using \wikip{taint}{Taint\_checking} checking. Better yet, use the carefully
constrained evaluation within a \cpan{Safe} compartment. See perlsec for details
about both these mechanisms. (Véase \pd{perlsec}{Taint-mode})
\end{quote}\end{it} 

\item
\begin{it}\begin{quote}
Because Perl's regex engine is currently \emph{not re-entrant}, interpolated
code may not invoke the regex engine either directly with \verb|m//| or 
\verb|s///|, or indirectly with functions such as \perldocf{split}.
\end{quote}\end{it}
\end{itemize}

\parrafo{Depurando con código empotrado Colisiones en los Nombres de las Subexpresiones Regulares}

Las acciones empotradas pueden utilizarse como mecanismo de 
depuración y de descubrimiento del comportamiento de nuestras expresiones 
regulares.

En el siguiente programa se produce una colisión
entre los nombres \verb|<i>| y \verb|<j>| de los patrones 
que ocurren en el patrón \verb|<expr>|
y en el patrón principal:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $" = ", ";
  7  
  8    my $parser = qr{
  9        ^ (?<i> (?&expr)) (?<j> (?&expr)) \z
 10          (?{
 11               say "main \$+ hash:";
 12               say " ($_ => $+{$_}) " for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?<expr>
 17                (?<i> . )
 18                (?<j> . )
 19                  (?{
 20                      say "expr \$+ hash:";
 21                      say " ($_ => $+{$_}) " for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = <>;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say "matches: ($&)";
 31    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n clashofnamedofssets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$&quot;</span> = <span class="synConstant">&quot;, &quot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say &quot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:&quot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say &quot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say &quot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">&quot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say &quot;</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say &quot;</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">&quot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>

\end{rawhtml}
%}}}
La colisión hace que la salida sea esta:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./clashofnamedofssets.pl
abab
expr $+ hash:
 (i => a)
 (j => b)
expr $+ hash:
 (i => ab)
 (j => b)
main $+ hash:
 (i => ab)
 (j => ab)
matches: (abab)
\end{verbatim}
Si se evitan las colisiones, 
se evita la pérdida de información:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    my $input;
  5  
  6    local $" = ", ";
  7  
  8    my $parser = qr{
  9        ^ (?<i> (?&expr)) (?<j> (?&expr)) \z
 10          (?{
 11               say "main \$+ hash:";
 12               say " ($_ => $+{$_}) " for sort keys %+;
 13           })
 14  
 15        (?(DEFINE)
 16            (?<expr>
 17                (?<i_e> . )
 18                (?<j_e> . )
 19                  (?{
 20                      say "expr \$+ hash:";
 21                      say " ($_ => $+{$_}) " for sort keys %+;
 22                  })
 23            )
 24        )
 25    }x;
 26  
 27    $input = <>;
 28    chomp($input);
 29    if ($input =~ $parser) {
 30      say "matches: ($&)";
 31    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n namedoffsets.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">local</span> <span class="synIdentifier">$&quot;</span> = <span class="synConstant">&quot;, &quot;</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$parser</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">    9</span> <span class="synConstant">      ^ </span><span class="synSpecial">(?</span><span class="synConstant">&lt;i&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&lt;j&gt; </span><span class="synSpecial">(?</span><span class="synConstant">&amp;expr</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\z</span>
<span class="synLinenum">   10</span> <span class="synConstant">        </span><span class="synSpecial">(?</span><span class="synConstant">{</span>
<span class="synLinenum">   11</span> <span class="synConstant">             say &quot;main </span><span class="synSpecial">\$+</span><span class="synConstant"> hash:&quot;;</span>
<span class="synLinenum">   12</span> <span class="synConstant">             say &quot; </span><span class="synSpecial">(</span><span class="synIdentifier">$_</span><span class="synConstant"> =&gt; </span><span class="synIdentifier">$+</span><span class="synConstant">{</span><span class="synIdentifier">$_</span><span class="synConstant">}</span>) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   13</span> <span class="synConstant">         })</span>
<span class="synLinenum">   14</span> 
<span class="synLinenum">   15</span> <span class="synConstant">      (?(DEFINE)</span>
<span class="synLinenum">   16</span> <span class="synConstant">          (?&lt;expr&gt;</span>
<span class="synLinenum">   17</span> <span class="synConstant">              (?&lt;i_e&gt; . )</span>
<span class="synLinenum">   18</span> <span class="synConstant">              (?&lt;j_e&gt; . )</span>
<span class="synLinenum">   19</span> <span class="synConstant">                (?{</span>
<span class="synLinenum">   20</span> <span class="synConstant">                    say &quot;</span>expr \<span class="synIdentifier">$+</span> hash:<span class="synConstant">&quot;;</span>
<span class="synLinenum">   21</span> <span class="synConstant">                    say &quot;</span> (<span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$+</span>{<span class="synIdentifier">$_</span>}) <span class="synConstant">&quot; for sort keys %+;</span>
<span class="synLinenum">   22</span> <span class="synConstant">                })</span>
<span class="synLinenum">   23</span> <span class="synConstant">          )</span>
<span class="synLinenum">   24</span> <span class="synConstant">      )</span>
<span class="synLinenum">   25</span> <span class="synConstant">  }x;</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">  </span><span class="synIdentifier">$input</span><span class="synConstant"> = &lt;&gt;;</span>
<span class="synLinenum">   28</span> <span class="synConstant">  chomp(</span><span class="synIdentifier">$input</span><span class="synConstant">);</span>
<span class="synLinenum">   29</span> <span class="synConstant">  if (</span><span class="synIdentifier">$input</span><span class="synConstant"> =~ </span><span class="synIdentifier">$parser</span><span class="synConstant">) {</span>
<span class="synLinenum">   30</span> <span class="synConstant">    say &quot;</span>matches: (<span class="synIdentifier">$&amp;</span>)<span class="synConstant">&quot;;</span>
<span class="synLinenum">   31</span> <span class="synConstant">  }</span>
</pre>

\end{rawhtml}
%}}}

que al ejecutarse produce:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./namedoffsets.pl
abab
expr $+ hash:
 (i_e => a)
 (j_e => b)
expr $+ hash:
 (i => ab)
 (i_e => a)
 (j_e => b)
main $+ hash:
 (i => ab)
 (j => ab)
matches: (abab)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expresiones Regulares en tiempo de matching}
\label{subsection:tiempodematching}

Los paréntesis especiales:
\begin{verbatim}
                (??{ Código Perl })
\end{verbatim}
hacen que el \verb|Código Perl| sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular. El match continuará 
intentando casar con la expresión regular retornada.

\parrafo{Paréntesis con memoria dentro de una {\it pattern code expression}}

Los paréntesis en la expresión regular retornada no cuentan
en el patrón exterior. Véase el siguiente 
ejemplo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ([ab])             # save 'a' or 'b' in \$1
   7                (??{ "($^N)"x3 })  # 3 more of the same as in \$1
   8              };
   9    say "<$&> lastpar = $#-" if 'bbbb' =~ $r;
  10    say "<$&> lastpar = $#-" if 'aaaa' =~ $r;
  11    say "<abab> didn't match" unless 'abab' =~ $r;
  12    say "<aaab> didn't match" unless 'aaab' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n postponedregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              </span><span class="synSpecial">([ab])</span><span class="synConstant">             # save 'a' or 'b' in </span><span class="synSpecial">\$</span><span class="synConstant">1</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(??</span><span class="synConstant">{ &quot;</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant">&quot;x3 }</span>)  <span class="synComment"># 3 more of the same as in \$1</span>
<span class="synLinenum">    8</span>             };
<span class="synLinenum">    9</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'bbbb'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   10</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt; lastpar = </span><span class="synIdentifier">$#</span><span class="synConstant">-&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'aaaa'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   11</span>   say <span class="synConstant">&quot;&lt;abab&gt; didn't match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abab'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   12</span>   say <span class="synConstant">&quot;&lt;aaab&gt; didn't match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'aaab'</span> =~ <span class="synIdentifier">$r</span>;
</pre>

\end{rawhtml}%%}}}

Como se ve, hemos accedido desde el código interior 
al último paréntesis usando \verb|$^N|.
Sigue una ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./postponedregexp.pl
<bbbb> lastpar = 1
<aaaa> lastpar = 1
<abab> didn't match
<aaab> didn't match
\end{verbatim}

\parrafo{Ejemplo: Secuencias de dígitos de longitud especificada por el primer dígito}

Consideremos el problema de escribir una expresión regular
que reconoce secuencias no vacías de dígitos tales que la longitud 
de la secuencia restante viene
determinada por el primer dígito.
Esta es una solución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n intints.pl
   1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2  use v5.10;
   3  use strict;
   4  
   5  my $r = qr{(?x)                # ignore spaces
   6             (\d)                # a digit
   7             ( (??{
   8                 "\\d{$^N}"      # as many as the former
   9               })                # digit says
  10             )
  11            };
  12  say "<$&> <$1> <$2>" if '3428' =~ $r;
  13  say "<$&> <$1> <$2>" if '228' =~ $r;
  14  say "<$&> <$1> <$2>" if '14' =~ $r;
  15  say "24 does not match" unless '24' =~ $r;
  16  say "4324 does not match" unless '4324' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n intints.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">           </span><span class="synSpecial">(\d)</span><span class="synConstant">                # a digit</span>
<span class="synLinenum">    7</span> <span class="synConstant">           </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">(??</span><span class="synConstant">{</span>
<span class="synLinenum">    8</span> <span class="synConstant">               &quot;</span><span class="synSpecial">\\</span><span class="synConstant">d{</span><span class="synIdentifier">$^</span><span class="synConstant">N}&quot;      # as many as the former</span>
<span class="synLinenum">    9</span> <span class="synConstant">             })                # digit says</span>
<span class="synLinenum">   10</span> <span class="synConstant">           )</span>
<span class="synLinenum">   11</span> <span class="synConstant">          };</span>
<span class="synLinenum">   12</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '3428' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   13</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '228' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   14</span> <span class="synConstant">say &quot;</span>&lt;<span class="synIdentifier">$&amp;</span>&gt; &lt;<span class="synIdentifier">$1</span>&gt; &lt;<span class="synIdentifier">$2</span>&gt;<span class="synConstant">&quot; if '14' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   15</span> <span class="synConstant">say &quot;24</span> does <span class="synStatement">not</span> match<span class="synConstant">&quot; unless '24' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
<span class="synLinenum">   16</span> <span class="synConstant">say &quot;4324</span> does <span class="synStatement">not</span> match<span class="synConstant">&quot; unless '4324' =~ </span><span class="synIdentifier">$r</span><span class="synConstant">;</span>
</pre>

\end{rawhtml}%%}}}

Cuando se ejecuta se obtiene:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./intints.pl
<3428> <3> <428>
<228> <2> <28>
<14> <1> <4>
24 does not match
4324 does not match
\end{verbatim}

\parrafo{Ejemplo: Secuencias de dígitos no repetidos}

Otro ejemplo: queremos escribir una expresión regular que reconozca secuencias
de  \verb|$n| dígitos en las que no todos los dígitos se repiten. Donde quizá \verb|$n| es capturado
de un paréntesis anterior en la expresión regular. Para simplificar la ilustración
de la técnica supongamos que \verb|$n = 7|:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x join '', map { "(?!".$_."{7})" } 0..9
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB<2> x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
  empty array
  DB<3> x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
0  7777778
  DB<4> x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
  empty array
  DB<5> x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/
0  4422444
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~$  <span class="dbuser">perl5.10.1 -wdE 0</span>
main::(-e:1):   0
  DB&lt;1&gt;  <span class="dbuser">x join '', map { "(?!".$_."{7})" } 0..9</span>
0  '(?!0{7})(?!1{7})(?!2{7})(?!3{7})(?!4{7})(?!5{7})(?!6{7})(?!7{7})(?!8{7})(?!9{7})'
  DB&lt;2&gt;  <span class="dbuser">x '7777777' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;3&gt;  <span class="dbuser">x '7777778' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  7777778
  DB&lt;4&gt;  <span class="dbuser">x '4444444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
  empty array
  DB&lt;5&gt;  <span class="dbuser">x '4422444' =~ /(??{join '', map { "(?!".$_."{7})" } 0..9})(\d{7})/</span>
0  4422444
</pre>
\end{rawhtml}
%}}}

\parrafo{Palíndromos con independencia del acento}
\label{parrafo:palindromospostregexp}

Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
\ref{parrafo:palabrapalindromos}
para reconocer los palabra-palíndromos. 

Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo {\it dábale arroz a la zorra 
el abad}). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion:
 

\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat actionspanishpalin.pl 
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  use re 'eval';
  7  use Switch;
  8  
  9  sub f {
 10    my $char = shift;
 11  
 12    switch($char) {
 13      case [ qw{a á} ] { return '[aá]' }
 14      case [ qw{e é} ] { return '[eé]' }
 15      case [ qw{i í} ] { return '[ií]' }
 16      case [ qw{o ó} ] { return '[oó]' }
 17      case [ qw{u ú} ] { return '[uú]' }
 18      else             { return $char  };
 19    }
 20  }
 21  
 22  my $regexp = qr/^(\W* (?: 
 23                              (\w) (?-2)(??{ f($^N) })
 24                            | \w? 
 25                        ) \W*
 26                    )
 27                  $
 28                 /ix;
 29  
 30  my $input = <>; # Try: 'dábale arroz a la zorra el abad';
 31  chomp($input);
 32  if ($input =~ $regexp) {
 33    say "$input is a palindrome";
 34  }
 35  else {
 36    say "$input does not match";
 37  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat actionspanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl </span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>;
<span class="synLinenum">    7</span> <span class="synStatement">use </span>Switch;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synStatement">sub</span><span class="synIdentifier"> f </span>{
<span class="synLinenum">   10</span>   <span class="synStatement">my</span> <span class="synIdentifier">$char</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synStatement">switch</span>(<span class="synIdentifier">$char</span>) {
<span class="synLinenum">   13</span>     case [ <span class="synConstant">qw{a á}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[aá]'</span> }
<span class="synLinenum">   14</span>     case [ <span class="synConstant">qw{e é}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[eé]'</span> }
<span class="synLinenum">   15</span>     case [ <span class="synConstant">qw{i í}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[ií]'</span> }
<span class="synLinenum">   16</span>     case [ <span class="synConstant">qw{o ó}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[oó]'</span> }
<span class="synLinenum">   17</span>     case [ <span class="synConstant">qw{u ú}</span> ] { <span class="synStatement">return</span> <span class="synConstant">'[uú]'</span> }
<span class="synLinenum">   18</span>     <span class="synStatement">else</span>             { <span class="synStatement">return</span> <span class="synIdentifier">$char</span>  };
<span class="synLinenum">   19</span>   }
<span class="synLinenum">   20</span> }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">   23</span> <span class="synConstant">                            </span><span class="synSpecial">(\w)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">-2</span><span class="synSpecial">)(??</span><span class="synConstant">{ f</span><span class="synSpecial">(</span><span class="synIdentifier">$^</span><span class="synConstant">N</span><span class="synSpecial">)</span><span class="synConstant"> }</span><span class="synSpecial">)</span>
<span class="synLinenum">   24</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant"> </span>
<span class="synLinenum">   25</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span>
<span class="synLinenum">   26</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">                $</span>
<span class="synLinenum">   28</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   31</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   32</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   33</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
<span class="synLinenum">   34</span> }
<span class="synLinenum">   35</span> <span class="synStatement">else</span> {
<span class="synLinenum">   36</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match&quot;</span>;
<span class="synLinenum">   37</span> }
</pre>

\end{rawhtml}
%}}}

Sigue un ejemplo de ejecución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
éoíúaáuioé
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ ./actionspanishpalin.pl 
dáed
dáed does not match
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$<span class="dbuser"> ./actionspanishpalin.pl </span>
<span class="dbuser">éoíúaáuioé</span>
éoíúaáuioé is a palindrome
pl@nereida:~/Lperltesting$ <span class="dbuser">./actionspanishpalin.pl </span>
<span class="dbuser">dáed</span>
dáed does not match
</pre>
\end{rawhtml}
%}}}


\parrafo{Postponiendo para conseguir recursividad}

Véase el nodo \pmm{585167}{Complex regex for maths formulas}
para la formulación del problema:

\begin{it}\begin{quotation} 
Hiya monks,

Im having trouble getting my head around a regular expression to match sequences.
I need to catch all exceptions where a mathematical expression is illegal...

There must be either a letter or a digit either side of an operator
parenthesis must open and close next to letters or digits, not next to operators, and do not have to exist
variables must not be more than one letter
Nothing other than \verb|a-z,A-Z,0-9,+,-,*,/,(,)| can be used

Can anyone offer a hand on how best to tackle this problem?

many thanks 
\end{quotation}\end{it} 

La respuesta dada por \pmm{381608}{ikegami} usa \verb|(?{{ ... })|
para conseguir una conducta recursiva en versiones de perl anteriores a la 5.10:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
  1    #!/usr/bin/perl
  2    use strict;
  3    use warnings;
  4  
  5    sub is_valid_expr {
  6       use re 'eval'; # to allow Eval-group at runtime
  7  
  8       local our ($skip, $term, $expr);
  9       $skip = qr! \s* !x;
 10       $term = qr! $skip [a-zA-Z]+              # A term is an identifier
 11                 | $skip [1-9][0-9]*            # or a number
 12                 | $skip \( (??{ $expr }) $skip # or an expression
 13                         \)
 14                 !x;
 15       $expr = qr! $term                         # A expr is a term
 16                   (?: $skip [-+*/] $term )*     # or a term + a term ...
 17                 !x;
 18  
 19       return $_[0] =~ / ^ $expr $skip \z /x;
 20    }
 21  
 22    print(is_valid_expr($_) ? "$_ is valid\n" : "$_ is not valid\n") foreach (
 23     '(a + 3)',
 24     '(3 * 4)+(b + x)',
 25     '(5 - a)*z',
 26     '3 + 2',
 27  
 28     '!3 + 2',
 29     '3 + 2!',
 30  
 31     '3 a',
 32     '3 3',
 33     '3 * * 3',
 34  
 35     '2 - 3 * 4',
 36     '2 - 3 + 4',
 37    );
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n complexformula.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> is_valid_expr </span>{
<span class="synLinenum">    6</span>      <span class="synStatement">use </span>re <span class="synConstant">'eval'</span>; <span class="synComment"># to allow Eval-group at runtime</span>
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>      <span class="synStatement">local</span> <span class="synStatement">our</span> (<span class="synIdentifier">$skip</span>, <span class="synIdentifier">$term</span>, <span class="synIdentifier">$expr</span>);
<span class="synLinenum">    9</span>      <span class="synIdentifier">$skip</span> = qr! \s* !x;
<span class="synLinenum">   10</span>      <span class="synIdentifier">$term</span> = qr! <span class="synIdentifier">$skip</span> [a-zA-Z]+              <span class="synComment"># A term is an identifier</span>
<span class="synLinenum">   11</span>                | <span class="synIdentifier">$skip</span> [<span class="synConstant">1-9</span>][<span class="synConstant">0-9</span>]*            <span class="synComment"># or a number</span>
<span class="synLinenum">   12</span>                | <span class="synIdentifier">$skip</span> \( (??{ <span class="synIdentifier">$expr</span> }) <span class="synIdentifier">$skip</span> <span class="synComment"># or an expression</span>
<span class="synLinenum">   13</span>                        \)
<span class="synLinenum">   14</span>                !x;
<span class="synLinenum">   15</span>      <span class="synIdentifier">$expr</span> = qr! <span class="synIdentifier">$term</span>                         <span class="synComment"># A expr is a term</span>
<span class="synLinenum">   16</span>                  (?: <span class="synIdentifier">$skip</span> [-+*/] <span class="synIdentifier">$term</span> )*     <span class="synComment"># or a term + a term ...</span>
<span class="synLinenum">   17</span>                !x;
<span class="synLinenum">   18</span> 
<span class="synLinenum">   19</span>      <span class="synStatement">return</span> <span class="synIdentifier">$_</span>[<span class="synConstant">0</span>] =~<span class="synStatement"> /</span><span class="synConstant"> ^ </span><span class="synIdentifier">$expr</span><span class="synConstant"> </span><span class="synIdentifier">$skip</span><span class="synConstant"> </span><span class="synSpecial">\z</span><span class="synConstant"> </span><span class="synStatement">/x</span>;
<span class="synLinenum">   20</span>   }
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">print</span>(is_valid_expr(<span class="synIdentifier">$_</span>) ? <span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span> : <span class="synConstant">&quot;</span><span class="synIdentifier">$_</span><span class="synConstant"> is not valid</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>) <span class="synStatement">foreach</span> (
<span class="synLinenum">   23</span>    <span class="synConstant">'(a + 3)'</span>,
<span class="synLinenum">   24</span>    <span class="synConstant">'(3 * 4)+(b + x)'</span>,
<span class="synLinenum">   25</span>    <span class="synConstant">'(5 - a)*z'</span>,
<span class="synLinenum">   26</span>    <span class="synConstant">'3 + 2'</span>,
<span class="synLinenum">   27</span> 
<span class="synLinenum">   28</span>    <span class="synConstant">'!3 + 2'</span>,
<span class="synLinenum">   29</span>    <span class="synConstant">'3 + 2!'</span>,
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>    <span class="synConstant">'3 a'</span>,
<span class="synLinenum">   32</span>    <span class="synConstant">'3 3'</span>,
<span class="synLinenum">   33</span>    <span class="synConstant">'3 * * 3'</span>,
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span>    <span class="synConstant">'2 - 3 * 4'</span>,
<span class="synLinenum">   36</span>    <span class="synConstant">'2 - 3 + 4'</span>,
<span class="synLinenum">   37</span>   );
</pre>

\end{rawhtml}
%}}}

Sigue el resultado de la ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl complexformula.pl
(a + 3) is valid
(3 * 4)+(b + x) is valid
(5 - a)*z is valid
3 + 2 is valid
!3 + 2 is not valid
3 + 2! is not valid
3 a is not valid
3 3 is not valid
3 * * 3 is not valid
2 - 3 * 4 is valid
2 - 3 + 4 is valid
\end{verbatim}

\parrafo{Caveats}

Estos son algunos puntos a tener en cuenta cuando se usan patrones postpuestos.
Véase la entrada \verb|(??{ code })| en \pd{perlre}{Extended-Patterns}:

\begin{it}\begin{quote}
WARNING: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that has
side effects may not perform identically from version to version due to
the effect of future optimisations in the regex engine.

This is a \cei{postponed regular subexpression}. The code is evaluated at
run time, at the moment this subexpression may match. The result of
evaluation is considered as a regular expression and matched as if it
were inserted instead of this construct. 

The code {\it is not interpolated}. 

As before, the rules to determine where the code ends are currently somewhat convoluted.

Because perl's regex engine is not currently \wikip{re-entrant}{Reentrant_(subroutine)}, delayed code
may not invoke the regex engine either directly with \verb|m//| or \verb|s///|),
or indirectly with functions such as \perldocf{split}.

{\it Recursing} deeper than 50 times without consuming any input string will
result in a fatal error. The maximum depth is compiled into perl, so
changing it requires a custom build.
\end{quote}\end{it}

\subsection{Expresiones Condicionales}
\label{subsection:regexpcondicionales}

Citando a \perldoc{perlre}:

\begin{it}
\begin{quotation}
A conditional expression is a form of if-then-else
statement that allows one to choose which patterns are
to be matched, based on some condition. 

There are two
types of conditional expression: \verb#(?(condition)yes-regexp)# and
\verb#(?(condition)yes-regexp|no-regexp)#. 

\verb#(?(condition)yes-regexp)# is like an
\verb'if () {}' statement in Perl. 
If the condition is true, the yes-regexp
will be matched. If the condition is false, the yes-regexp will be
skipped and Perl will move onto the next regexp element. 

The second form
is like an \verb'if () {} else {}' statement in Perl. If the condition is true,
the yes-regexp will be matched, otherwise the no-regexp will be matched.

The condition can have several forms. 
\begin{itemize}
\item The first form is simply an
integer in parentheses (integer). It is true if the corresponding
backreference \verb|\integer| matched earlier in the regexp. The same thing
can be done with a name associated with a capture buffer, written as
\verb|(<name>)| or \verb#('name')#. 
\item
The second form is a bare zero width assertion
\verb|(?...)|, either a lookahead, a lookbehind, or a code assertion. 

\item
The third set of forms provides tests that return
true if the expression is executed within a recursion \verb|(R)| or is being
called from some capturing group, referenced either by number \verb|(R1|,
or by name \verb#(R&name)#.
\end{itemize}
\end{quotation}
\end{it}

\parrafo{Condiciones: número de paréntesis}

Una expresión condicional puede adoptar diversas formas.
La mas simple es un entero en paréntesis. 
Es cierta si la correspondiente referencia 
\verb|\integer| casó (también se puede usar un nombre
si se trata de un paréntesis con nombre). 

En la expresión regular \verb#/^(.)(..)?(?(2)a|b)/# si el segundo paréntesis
casa, la cadena debe ir seguida de una \verb|a|, si no casa deberá ir seguida de 
una \verb|b|: 

\begin{verbatim}
  DB<1> x 'hola' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  'ol'
  DB<2> x 'ha' =~ /^(.)(..)?(?(2)a|b)/
  empty array
  DB<3> x 'hb' =~ /^(.)(..)?(?(2)a|b)/
0  'h'
1  undef
\end{verbatim}

\parrafo{Ejemplo: cadenas de la forma {\it una}-otra-otra-{\it una}}

La siguiente búsqueda casa con patrones de la forma 
\verb"$x$x" o \verb"$x$y$y$x":

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wde 0
main::(-e:1):   0
  DB<1> x 'aa' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  undef
  DB<2> x 'abba' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'a'
1  'b'
  DB<3> x 'abbc' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
  empty array
  DB<4> x 'juanpedropedrojuan' =~ m{^(\w+)(\w+)?(?(2)\2\1|\1)$}
0  'juan'
1  'pedro'
\end{verbatim}

%The lookbehind condition allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,
%
%    /[ATGC]+(?(?<=AA)G|C)$/;
%
%matches a DNA sequence such that it either ends in AAG, or some other base pair combination and C. Note that the form is (?(?<=AA)G|C) and not (?((?<=AA))G|C); for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.
%
\parrafo{Condiciones: Código}

Una expresión condicional también puede ser un código:
\begin{verbatim}
  DB<1> $a = 0; print "$&" if 'hola' =~ m{(?(?{$a})hola|adios)} # No hay matching

  DB<2> $a = 1; print "$&" if 'hola' =~ m{(?(?{$a})hola|adios)}
hola
\end{verbatim}

\parrafo{Ejemplo: Cadenas con posible paréntesis inicial (no anidados)}

La siguiente expresión regular utiliza un condicional
para forzar a que si una cadena comienza por un paréntesis
abrir termina con un paréntesis cerrar. Si la cadena 
no comienza por paréntesis abrir no debe existir un paréntesis
final de cierre:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
   1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
   2    use v5.10;
   3    use strict;
   4  
   5    my $r = qr{(?x)                # ignore spaces
   6                ^
   7                ( \( )?            # may be it comes an open par
   8                [^()]+             # no parenthesis
   9                (?(1)              # did we sart with par?
  10                  \)               # if yes then close par
  11                )
  12                $
  13              };
  14    say "<$&>" if '(abcd)' =~ $r;
  15    say "<$&>" if 'abc' =~ $r;
  16    say "<(abc> does not match" unless '(abc' =~ $r;
  17    say "<abc)> does not match" unless 'abc)' =~ $r;
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n conditionalregexp.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span>   <span class="synStatement">my</span> <span class="synIdentifier">$r</span> = <span class="synConstant">qr{</span><span class="synSpecial">(?x)</span><span class="synConstant">                # ignore spaces</span>
<span class="synLinenum">    6</span> <span class="synConstant">              ^</span>
<span class="synLinenum">    7</span> <span class="synConstant">              </span><span class="synSpecial">(</span><span class="synConstant"> </span><span class="synSpecial">\(</span><span class="synConstant"> </span><span class="synSpecial">)?</span><span class="synConstant">            # may be it comes an open par</span>
<span class="synLinenum">    8</span> <span class="synConstant">              </span><span class="synSpecial">[^()]+</span><span class="synConstant">             # no parenthesis</span>
<span class="synLinenum">    9</span> <span class="synConstant">              </span><span class="synSpecial">(?(</span><span class="synConstant">1</span><span class="synSpecial">)</span><span class="synConstant">              # did we sart with par</span><span class="synSpecial">?</span>
<span class="synLinenum">   10</span> <span class="synConstant">                </span><span class="synSpecial">\)</span><span class="synConstant">               # if yes then close par</span>
<span class="synLinenum">   11</span> <span class="synConstant">              </span><span class="synSpecial">)</span>
<span class="synLinenum">   12</span> <span class="synConstant">              $</span>
<span class="synLinenum">   13</span> <span class="synConstant">            }</span>;
<span class="synLinenum">   14</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'(abcd)'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   15</span>   say <span class="synConstant">&quot;&lt;</span><span class="synIdentifier">$&amp;</span><span class="synConstant">&gt;&quot;</span> <span class="synStatement">if</span> <span class="synConstant">'abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   16</span>   say <span class="synConstant">&quot;&lt;(abc&gt; does not match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'(abc'</span> =~ <span class="synIdentifier">$r</span>;
<span class="synLinenum">   17</span>   say <span class="synConstant">&quot;&lt;abc)&gt; does not match&quot;</span> <span class="synStatement">unless</span> <span class="synConstant">'abc)'</span> =~ <span class="synIdentifier">$r</span>;
</pre>

\end{rawhtml}%%}}}

Al ejecutar este programa se obtiene:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./conditionalregexp.pl
<(abcd)>
<abc>
<(abc> does not match
<abc)> does not match
\end{verbatim}

\parrafo{Expresiones Condicionales con {\tt (R)}}

El siguiente ejemplo muestra el uso de la condición \verb|(R)|, la cual comprueba 
si la expresión ha sido evaluada dentro de una recursión:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> x 'bbaaaabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbaaaabb'
  DB<2> x 'bb' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB<3> x 'bab' =~ /(b(?(R)a+|(?0))b)/
  empty array
  DB<4> x 'bbabb' =~ /(b(?(R)a+|(?0))b)/
0  'bbabb'
\end{verbatim}
La sub-expresión regular \verb#(?(R)a+|(?0))# dice:
si  esta siendo evaluada recursivamente admite \verb|a+|
si no, evalúa la regexp completa recursivamente.

\parrafo{Ejemplo: Palíndromos con Equivalencia de Acentos Españoles}

Se trata en este ejercicio de generalizar la expresión
regular introducida en la sección
\ref{parrafo:palabrapalindromos}
para reconocer los palabra-palíndromos\footnote{
No sé si existe el término. Significa que 
la lectura directa y la inversa 
pueden diferir en los signos de puntuación
}. Se trata de encontrar una regexp que acepte
que la lectura derecha e inversa de una frase en Español
pueda diferir en la acentuación (como es el caso
del clásico palíndromo {\it dábale arroz a la zorra 
el abad}). Una solución trivial es preprocesar 
la cadena eliminando los acentos. Supondremos sin embargo
que se quiere trabajar sobre la cadena original.
He aquí una solucion parcial (por
consideraciones de legibilidad sólo se consideran las vocales \verb|a|
y \verb|o|:


\begin{latexonly}
\begin{verbatim}
  1  pl@nereida:~/Lperltesting$ cat spanishpalin.pl
  2  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w -CIOEioA
  3  use v5.10;
  4  use strict;
  5  use utf8;
  6  
  7  my $regexp = qr/^(?<pal>\W* (?: 
  8                              (?<L>(?<a>[áa])|(?<e>[ée])|\w) # letter
  9                              (?&pal)                        # nested palindrome
 10                              (?(<a>)[áa]                    # if is an "a" group
 11                                    |(?:((?<e>)[ée]          # if is an "e" group
 12                                              |\g{L}         # exact match
 13                                        )                    # end if [ée]
 14                                     )                       # end group
 15                              )                              # end if [áa]
 16                            | \w?                            # non rec. case
 17                        ) \W*                                # punctuation symbols
 18                    )
 19                  $
 20                 /ix;
 21  
 22  my $input = <>; # Try: 'dábale arroz a la zorra el abad';
 23  chomp($input);
 24  if ($input =~ $regexp) {
 25    say "$input is a palindrome";
 26  }
 27  else {
 28    say "$input does not match";
 29  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> pl<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperltesting$ cat spanishpalin</span><span class="synSpecial">.</span><span class="synConstant">pl</span>
<span class="synLinenum">    2</span> <span class="synConstant">#!</span><span class="synStatement">/</span>usr/<span class="synStatement">local</span>/lib/perl/<span class="synConstant">5.10</span>.<span class="synConstant">1</span>/bin//perl5.<span class="synConstant">10.1</span> <span class="synStatement">-w</span> -CIOEioA
<span class="synLinenum">    3</span> <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    4</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    5</span> <span class="synStatement">use utf8</span>;
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr/^</span><span class="synSpecial">(?</span><span class="synConstant">&lt;pal&gt;</span><span class="synSpecial">\W*</span><span class="synConstant"> </span><span class="synSpecial">(?:</span><span class="synConstant"> </span>
<span class="synLinenum">    8</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&lt;L&gt;</span><span class="synSpecial">(?</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">[áa])</span><span class="synConstant">|</span><span class="synSpecial">(?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">[ée])</span><span class="synConstant">|</span><span class="synSpecial">\w)</span><span class="synConstant"> # letter</span>
<span class="synLinenum">    9</span> <span class="synConstant">                            </span><span class="synSpecial">(?</span><span class="synConstant">&amp;pal</span><span class="synSpecial">)</span><span class="synConstant">                        # nested palindrome</span>
<span class="synLinenum">   10</span> <span class="synConstant">                            </span><span class="synSpecial">(?(</span><span class="synConstant">&lt;a&gt;</span><span class="synSpecial">)[áa]</span><span class="synConstant">                    # if is an &quot;a&quot; group</span>
<span class="synLinenum">   11</span> <span class="synConstant">                                  |</span><span class="synSpecial">(?:((?</span><span class="synConstant">&lt;e&gt;</span><span class="synSpecial">)[ée]</span><span class="synConstant">          # if is an &quot;e&quot; group</span>
<span class="synLinenum">   12</span> <span class="synConstant">                                            |</span><span class="synSpecial">\g</span><span class="synConstant">{L}         # exact match</span>
<span class="synLinenum">   13</span> <span class="synConstant">                                      </span><span class="synSpecial">)</span><span class="synConstant">                    # end if </span><span class="synSpecial">[ée]</span>
<span class="synLinenum">   14</span> <span class="synConstant">                                   </span><span class="synSpecial">)</span><span class="synConstant">                       # end group</span>
<span class="synLinenum">   15</span> <span class="synConstant">                            </span><span class="synSpecial">)</span><span class="synConstant">                              # end if </span><span class="synSpecial">[áa]</span>
<span class="synLinenum">   16</span> <span class="synConstant">                          | </span><span class="synSpecial">\w?</span><span class="synConstant">                            # non rec</span><span class="synSpecial">.</span><span class="synConstant"> case</span>
<span class="synLinenum">   17</span> <span class="synConstant">                      </span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">\W*</span><span class="synConstant">                                # punctuation symbols</span>
<span class="synLinenum">   18</span> <span class="synConstant">                  </span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> <span class="synConstant">                $</span>
<span class="synLinenum">   20</span> <span class="synConstant">               /ix</span>;
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;; <span class="synComment"># Try: 'dábale arroz a la zorra el abad';</span>
<span class="synLinenum">   23</span> <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   24</span> <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   25</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> is a palindrome&quot;</span>;
<span class="synLinenum">   26</span> }
<span class="synLinenum">   27</span> <span class="synStatement">else</span> {
<span class="synLinenum">   28</span>   say <span class="synConstant">&quot;</span><span class="synIdentifier">$input</span><span class="synConstant"> does not match&quot;</span>;
<span class="synLinenum">   29</span> }
</pre>

\end{rawhtml}
%}}}


Ejecución:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
dábale arroz a la zorra el abad
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
óuuo
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
éaáe
éaáe is a palindrome
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">dábale arroz a la zorra el abad</span>
dábale arroz a la zorra el abad is a palindrome
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">óuuo</span>
óuuo does not match
pl@nereida:~/Lperltesting$ ./spanishpalin.pl
<span class="dbuser">éaáe</span>
éaáe is a palindrome
</pre>
\end{rawhtml}
%}}}


Hemos usado la opción \verb|-CIOEioA| para asegurarnos
que los ficheros de entrada/saldia y error y la línea de
comandos estan en modo UTF-8.
(Véase la sección \ref{section:unicode})

Esto es lo que dice la documentación de \perldoc{perlrun }
al respecto:

\begin{it}
\begin{quotation}
The \verb|-C| flag controls some of the Perl Unicode features.

As of 5.8.1, the \verb|-C| can be followed either by a number or a list of option
letters. The letters, their numeric values, and effects are as follows;
listing the letters is equal to summing the numbers.

\begin{verbatim}
  1   I 1 STDIN is assumed to be in UTF-8
  2   O 2 STDOUT will be in UTF-8
  3   E 4 STDERR will be in UTF-8
  4   S 7 I + O + E
  5   i 8 UTF-8 is the default PerlIO layer for input streams
  6   o 16 UTF-8 is the default PerlIO layer for output streams
  7   D 24 i + o
  8   A 32 the @ARGV elements are expected to be strings encoded
  9   in UTF-8
 10   L 64 normally the "IOEioA" are unconditional,
 11   the L makes them conditional on the locale environment
 12   variables (the LC_ALL, LC_TYPE, and LANG, in the order
 13   of decreasing precedence) -- if the variables indicate
 14   UTF-8, then the selected "IOEioA" are in effect
 15   a 256 Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
 16   debugging mode.
 \end{verbatim}

For example, \verb|-COE| and \verb|-C6| will both turn on UTF-8-ness
on both \verb|STDOUT| and \verb|STDERR|. Repeating letters is just redundant, not
cumulative nor toggling.

The io options mean that any subsequent \verb|open()| (or similar I/O operations)
will have the \verb|:utf8| PerlIO layer implicitly applied to them, in other
words, \verb|UTF-8| is expected from any input stream, and \verb|UTF-8| is produced
to any output stream. This is just the default, with explicit layers in
\verb|open()| and with \verb|binmode()| one can manipulate streams as usual.

\verb|-C| on its own (not followed by any number or option list), or the empty string 
\verb|""| for the \verb|PERL_UNICODE| environment variable, has the same effect as \verb|-CSDL| . 
In other words, the standard I/O handles and the default\verb|open()| layer are 
UTF-8-fied but only if the locale environment variables indicate a
UTF-8 locale. This behaviour follows the implicit (and problematic)
UTF-8 behaviour of Perl 5.8.0.

You can use \verb|-C0| (or \verb"0" for \verb|PERL_UNICODE| ) to explicitly disable all
the above Unicode features.
\end{quotation}
\end{it}

El pragma \verb|use utf8| hace que se utilice una semántica de
carácteres (por ejemplo, la regexp \verb|/./| casará con un carácter unicode), el
pragma \verb|use bytes| cambia de semántica de caracteres
a semántica de bytes (la regexp \verb/./ casará con un byte).

%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
lhp<span class="synIdentifier">@nereida</span>:~<span class="synStatement">/</span><span class="synConstant">Lperl</span><span class="synStatement">/s</span>rc/testing$ cat -n dot_utf8_2.pl
     <span class="synConstant">1</span>  <span class="synComment">#!/usr/local/bin/perl -w</span>
     <span class="synConstant">2</span>  <span class="synStatement">use strict</span>;
     <span class="synConstant">3</span>  <span class="synStatement">use utf8</span>;
     <span class="synConstant">4</span>  <span class="synStatement">use </span>charnames <span class="synConstant">qw{greek}</span>;
     <span class="synConstant">5</span>
     <span class="synConstant">6</span>  <span class="synStatement">binmode</span>(<span class="synIdentifier">STDOUT</span>, <span class="synConstant">':utf8'</span>);
     <span class="synConstant">7</span>
     <span class="synConstant">8</span>  <span class="synStatement">my</span> <span class="synIdentifier">$x</span> = <span class="synConstant">'αβγδεφ'</span>;
     <span class="synConstant">9</span>
    <span class="synConstant">10</span>  <span class="synStatement">my</span> <span class="synIdentifier">@w</span> = <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">11</span>  <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">@w</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
    <span class="synConstant">12</span>
    <span class="synConstant">13</span>  {
    <span class="synConstant">14</span>    <span class="synStatement">use </span>bytes;
    <span class="synConstant">15</span>    <span class="synStatement">my</span> <span class="synIdentifier">@v</span> = <span class="synStatement">map</span> { <span class="synStatement">ord</span> } <span class="synIdentifier">$x</span> =~<span class="synStatement"> /</span><span class="synSpecial">(.)</span><span class="synStatement">/g</span>;
    <span class="synConstant">16</span>    <span class="synStatement">print</span> <span class="synConstant">&quot;</span><span class="synIdentifier">@v</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
    <span class="synConstant">17</span>  }
</pre>

Al ejcutar el programa obtenemos la salida:
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">perl dot_utf8_2.pl</span>
α β γ δ ε φ
206 177 206 178 206 179 206 180 206 181 207 134

</pre>
\end{rawhtml}
%}}}


\subsection{Verbos que controlan el retroceso}

\parrafo{El verbo de control {\tt (*FAIL)}}

Tomado de \pd{perlretut}{Backtracking-control-verbs}:

\begin{it}
\begin{quotation}
The control verb \verb|(*FAIL)| may be abbreviated as \verb|(*F)|. 
If this is inserted in a regexp it
will cause to fail, just like at some mismatch between the pattern and
the string. Processing of the regexp continues like after any "normal"
failure, so that the next position in the string or
another alternative will be tried. As failing to match doesn't preserve
capture buffers or produce results, it may be necessary to use this in
combination with embedded code.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n vowelcount.pl
     1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
     2  use strict;
     3
     4  my $input = shift() || <STDIN>;
     5  my %count = ();
     6  $input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
     7  printf("'%s' => %3d\n", $_, $count{$_})  for (sort keys %count);
\end{verbatim}
Al ejecutarse con entrada \verb|supercalifragilistico| produce la salida:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./vowelcount.pl
supercalifragilistico
'a' =>   2
'e' =>   1
'i' =>   4
'o' =>   1
'u' =>   1
\end{verbatim}

\begin{exercise}
¿Que queda en \verb|$1| depués de ejecutado el matching 
\verb|$input =~ /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;|?
\end{exercise}


Véase  también:
\begin{itemize}
\item
El nodo en \perlmonk{796576} \emph{The Oldest Plays the Piano}
\item Véase el ejercicio {\it Las tres hijas} en la sección
\ref{parrfo:lastreshijas}
\end{itemize}

\parrafo{El verbo de control {\tt (*ACCEPT)}}

Tomado de \perldoc{perlretut}:

\begin{it}
\begin{quotation}
This pattern matches nothing and causes the end of successful matching
at the point at which the \verb#(*ACCEPT)# pattern was encountered, regardless
of whether there is actually more to match in the string. When inside
of a nested pattern, such as recursion, or in a subpattern dynamically
generated via \verb#(??{})#, only the innermost pattern is ended immediately.

If the \verb#(*ACCEPT)# is inside of capturing buffers then the buffers are
marked as ended at the point at which the \verb#(*ACCEPT)# was encountered. For
instance:

\begin{verbatim}
  DB<1> x 'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'AB'
1  'B'
2  undef
  DB<2> x 'ACDE'  =~ /(A (A|B(*ACCEPT)|C) D)(E)/x
0  'ACD'
1  'C'
2  'E'
\end{verbatim}

\end{quotation}
\end{it}

\parrafo{El verbo {\tt SKIP}}

\begin{it}
\begin{quotation}
This zero-width pattern 
prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern \verb|A (*SKIP) B|,
where \verb|A| and \verb|B| are complex patterns. Until the \verb|(*SKIP)| verb is reached,
\verb|A| may backtrack as necessary to match. Once it is reached, matching
continues in \verb|B|, which may also backtrack as necessary; however, should \verb|B|
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.

It also signifies that whatever text that was matched leading up to the
\verb|(*SKIP)|  pattern being executed cannot be part of any match of this
pattern. This effectively means that the regex engine \verb"skips" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).

The name of the \verb|(*SKIP:NAME)| pattern has special significance. If a
\verb|(*MARK:NAME)| was encountered while matching, then it is that position
which is used as the "skip point". If no \verb|(*MARK)| of that name was
encountered, then the \verb|(*SKIP)| operator has no effect. When used without
a name the "skip point" is where the match point was when executing the
\verb|(*SKIP)| pattern.
\end{quotation}
\end{it}

Ejemplo:

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n SKIP.pl
     1  #!/soft/perl5lib/bin/perl5.10.1 -w
     2  use strict;
     3  use v5.10;
     4
     5  say "NO SKIP: /a+b?(*FAIL)/";
     6  our $count = 0;
     7  'aaab' =~ /a+b?(?{print "$&\n"; $count++})(*FAIL)/;
     8  say "Count=$count\n";
     9
    10  say "WITH SKIP: a+b?(*SKIP)(*FAIL)/";
    11  $count = 0;
    12  'aaab' =~ /a+b?(*SKIP)(?{print "$&\n"; $count++})(*FAIL)/;
    13  say "WITH SKIP: Count=$count\n";
    14
    15  say "WITH SKIP /a+(*SKIP)b?(*FAIL)/:";
    16  $count = 0;
    17  'aaab' =~ /a+(*SKIP)b?(?{print "$&\n"; $count++})(*FAIL)/;
    18  say "Count=$count\n";
    19
    20  say "WITH SKIP /(*SKIP)a+b?(*FAIL): ";
    21  $count = 0;
    22  'aaab' =~ /(*SKIP)a+b?(?{print "$&\n"; $count++})(*FAIL)/;
    23  say "Count=$count\n";
\end{verbatim}

Ejecución:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 SKIP.pl
NO SKIP: /a+b?(*FAIL)/
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9

WITH SKIP: a+b?(*SKIP)(*FAIL)/
aaab
WITH SKIP: Count=1

WITH SKIP /a+(*SKIP)b?(*FAIL)/:
aaab
aaa
Count=2

WITH SKIP /(*SKIP)a+b?(*FAIL):
aaab
aaa
aa
a
aab
aa
a
ab
a
Count=9
\end{verbatim}

\parrafo{Marcas}

Tomado de \pd{perlretut}{Backtracking-control-verbs}:

\begin{it}
\begin{quotation}
\verb|(*MARK:NAME) (*:NAME)|

This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later \verb|(*SKIP)| pattern will then skip
forward to that point if backtracked into on failure. Any number of
\verb|(*MARK)| patterns are allowed, and the \verb|NAME| portion is optional and may
be duplicated.

In addition to interacting with the \verb|(*SKIP)| pattern, \verb|(*MARK:NAME)| can
be used to \verb"label" a pattern branch, so that after matching, the program
can determine which branches of the pattern were involved in the match.

When a match is successful, the \verb|$REGMARK| variable will be set to the name
of the most recently executed \verb|(*MARK:NAME)| that was involved in the match.

This can be used to determine which branch of a pattern was
matched without using a separate capture buffer for each branch,
which in turn can result in a performance improvement.

When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the \verb|$REGERROR|
variable will be set to the name of the most recently executed
\verb|(*MARK:NAME)|.
\end{quotation}
\end{it}

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n mark.pl
 1  use v5.10;
 2  use strict;
 3
 4  our $REGMARK;
 5
 6  $_ = shift;
 7  say $REGMARK if /(?:x(*MARK:mx)|y(*MARK:my)|z(*MARK:mz))/;
 8  say $REGMARK if /(?:x(*:xx)|y(*:yy)|z(*:zz))/;
\end{verbatim}
Cuando se ejecuta produce:
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl y
my
yy
pl@nereida:~/Lperltesting$ perl5.10.1 mark.pl z
mz
zz
\end{verbatim}

\parrafo{Poniendo un espacio después de cada signo de puntuación}

Se quiere poner un espacio en blanco después de la aparición de cada coma:

\begin{verbatim}
s/,/, /g;
\end{verbatim}

pero se quiere que la sustitución no tenga lugar si la coma esta
incrustada entre dos dígitos. Además se pide que si hay ya un espacio
después de la coma, no se duplique. Sigue una solución que
usa marcas:

\begin{verbatim}
pl@nereida:~/Lperltesting$ perl5.10.1 -wdE 0
main::(-e:1):   0
  DB<1> $a = 'ab,cd, ef,12,34,efg,56,78,df, ef,'
  DB<2> x ($b = $a) =~ s/\d,\d(*:d)|,(?!\s)/($REGMARK eq 'd')? $& : ', '/ge
0  8
  DB<3> p "<$b>"
<ab, cd, ef, 12,34, efg, 56,78, df, ef, >
\end{verbatim}


% section unicode
\input{unicode/unicode.tex}

\section{Expresiones Regulares en Otros Lenguajes}
\label{section:otroslenguajes}

\parrafo{Vim}

\begin{itemize}
\item \pmm{333737}{Learn vi/vim in 50 lines and 15 minutes}
\item  \htmladdnormallink{VIM Regular Expressions}{http://www.geocities.com/volontir/}
\item \pmm{141765}{Editing features for advanced users}
\item \htmladdnormallink{Vim documentation: pattern}{http://www.vim.org/htmldoc/pattern.html}
\item \htmladdnormallink{Vim Regular Expressions Chart}{http://www.softpanorama.org/Editors/Vimorama/vim\_regular\_expressions.shtml}
\end{itemize}

\parrafo{Java}

El siguiente ejemplo muestra un programa estilo \verb|grep|: solicita
una expresión regular para aplicarla luego a una serie de entradas 
leídas desde la entrada estandar.
\begin{verbatim}
casiano@nereida:~/projects/PA/regexp$ cat -n Application.java
 1  /**
 2   * javac Application.java
 3   * java Application
 4   */
 5
 6  import java.io.*;
 7  import java.util.regex.Pattern;
 8  import java.util.regex.Matcher;
 9
10  public class Application {
11
12      public static void main(String[] args){
13          String regexp = "";
14          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
15          try {
16              System.out.print("Enter your regex: ");
17              regexp = br.readLine();
18          } catch (IOException e) { System.exit(1); };
19          while (true) {
20
21              String input = "";
22              try {
23                System.out.print("Enter input string to search: ");
24                input = br.readLine();
25              } catch (IOException e) { System.exit(1); };
26
27              Pattern pattern = Pattern.compile(regexp);
28              Matcher matcher = pattern.matcher(input);
29
30              boolean found = false;
31              while (matcher.find()) {
32                  System.out.println("I found the text "
33                                     + matcher.group()
34                                     + " starting at index "
35                                     + matcher.start()
36                                     + " and ending at index "
37                                     +matcher.end()
38                  );
39                  found = true;
40              }
41              if(!found){
42                  System.out.println("No match found.");
43              }
44          }
45      }
46  }
\end{verbatim}
Ejecución:
\begin{verbatim}
casiano@nereida:~/Ljavatesting$ java Application
Enter your regex: (\d+).(\d+)
Enter input string to search: a4b5d6c7efg
I found the text 4b5 starting at index 1 and ending at index 4
I found the text 6c7 starting at index 5 and ending at index 8
Enter input string to search: abc
No match found.
Enter input string to search:
\end{verbatim}

Véase también 
\htmladdnormallink
{Java Regular Expressions}
{http://java.sun.com/docs/books/tutorial/essential/regex/}

\parrafo{bash}

Esta es una versión en \verb|bash| del conversor de temperaturas
visto en las secciones anteriores:

\begin{verbatim}
pl@nereida:~/src/bash$ cat -n f2c
     1  #!/bin/bash
     2  echo "Enter a temperature (i.e. 32F, 100C):";
     3  read input;
     4
     5  if [ -z "$(echo $input | grep -i '^[-+]\?[0-9]\+\(\.[0-9]*\)\?\ *[CF]$')" ]
     6  then
     7    echo "Expecting a temperature, so don't understand \"$input\"." 1>&2;
     8  else
     9    input=$(echo $input | tr -d ' ');
    10    InputNum=${input:0:${#input}-1};
    11    Type=${input: -1}
    12
    13    if [ $Type = "c" -o $Type = "C" ]
    14    then
    15     celsius=$InputNum;
    16     fahrenheit=$(echo "scale=2; ($celsius * 9/5)+32" | bc -l);
    17    else
    18     fahrenheit=$InputNum;
    19     celsius=$(echo "scale=2; ($fahrenheit -32)*5/9" | bc -l);
    20    fi
    21
    22    echo "$celsius C = $fahrenheit F";
    23  fi
\end{verbatim}

\parrafo{C}

\begin{verbatim}
pl@nereida:~/src/regexpr$ cat -n pcregrep.c
 1  #include <stdio.h>
 2  #include <stdlib.h>
 3  #include <string.h>
 4  #include <assert.h>
 5  #include <pcre.h>
 6
 7  char enter_reverse_mode[] = "\33[7m";
 8  char exit_reverse_mode[] = "\33[0m";
 9
10  int main(int argc, char **argv)
11  {
12    const char *pattern;
13    const char *errstr;
14    int erroffset;
15    pcre *expr;
16    char line[512];
17    assert(argc == 2); /* XXX fixme */
18    pattern = argv[1];
19    if (!(expr = pcre_compile(pattern, 0, &errstr, &erroffset, 0))) {
20      fprintf(stderr, "%s: %s\n", pattern, errstr);
21      return EXIT_FAILURE;
22    }
23    while (fgets(line, sizeof line, stdin)) {
24      size_t len = strcspn(line, "\n");
25      int matches[2];
26      int offset = 0;
27      int flags = 0;
28      line[len] = '\0';
29      while (0 < pcre_exec(expr, 0, line, len, offset, flags, matches, 2)) {
30        printf("%.*s%s%.*s%s",
31          matches[0] - offset, line + offset,
32          enter_reverse_mode,
33          matches[1] - matches[0], line + matches[0],
34          exit_reverse_mode);
35        offset = matches[1];
36        flags |= PCRE_NOTBOL;
37      }
38      printf("%s\n", line + offset);
39    }
40    return EXIT_SUCCESS;
41  }
\end{verbatim}
Compilación:
\begin{verbatim}
pl@nereida:~/src/regexpr$ gcc -lpcre pcregrep.c -o pcregrep
\end{verbatim}

Cuando se ejecuta espera un patrón en la línea de comandos
y pasa a leer desde la entrada estandar. Las cadenas que casan
se muestran resaltadas:
\begin{verbatim}
pl@nereida:~/src/regexpr$ ./pcregrep '\d+'
435 otro 23
\end{verbatim}
\noindent \underline{435} {\tt otro} \underline{23}
\begin{verbatim}
hola
hola
\end{verbatim}

\parrafo{Python}


\begin{verbatim}
pl@nereida:~/src/python$ cat -n c2f.py
 1  #!/usr/local/bin/python
 2  import re
 3
 4  temp = raw_input( ' Introduzca una temperatura (i.e. 32F, 100C): ' )
 5  pattern = re.compile( "^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$", re.IGNORECASE )
 6  mo = pattern.match( temp )
 7
 8  if mo:
 9    inputNum = float(mo.group( 1 ))
10    type = mo.group( 3 )
11    celsius = 0.0
12    fahrenheit = 0.0
13    if ( type == "C" or type == "c" ) :
14      celsius = inputNum
15      fahrenheit = ( celsius * 9/5 ) + 32
16    else :
17      fahrenheit = inputNum
18      celsius = ( fahrenheit - 32 ) * 5/9
19    print " ", '%.2f'%(celsius), " C = ", '%.2f'%(fahrenheit), " F\n"
20  else :
21    print " Se experaba una temperatura, no se entiende", temp, "\n"
\end{verbatim}

\parrafo{Ruby}


\begin{verbatim}
pl@nereida:~/src/ruby$ cat -n f2c_b
 1  #!/usr/bin/ruby
 2
 3  # Primero leemos una temperatura
 4  class Temperature_calculator
 5    def initialize temp
 6    comp = Regexp.new('^([-+]?\d+(\.\d*)?)\s*([CFcf])$')
 7    if temp =~ comp
 8    begin
 9      cifra = Float($1)
10      @C,@F = ( $3 == "F" or $3 == "f")? [(cifra -32) * 5/9, cifra] : [cifra , cifra * 9/5 + 32]
11    end
12    else
13      raise("Entrada incorrecta")
14    end
15  end
16
17    def show
18      puts "Temperatura en Celsius: #{@C}, temperatura en Fahrenheit: #{@F}"
19    end
20  end
21
22  temperatura = Temperature_calculator.new(readline.chop)
23  temperatura.show
\end{verbatim}

\parrafo{Javascript}

\begin{verbatim}
<SCRIPT LANGUAGE="JavaScript"><!--
function demoMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  if (document.demoMatch.subject.value.match(re)) {
    alert("Successful match");
  } else {
    alert("No match");
  }
}

function demoShowMatchClick() {
  var re = new RegExp(document.demoMatch.regex.value);
  var m = re.exec(document.demoMatch.subject.value);
  if (m == null) {
    alert("No match");
  } else {
    var s = "Match at position " + m.index + ":\n";
    for (i = 0; i < m.length; i++) {
      s = s + m[i] + "\n";
    }
    alert(s);
  }
}

function demoReplaceClick() {
  var re = new RegExp(document.demoMatch.regex.value, "g");
  document.demoMatch.result.value = 
    document.demoMatch.subject.value.replace(re, 
      document.demoMatch.replacement.value);
}
// -->
</SCRIPT>

<FORM ID="demoMatch" NAME="demoMatch" METHOD=POST ACTION="javascript:void(0)">
<P>Regexp: <INPUT TYPE=TEXT NAME="regex" VALUE="\bt[a-z]+\b" SIZE=50></P>
<P>Subject string: <INPUT TYPE=TEXT NAME="subject" 
   VALUE="This is a test of the JavaScript RegExp object" SIZE=50></P>
<P><INPUT TYPE=SUBMIT VALUE="Test Match" ONCLICK="demoMatchClick()">
<INPUT TYPE=SUBMIT VALUE="Show Match" ONCLICK="demoShowMatchClick()"></P>

<P>Replacement text: <INPUT TYPE=TEXT NAME="replacement" VALUE="replaced" SIZE=50></P>
<P>Result: <INPUT TYPE=TEXT NAME="result" 
   VALUE="click the button to see the result" SIZE=50></P>
<P><INPUT TYPE=SUBMIT VALUE="Replace" ONCLICK="demoReplaceClick()"></P>
</FORM>
\end{verbatim}

\section{Casos de Estudio}

\subsection{Secuencias de números de tamaño fijo}
\label{section:numeros}
El siguiente problema y sus soluciones se describen en el libro de J.E.F. Friedl
\cite{friedl}.
Supongamos que tenemos un texto conteniendo códigos que son 
números de tamaño fijo, digamos 
seis dígitos, todos pegados, sin separadores entre ellos, como sigue:

\begin{center}
\begin{tt} 
012345678901{\bf123334}234567890123{\bf125934}890123345126
\end{tt} 
\end{center}

El problema es encontrar los códigos que comienzan por {\tt 12}. En negrita 
se han resaltado las soluciones.  Son soluciones sólo aquellas que, comienzan
por \verb|12| en una posición múltiplo de seis. 
Una solución es:

\begin{center}
\begin{verbatim}
@nums = grep {m/^12/} m/\d{6}/g;
\end{verbatim}
\end{center}

que genera una lista con los números y luego selecciona los que comienzan por
\verb|12|.
Otra solución es:

\begin{center}
\begin{verbatim}
@nums = grep { defined } m/(12\d{4})|\d{6}/g;
\end{verbatim}
\end{center}

que aprovecha que la expresión regular devolverá una lista vacía cuando
el número no empieza por \verb|12|:
\begin{verbatim}
DB<1> $x = '012345678901123334234567890123125934890123345126'
DB<2> x  ($x =~ m/(12\d{4})|\d{6}/g)
0  undef
1  undef
2  123334
3  undef
4  undef
5  125934
6  undef
7  undef
\end{verbatim}
Obsérvese que se esta utilizando también que el operador \verb#|# no es \emph{greedy}.

¿Se puede resolver el problema usando sólamente una expresión regular?
Obsérvese que esta solución ``casi funciona'':

\begin{center}
\begin{verbatim}
 DB<3> x @nums = $x =~ m/(?:\d{6})*?(12\d{4})/g;
0  123334
1  125934
2  123345
\end{verbatim}
\end{center}

recoge la secuencia mas corta de grupos de seis dígitos que no casan, seguida 
de una secuencia que casa. 
El problema que tiene esta solución 
es al final, cuando se han casado todas las soluciones, entonces 
la búsqueda exhaustiva hará que nos muestre soluciones que no comienzan en posiciones
múltiplo de seis. Por eso encuentra \verb|123345|:
\begin{center}
\begin{tt} 
012345678901{\bf123334}234567890123{\bf125934}890{\bf123345}126
\end{tt} 
\end{center}
Por eso, Friedl propone esta solución:

\begin{center}
\begin{verbatim}
@nums = m/(?:\d{6})*?(12\d{4})(?:(?!12)\d{6})*/g;
\end{verbatim}
\end{center}

Se asume que existe al menos un éxito en la entrada inicial.
Que es un extraordinario ejemplo de como el uso de paréntesis de agrupamiento
simplifica y mejora la legibilidad de la solución. Es fantástico también el uso
del operador de predicción negativo.

\parrafo{Solución usando el ancla {\tt $\backslash$ G}}

El ancla \verb|\G| ha sido concebida para su uso con la opción \verb|/g|.
Casa con el punto en la cadena en el que terminó el último emparejamiento.
Cuando se trata del primer intento o no se está usando \verb|/g|, usar \verb|\G|
es lo mismo que usar \verb|\A|.

Mediante el uso de este ancla es posible formular la siguiente solución 
al problema planteado:

\begin{center}
\begin{verbatim}
pl@nereida:~/Lperltesting$ perl -wde 0
main::(-e:1):   0
DB<1> $_ = '012345678901123334234567890123125934890123345126'
DB<2> x m/\G(?:\d{6})*?(12\d{4})/g
0  123334
1  125934
\end{verbatim}
\end{center}


\parrafo{Sustitución}

Si lo que se quiere es sustituir las secuencias deseadas es poisble hacerlo con 
la siguiente expresión regular:
\begin{verbatim}
casiano@nereida:~/docs/curriculums/CV_MEC$ perl -wde 0
DB<1> x $x = '012345678901123334234567890123125934890123345126'
0  012345678901123334234567890123125934890123345126
DB<2> x  ($y = $x) =~ s/(12\d{4})|\d{6}/$1? "-$1-":$& /ge
0  8
DB<3> p $y
012345678901-123334-234567890123-125934-890123345126
\end{verbatim}

\subsection{Palabras Repetidas}
\label{section:repetidas}
Su jefe le pide una herramienta que compruebe la aparición de
duplicaciones consecutivas en un texto texto (como esta esta y la anterior anterior).
La solución debe cumplir las siguientes especificaciones:
\begin{itemize}
\item
Aceptar cualquier número de ficheros. Resaltar las apariciones
de duplicaciones. Cada línea del informe debe estar precedida del nombre del fichero.
\item
Funcionar no sólo cuando la duplicación ocurre en la misma línea.
\item
Funcionar independientemente del \emph{case} y de los blancos usados en medio
de ambas palabras.
\item
Las palabras en cuestión pueden estar separadas por \emph{tags} \verb|HTML|.
\end{itemize}

\begin{latexonly}
\begin{verbatim}
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Term::ANSIScreen qw/:constants/;
  4  
  5  my $bold = BOLD();
  6  my $clear = CLEAR();
  7  my $line = 1;
  8  
  9  # read paragraph
 10  local $/ = ".\n";
 11  while (my $par = <>) {
 12    next unless $par =~ s{
 13          \b                 # start word ...
 14          ([a-z]+)           # grab word in $1 and \1
 15          (                  # save the tags and spaces in $2
 16          (\s|<[^>]+>)+      # spaces or HTML tags 
 17          )   
 18          (\1\b)             # repeated word in $4
 19    }!$bold$1$clear$2$bold$4$clear!igx;
 20  
 21    $par =~ s/^/"$ARGV(".$line++."): "/meg;   # insert filename and line number
 22  
 23    print $par;
 24  }
\end{verbatim}
\end{latexonly}
%%{{{
\begin{rawhtml}

<pre>
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> <span class="synStatement">use </span>Term::ANSIScreen <span class="synConstant">qw/:constants/</span>;
<span class="synLinenum">    4</span> 
<span class="synLinenum">    5</span> <span class="synStatement">my</span> <span class="synIdentifier">$bold</span> = BOLD();
<span class="synLinenum">    6</span> <span class="synStatement">my</span> <span class="synIdentifier">$clear</span> = CLEAR();
<span class="synLinenum">    7</span> <span class="synStatement">my</span> <span class="synIdentifier">$line</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    8</span> 
<span class="synLinenum">    9</span> <span class="synComment"># read paragraph</span>
<span class="synLinenum">   10</span> <span class="synStatement">local</span> <span class="synIdentifier">$/</span> = <span class="synConstant">&quot;.</span><span class="synSpecial">\n</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   11</span> <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$par</span> = &lt;&gt;) {
<span class="synLinenum">   12</span>   <span class="synStatement">next</span> <span class="synStatement">unless</span> <span class="synIdentifier">$par</span> =~ <span class="synStatement">s{</span>
<span class="synLinenum">   13</span> <span class="synConstant">        </span><span class="synSpecial">\b</span><span class="synConstant">                 # start word </span><span class="synSpecial">...</span>
<span class="synLinenum">   14</span> <span class="synConstant">        </span><span class="synSpecial">([a-z]+)</span><span class="synConstant">           # grab word in </span><span class="synIdentifier">$1</span><span class="synConstant"> and </span><span class="synSpecial">\1</span>
<span class="synLinenum">   15</span> <span class="synConstant">        </span><span class="synSpecial">(</span><span class="synConstant">                  # save the tags and spaces in </span><span class="synIdentifier">$2</span>
<span class="synLinenum">   16</span> <span class="synConstant">        </span><span class="synSpecial">(\s</span><span class="synConstant">|&lt;</span><span class="synSpecial">[^&gt;]+</span><span class="synConstant">&gt;</span><span class="synSpecial">)+</span><span class="synConstant">      # spaces or HTML tags </span>
<span class="synLinenum">   17</span> <span class="synConstant">        </span><span class="synSpecial">)</span><span class="synConstant">   </span>
<span class="synLinenum">   18</span> <span class="synConstant">        </span><span class="synSpecial">(\1\b)</span><span class="synConstant">             # repeated word in </span><span class="synIdentifier">$4</span>
<span class="synLinenum">   19</span> <span class="synConstant">  </span><span class="synStatement">}</span>!<span class="synIdentifier">$bold$1$clear$2$bold$4$clear</span>!igx;
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synIdentifier">$par</span> =~ <span class="synStatement">s/</span><span class="synConstant">^</span><span class="synStatement">/</span><span class="synConstant">&quot;</span><span class="synIdentifier">$ARGV</span><span class="synConstant">(&quot;.</span><span class="synIdentifier">$line</span><span class="synConstant">++.&quot;): &quot;</span><span class="synStatement">/meg</span>;   <span class="synComment"># insert filename and line number</span>
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">print</span> <span class="synIdentifier">$par</span>;
<span class="synLinenum">   24</span> }
</pre>

\end{rawhtml}%%}}}

%Esta es la solución:
%%%%%%%%%%%%%%%%listinginput: Input from: "../src/doublee.pl"
%\begin{verbatim}
%   1 #!/usr/bin/perl -w
%   2 # one <a>one</a>
%   3 # is two three
%   4 # three
%   5 $/ = ".\n";
%   6 while (<>) {
%   7   next if !s{
%   8     \b                 # start word ...
%   9     ([a-z]+)           # grab word in $1 and \1
%  10     (                  # save the tags and spaces in $2
%  11     (\s|<[^>]+>)+      # spaces or HTML tags 
%  12     )   
%  13     (\1\b)             # repeated word in $4
%  14   }
%  15   "\e[7m$1\e[m$2\e[7m$4\e[m"igx;
%  16   s/^([^\e]*\n)+//mg;  # remove lines that don't contain escapes
%  17   s/^/$ARGV: /mg;      # insert filename at the beginning of the lines
%  18   print;
%  19 }
%\end{verbatim}


\begin{rawhtml}
Sigue un ejemplo de uso:
<pre>
pl@nereida:~/Lperltesting$ cat -n t.t
     1  one one
     2  nothing rep
     3  is two three
     4  three four
     5
pl@nereida:~/Lperltesting$ ./repeatedwords2.pl t.t
t.t(1): <font color="blue">one one</font>
t.t(2): nothing rep
t.t(3): is two <font color="blue">three</font>
t.t(4): <font color="blue">three</font> four
t.t(5):
</pre>
\end{rawhtml}

\subsection{Análisis de cadenas con datos separados por comas}
\label{section:csv}
Supongamos que tenemos cierto texto en \verb|$text| proveniente
de un fichero \verb|CSV| (\emph{Comma Separated Values}). Esto es
el fichero contiene líneas con el formato:

\begin{verbatim}
"earth",1,"moon",9.374
\end{verbatim}

Esta línea representa cinco campos.
Es razonable querer guardar esta información en un \emph{array},
digamos \verb|@field|, de manera que \verb|$field[0] == 'earth'|,
\verb|$field[1] == '1'|, etc.
Esto no sólo implica descomponer la cadena en campos sino
también quitar las comillas de los campos entrecomillados.
La primera solución que se nos ocurre es hacer uso de la
función \verb|split|:

\begin{verbatim}
@fields = split(/,/,$text);
\end{verbatim}

Pero esta solución deja las comillas dobles en  los campos
entrecomillados.  Peor aún, los campos entrecomillados pueden contener
comas, en cuyo caso  la división proporcionada por \verb|split| sería
errónea. 

%%%%%%%%%%%%%%%listinginput: Input from: "../src/csv.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 use Text::ParseWords;
   3 
   4 sub parse_csv {
   5   my $text = shift;
   6   my @fields = (); # initialize @fields to be empty
   7 
   8   while ($text =~ 
   9     m/"(([^"\\]|\\.)*)",? # quoted fields
  10       | 
  11       ([^,]+),?           # $3 = non quoted fields
  12       | 
  13       ,                   # allows empty fields
  14     /gx 
  15     )
  16   {
  17     push(@fields, defined($1)? $1:$3); # add the just matched field
  18   }
  19   push(@fields, undef) if $text =~ m/,$/; #account for an empty last field
  20   return @fields;
  21 }
  22        
  23 $test = '"earth",1,"a1, a2","moon",9.374';
  24 print "string = \'$test\'\n";
  25 print "Using parse_csv\n:";
  26 @fields = parse_csv($test);
  27 foreach $i (@fields) {
  28   print "$i\n";
  29 }
  30 
  31 print "Using Text::ParseWords\n:";
  32 #  @words = &quotewords($delim, $keep, @lines);  
  33 #The $keep argument is a boolean flag.  If true, then the
  34 #tokens are split on the specified delimiter, but all other
  35 #characters (quotes, backslashes, etc.) are kept in the
  36 #tokens.  If $keep is false then the &*quotewords()
  37 #functions remove all quotes and backslashes that are not
  38 #themselves backslash-escaped or inside of single quotes
  39 #(i.e., &quotewords() tries to interpret these characters
  40 #just like the Bourne shell). 
  41 
  42 @fields = quotewords(',',0,$test);
  43 foreach $i (@fields) {
  44   print "$i\n";
  45 }
\end{verbatim}

Las subrutinas  en Perl reciben sus argumentos en el \emph{array}
\verb|@_|. Si la lista de argumentos contiene listas, estas 
son ``aplanadas'' en una única lista. Si, como es el caso, la subrutina
ha sido declarada antes de la llamada, los argumentos pueden
escribirse sin paréntesis que les rodeen:
\begin{verbatim}
@fields = parse_csv $test;
\end{verbatim}

Otro modo de llamar una subrutina es usando el prefijo \verb|&|,
pero sin proporcionar lista de argumentos.
\begin{verbatim}
@fields = &parse_csv;
\end{verbatim}
En este caso se le pasa a la rutina el valor actual del  \emph{array} \verb|@_|.

Los operadores \verb|push| (usado en la línea 17) y \verb|pop| trabajan
sobre el final del \emph{array}. De manera análoga los operadores
\verb|shift| y \verb|unshift| lo hacen sobre el comienzo.
El operador ternario \verb|?| trabaja de manera análoga como lo hace en C.

El código del \verb|push| podría sustituirse por este otro:
\begin{verbatim}
push(@fields, $+);
\end{verbatim}
Puesto que la variable \verb|$+| contiene la cadena que ha casado
con el último paréntesis que haya casado en el ultimo ``matching''.

La segunda parte del código muestra que existe un 
módulo en Perl, el módulo \verb|Text::Parsewords| que proporciona la rutina \verb|quotewords| que hace la misma función que nuestra subrutina.

Sigue un ejemplo de ejecución:
\begin{verbatim}
> csv.pl
string = '"earth",1,"a1, a2","moon",9.374'
Using parse_csv
:earth
1
a1, a2
moon
9.374
Using Text::ParseWords
:earth
1
a1, a2
moon
9.374    
\end{verbatim}

\subsection{Las Expresiones Regulares como Exploradores de un Árbol de Soluciones}

\parrafo{Números Primos}

El siguiente programa evalúa si un número es primo o no:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n isprime.pl
 1  #!/usr/bin/perl -w
 2  use strict;
 3
 4  my $num = shift;
 5  die "Usage: $0 integer\n" unless (defined($num) && $num =~ /^\d+$/);
 6
 7  if (("1" x $num) =~ /^(11+)\1+$/) {
 8    my $factor = length($1);
 9    print "$num is $factor x ".$num/$factor."\n";
10  }
11  else {
12    print "$num is prime\n";
13  }
\end{verbatim}
Siguen varias ejecuciones:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./isprime.pl 35.32
Usage: ./isprime.pl integer
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 147
147 is 49 x 3
pl@nereida:~/Lperltesting$ ./isprime.pl 137
137 is prime
pl@nereida:~/Lperltesting$ ./isprime.pl 49
49 is 7 x 7
pl@nereida:~/Lperltesting$ ./isprime.pl 47
47 is prime
\end{verbatim}


\parrafo{Ecuaciones Diofánticas: Una solución}

Según dice la entrada \wikipedia{Diophantine\_equation}\ en la wikipedia:

\begin{it}
\begin{quotation}
In mathematics, a Diophantine equation is an indeterminate polynomial equation that allows the variables to be integers only. 
\end{quotation}
\end{it}

La siguiente sesión con el depurador muestra como se puede 
resolver una ecuación lineal diofántica con coeficientes 
positivos usando una expresión regular:

\begin{verbatim}
  DB<1> # Resolvamos 3x + 2y + 5z = 40
DB<2> x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
1  'aa'
2  'aaaaa'
DB<3> x map { length }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  33
1  2
2  5
DB<4> @c = (3, 2, 5)
DB<5> x map { length($_) / $c[$i++] }  ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$/
0  11
1  1
2  1
DB<6> p 3*11+2*1+5*1
40
\end{verbatim}

\parrafo{Ecuaciones Diofánticas: Todas las soluciones}


Usando el verbo \verb|(*FAIL)| es posible obtener todas las soluciones:
\begin{verbatim}
main::(-e:1):   0
DB<1>  sub equ { my @c = @_; print "\t3*$c[0]+2*$c[1]+5*$c[2] = ",3*$c[0]+2*$c[1]+5*$c[2],"\n" }
DB<2> sub f { my @c = ((length($1)/3), (length($2)/2), (length($3)/5)); equ(@c); }
DB<3> x ('a'x40) =~  /^((?:...)+)((?:..)+)((?:.....)+)$(?{ f() })(*FAIL)/x
        3*11+2*1+5*1 = 40
        3*9+2*4+5*1 = 40
        3*8+2*3+5*2 = 40
        3*7+2*7+5*1 = 40
        3*7+2*2+5*3 = 40
        3*6+2*6+5*2 = 40
        3*6+2*1+5*4 = 40
        3*5+2*10+5*1 = 40
        3*5+2*5+5*3 = 40
        3*4+2*9+5*2 = 40
        3*4+2*4+5*4 = 40
        3*3+2*13+5*1 = 40
        3*3+2*8+5*3 = 40
        3*3+2*3+5*5 = 40
        3*2+2*12+5*2 = 40
        3*2+2*7+5*4 = 40
        3*2+2*2+5*6 = 40
        3*1+2*16+5*1 = 40
        3*1+2*11+5*3 = 40
        3*1+2*6+5*5 = 40
        3*1+2*1+5*7 = 40
  empty array
DB<4>                                
\end{verbatim}


\parrafo{Ecuaciones Diofánticas: Resolutor general}

El siguiente programa recibe en línea de comandos los coeficientes y 
término inependeinte de una ecuación lineal diofántica con coeficientes 
positivos y muestra todas las soluciones. El
algoritmo primero crea una cadena conteniendo 
el código Perl que contiene la expresión regular adecuada 
para pasar luego a evaluarlo:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n diophantinesolvergen.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1 -w
 2  use v5.10;
 3  use strict;
 4
 5  # Writes a Perl solver for
 6  # a1 x1 + a2 x2 + ... + an xn = b
 7  # a_i and b integers > 0
 8  #
 9
10  my $b = pop;
11  my @a = @ARGV;
12  my $debug = 1;
13
14  my $b1 = '1'x$b;
15  my @a1 = map { '1'x$_ } @a;
16  my @index = map { 'length($'.$_.")/".$a[$_-1] } 1..(@a);
17  my $aux = join ",", @index;
18
19  my $regexp = '^';
20  $regexp .= "((?:$_)+)" for @a1;
21
22  $regexp .= '$(?{ f() })(*FAIL)';
23
24  my $solver = <<"SOLVER";
25  my \@stack;
26  sub f {
27    my \@s = ($aux);
28    push \@stack, [ \@s ];
29  }
30
31  q{$b1} =~ m{$regexp}x;
32
33  return \@stack;
34  SOLVER
35
36  print "Solver:\n--------\n$solver\n--------\n" if $debug;
37
38  my @stack = eval $solver;
39
40  say("@$_") for @stack
\end{verbatim}
Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./diophantinesolvergen.pl 3 2 5 40
Solver:
--------
my @stack;
sub f {
  my @s = (length($1)/3,length($2)/2,length($3)/5);
  push @stack, [ @s ];
}

q{1111111111111111111111111111111111111111} =~ m{^((?:111)+)((?:11)+)((?:11111)+)$(?{ f() })(*FAIL)}x;

return @stack;

--------
11 1 1
9 4 1
8 3 2
7 7 1
7 2 3
6 6 2
6 1 4
5 10 1
5 5 3
4 9 2
4 4 4
3 13 1
3 8 3
3 3 5
2 12 2
2 7 4
2 2 6
1 16 1
1 11 3
1 6 5
1 1 7
\end{verbatim}

\parrafo{Las  Tres Hijas}
\label{parrfo:lastreshijas}

En la páginas de Retos Matemáticos de

\htmladdnormallink{DIVULGAMAT}{http://divulgamat.ehu.es/weborriak/RetosMatematicos/Problemas/Prob15.asp}

puede encontrarse el siguiente problema:

\begin{exercise}
Dos matemáticos se vieron en la calle después de muchos años sin coincidir.

\begin{itemize}
\item  ¡Hola!, ¿qué tal?, ¿te casaste?, y... ¿cuántos hijos tienes?
\item  Pues tengo tres hijas.
\item  ¿y qué años tienen?
\item  ¡A ver si lo adivinas!: el producto de las edades de las tres es 36, y su suma es el número del portal que ves enfrente...
\item  ¡Me falta un dato!
\item  ¡Ah, sí!, ¡la mayor toca el piano!
\end{itemize}

%Two MIT math grads bump into each other while shopping at Fry’s. They haven't seen each other in over 20 years.
%
%First grad to the second: "How have you been?"
%Second: "Great! I got married and I have three daughters now."
%First: "Really? How old are they?"
%Second: "Well, the product of their ages is 72, and the sum of their ages is the same as the number on that building over there..."
%First: "Right, ok... Oh wait... Hmm, I still don't know."
%Second: "Oh sorry, the oldest one just started to play the piano."
%First: "Wonderful! My oldest is the same age!" 

¿Qué edad tendrán las tres hijas?

¿Podemos ayudarnos de una expresión regular para resolver el problema?
Al ejecutar el siguiente programa:
 
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n playspiano.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1  -w
 2  use v5.10;
 3  use strict;
 4  use List::Util qw{sum};
 5
 6  local our %u;
 7  sub f {
 8    my @a = @_;
 9    @a = sort { $b <=> $a } (length($a[1]), length($a[0])/length($a[1]), 36/length($a[0]) );
10
11    local $" = ", ";
12    say "(@a)\t ".sum(@a) unless exists($u{"@a"});
13    $u{"@a"} = undef;
14  }
15
16  say "SOL\t\tNUMBER";
17  my @a =  ('1'x36) =~
18           /^((1+)\2+)(\1+)$
19                     (?{ f($1, $2, $3)
20                      })
21             (*FAIL)
22           /x;
\end{verbatim}

obtenemos la salida:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./playspiano.pl
SOL             NUMBER
(9, 2, 2)        13
(6, 3, 2)        11
(4, 3, 3)        10
(18, 2, 1)       21
(12, 3, 1)       16
(9, 4, 1)        14
(6, 6, 1)        13
\end{verbatim}

Explique el funcionamiento del programa. 
A la vista de la salida ¿Cuáles eran las 
edades de las hijas?
\end{exercise}

\parrafo{Mochila 0-1}

Para una definición del problema vea la sección 
\htmladdnormallink{El Problema de la Mochila 0-1}{http://nereida.deioc.ull.es/~lhp/perlexamples/node205.html}
en los apuntes de LHP
\begin{exercise}
¿Sería capaz de resolver usando expresiones regulares el problema de la mochila 0-1?

¡Si lo logra merece el premio a la solución mas freak que se haya encontrado para dicho problema!
\end{exercise}

\parrafo{Véase también}

Véase  también:
\begin{itemize}
%\item
%\htmladdnormallink
%{http://blog.stevenlevithan.com/archives/algebra-with-regexes}
\item
Véase el nodo en \perlmonk{796576} \emph{The Oldest Plays the Piano}
\item
\htmladdnormallink{Solving Algebraic Equations Using Regular Expressions}{http://blog.stevenlevithan.com/archives/algebra-with-regexes}
\end{itemize}

\subsection{Número de substituciones realizadas}
El operador de substitución devuelve el número de substituciones
realizadas, que puede ser mayor que uno si se usa la opción
\verb|/g|. En cualquier otro caso retorna el valor falso.
%%%%%%%%%%%%%%%listinginput: Input from: "../src/numsust.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 undef($/);
   3 $paragraph = <STDIN>;
   4 $count = 0;
   5 $count = ($paragraph =~ s/Mister\b/Mr./ig);
   6 print "$paragraph";
   7 print "\n$count\n";
\end{verbatim}
El resultado de la ejecución es el siguiente:
\begin{verbatim}
> numsust.pl
Dear Mister Bean,
Is a pleasure for me and Mister Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mister Goofy.
 
Yours sincerely
  Mister Mickey Mouse
Dear Mr. Bean,
Is a pleasure for me and Mr. Pluto
to invite you to the Opening Session
Official dinner that will be chaired by
Mr. Goofy.
 
Yours sincerely
  Mr. Mickey Mouse
 
4   
\end{verbatim}

\subsection{Expandiendo y comprimiendo tabs}
Este programa convierte los tabs en el número apropiado de blancos.
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  
   4  my @string = <>;
   5  
   6  for (@string) {
   7    while (s/\t+/' ' x (length($&)*8 - length($`)%8)/e) {}
   8    print $_;
   9  }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n expandtabs.pl
<span class="synLinenum">    1</span> <span class="synPreProc">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span> <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span> <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span> <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>   <span class="synStatement">while</span> (<span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/e</span>) {}
<span class="synLinenum">    8</span>   <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span> }
</pre>

\end{rawhtml}
%}}}
Sigue un ejemplo de ejecución:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -nt tabs.in
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ ./expandtabs.pl tabs.in | cat -tn
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lperltesting$ <span class="dbuser">cat -nt tabs.in</span>
     1  012345670123456701234567012345670
     2  one^Itwo^I^Ithree
     3  four^I^I^I^Ifive
     4  ^I^Itwo
pl@nereida:~/Lperltesting$ <span class="dbuser">./expandtabs.pl tabs.in | cat -tn</span>
     1  012345670123456701234567012345670
     2  one     two             three
     3  four                            five
     4                  two
</pre>
\end{rawhtml}
%}}}

\begin{exercise}
¿Funciona igual si se cambia el bucle \verb|while| por una opción \verb|/g|?
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
   1    #!/usr/bin/perl -w
   2    use strict;
   3  
   4    my @string = <>;
   5  
   6    for (@string) {
   7      s/\t+/' ' x (length($&)*8 - length($`)%8)/ge;
   8      print $_;
   9    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./expandtabs2.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/perl -w</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synStatement">my</span> <span class="synIdentifier">@string</span> = &lt;&gt;;
<span class="synLinenum">    5</span> 
<span class="synLinenum">    6</span>   <span class="synStatement">for</span> (<span class="synIdentifier">@string</span>) {
<span class="synLinenum">    7</span>     <span class="synStatement">s/</span><span class="synSpecial">\t+</span><span class="synStatement">/</span><span class="synConstant">' ' x (length(</span><span class="synIdentifier">$&amp;</span><span class="synConstant">)*8 - length(</span><span class="synIdentifier">$`</span><span class="synConstant">)%8)</span><span class="synStatement">/ge</span>;
<span class="synLinenum">    8</span>     <span class="synStatement">print</span> <span class="synIdentifier">$_</span>;
<span class="synLinenum">    9</span>   }
</pre>

\end{rawhtml}
%}}}
¿Porqué?
\end{exercise}

\subsection{Modificación de Múltiples Ficheros: one liner}
Aunque no es la forma de uso habitual, Perl puede ser utilizado en ``modo sed'' para modificar el texto en múltiples ficheros: 

\verb|perl  -e 's/nereida\.deioc\.ull\.es/miranda.deioc.ull.es/gi'  -p  -i.bak  *.html|

Este programa sustituye la palabra original (g)lobalmente e i)gnorando el ``case'') en todos los ficheros \verb|*.html| y para cada uno de ellos crea una copia de seguridad \verb|*.html.bak|. 

Otro ejemplo: la sustitución que sigue ocurre en todos los ficheros \verb|info.txt| en todos
los subdirectorios de los subdirectorios que comiencen por \verb|alu|:

\begin{verbatim}
perl -e 's/\|hyperpage//gi' -p -i.bak  alu*/*/info.txt
\end{verbatim}

Las \cei{opciones de línea} de comandos significan lo siguiente:

\begin{itemize}
\item[-e] puede usarse para definir el script en la línea de comandos. Multiples -e te permiten escribir un multi-script. Cuando se usa -e, perl
      no busca por un fichero de script entre la lista de argumentos. 

\item[-p] La opción \teis{-p}{Opción de perl -p} hace que perl incluya un bucle alrededor de tu ``script'' al estilo sed: 
\begin{verbatim}
while (<>) {
        ...             # your script goes here
} continue {
        print;
}
\end{verbatim}
\item[-n] Nótese que las líneas se imprimen automáticamente. Para suprimir la impresión usa la opción 
\teis{-n}{Opción de perl -n} 

\item[-i[ext]] La opción \teis{-i}{Opción de perl -i} Expresa que los ficheros procesados serán modificados. Se renombra el fichero de entrada \verb|file.in| a \verb|file.in.ext|, abriendo el de salida con el mismo nombre del fichero de entrada \verb|file.in|.
      Se selecciona dicho fichero como de salida por defecto para las sentencias \verb|print|. Si se proporciona una extensión se hace una copia de seguridad. Si no, no se hace copia de seguridad.
\end{itemize}

En general las opciones pueden ponerse en la primera
línea del ``script'', donde se indica el intérprete. 
Asi pues, decir 

\verb|perl -p -i.bak -e "s/foo/bar/;"| 

es equivalente a usar el ``script'': 
\begin{verbatim}
#!/usr/bin/perl -pi.bak
s/foo/bar/;
\end{verbatim}

\section{tr y split}
\label{section:tr}
El operador de traducción permite la conversión de unos caracteres por otros. 
Tiene la sintáxis:

\begin{tabular}{l}
\verb|tr/SEARCHLIST/REPLACEMENTLIST/cds|\\
\verb|y/SEARCHLIST/REPLACEMENTLIST/cds|\\
\end{tabular}

El operador permite el reemplazo carácter a carácter, por ejemplo:
\begin{verbatim}
$ perl -de 0
  DB<1> $a = 'fiboncacci'
  DB<2> $a =~ tr/aeiou/AEIOU/
  DB<3> print $a
fIbOncAccI
  DB<4> $a =~ y/fbnc/FBNC/
  DB<5> print $a
FIBONCACCI
\end{verbatim}
El operador devuelve el número de carácteres reeemplazados
o suprimidos. 
\begin{verbatim}
$cnt = $sky =~ tr/*/*/; # count the stars in $sky
\end{verbatim}

Si se especifica el modificador \verb|/d|, cualquier carácter en  \verb|SEARCHLIST|
que no figure en \verb|REPLACEMENTLIST| es eliminado.
\begin{verbatim}
  DB<6> print $a
FIBONCACCI
  DB<7> $a =~ y/OA//d
  DB<8> print $a
FIBNCCCI
\end{verbatim}


Si se especifica el modificador \verb|/s|, las secuencias de carácteres
consecutivos que serían traducidas al mismo carácter son comprimidas a una sola:

\begin{verbatim}
  DB<1> $b = 'aaghhh!'
  DB<2> $b =~ tr/ah//s
  DB<3> p $b
agh!
\end{verbatim}

Observa que si la cadena \verb|REPLACEMENTLIST| es vacía,
no se introduce ninguna modificación.

Si se especifica el modificador \verb|/c|, se complementa \verb|SEARCHLIST|;
esto es, se buscan los caracteres que no están en \verb|SEARCHLIST|.

\begin{verbatim}
tr/a-zA-Z/ /cs; # change non-alphas to single space
\end{verbatim}

Cuando se dan múltiples traducciones para un mismo carácter, solo la primera es utilizada:

\begin{verbatim}
tr/AAA/XYZ/
\end{verbatim}

traducirá \verb|A| por \verb|X|.

El siguiente \emph{script} busca una expresión regular en el fichero de \verb|passwords|
e imprime los \emph{login} de los usuarios que casan con dicha cadena.
Para evitar posibles confusiones con las vocales acentuadas
se usa el operador \verb|tr|.

%%%%%%%%%%%%%%%listinginput: Input from: "../src/split.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $search = shift(@ARGV) or die("you must provide a regexpr\n");
   3 $search =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   4 open(FILE,"/etc/passwd");
   5 while ($line = <FILE>) {
   6   $line =~ y/ÁÉÍÓÚáéíóú/AEIOUaeiou/;
   7   if ($line =~ /$search/io) {
   8     @fields = split(":",$line);
   9     $login = $fields[0];
  10     if ($line !~ /^#/) {
  11       print "$login\n";
  12     }
  13     else {
  14       print "#$login\n";
  15     }
  16   }
  17 }
  18   
\end{verbatim}

Ejecución (suponemos que el nombre del fichero anterior es \verb|split.pl|):
\begin{verbatim}
> split.pl Rodriguez
##direccion
call
casiano
alu5
alu6
##doctorado
paco
falmeida
##ihiu07 
\end{verbatim}


Para familiarizarte con este operador, codifica y prueba el siguiente
código:

%%%%%%%%%%%%%%%listinginput: Input from: "../src/tr.pl"
\begin{verbatim}
   1 #!/usr/bin/perl -w
   2 $searchlist = shift @ARGV;
   3 $replacelist = shift @ARGV;
   4 $option = "";
   5 $option = shift @ARGV if @ARGV;
   6 
   7 while (<>) {
   8   $num = eval "tr/$searchlist/$replacelist/$option";
   9   die $@ if $@;
  10   print "$num: $_";
  11 }
\end{verbatim}

Perl construye la tabla de traducción en ``tiempo de compilación''. Por ello
ni \verb|SEARCHLIST| ni \verb|REPLACEMENTLIST| son susceptibles de 
ser interpolados. Esto significa que si queremos usar variables tenemos
que recurrir a la función \verb|eval|.

La expresión pasada como parámetro a \verb|eval| en la línea 8 es analizada y ejecutada como si 
se tratara de un pequeño programa Perl. Cualquier asignación a variables permanece
después del \verb|eval|, asi como cualquier definición de subrutina. 
El código dentro de \verb|eval| se trata como si fuera un bloque, de manera
que cualesquiera variables locales (declaradas con \verb|my|) desaparecen
al final del bloque.

La variable \verb|$@| contiene el mensaje de error asociado con la
última ejecución del comando \verb|eval|. Si es nula es que el último comando
se ejecuto correctamente.
Aqui tienes un ejemplo de llamada:

\begin{verbatim}
> tr.pl 'a-z' 'A-Z' s
jose hernandez
13: JOSE HERNANDEZ
joosee hernnandez
16: JOSE HERNANDEZ 
\end{verbatim}

\section{{\tt Pack} y {\tt Unpack}}
\label{section:pack}
El operador \verb|pack| trabaja de forma parecida a \verb|sprintf|.
Su primer argumento es una cadena, seguida de una lista de valores
a formatear y devuelve una cadena:
\begin{verbatim}
pack("CCC", 65, 66, 67, 68) # empaquetamos A B C D
\end{verbatim}
el inverso es el operador \verb|unpack|
\begin{verbatim}
unpack("CCC", "ABCD")
\end{verbatim}
La cadena de formato es una lista de especificadores que indican el
tipo del dato que se va a empaquetar/desempaquetar. Cada especificador
puede opcionalmente seguirse de un contador de repetición
que indica el número de elementos a formatear. Si se pone un
asterisco (\verb|*|) se indica que la especificación
se aplica a todos los elementos restantes de la lista.

\begin{tabular}{|l|l|l}
Formato  & Descripción \\
A & Una cadena completada con blancos\\
a & Una cadena completada con ceros\\
B & Una cadena binaria en orden descendente\\
b & Una cadena binaria en orden ascendente\\
H & Una cadena hexadecimal, los nibble altos primero\\
h & Una cadena hexadecimal, los nibble bajos primero\\
\end{tabular}

Ejemplo de uso del formato \verb|A|:
\begin{verbatim}
DB<1> $a = pack "A2A3", "Pea","rl"
DB<2> p $a
Perl
DB<3> @b = unpack "A2A3", "Perl"
DB<4> p "@b"
Pe rl
\end{verbatim}
La variable \verb|@b| tiene ahora dos cadenas. Una es \verb|Pe| la otra es \verb|rl|.
Veamos un ejemplo con el formato \verb|B|:
\begin{verbatim}
p ord('A')
65
DB<22> $x = pack "B8", "01000001"
DB<23> p $x
A
DB<24> @y = unpack "B8", "A"
DB<25> p "@y"
01000001
DB<26> $x = pack "b8", "10000010"
DB<27> p $x
\end{verbatim}

\sectionpractica{Un lenguaje para Componer Invitaciones}
\label{practica:invitaciones}

En el capítulo 6 (sección 6.4.2.2) del libro 
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
se define un lenguaje para componer textos para enviar invitaciones.

Para escribir una invitación en ese lenguaje escribiríamos algo así:

\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  <?xml version="1.0"?>
 2  <!DOCTYPE invitation SYSTEM "invitation.dtd">
 3  <invitation>
 4  <!-- ++++ The header part of the document ++++ -->
 5  <front>
 6  <to>Anna, Bernard, Didier, Johanna</to>
 7  <date>Next Friday Evening at 8 pm</date>
 8  <where>The Web Cafe</where>
 9  <why>My first XML baby</why>
10  </front>
11  <!-- +++++ The main part of the document +++++ -->
12  <body>
13  <par>
14  I would like to invite you all to celebrate
15  the birth of <emph>Invitation</emph>, my
16  first XML document child.
17  </par>
18  <par>
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  </par>
22  <par>
23  I <emph>really</emph> look forward to see you soon!
24  </par>
25  </body>
26  <!-- +++ The closing part of the document ++++ -->
27  <back>
28  <signature>Michel</signature>
29  </back>
30  </invitation>
\end{verbatim}

La sintáxis del lenguaje queda reflejada en la siguiente 
\cei{Document Type Definition} (\cei{DTD}) que aparece en la sección 6.4.3
del libro de Goosens:

\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.dtd
 1  <!-- invitation DTD   -->
 2  <!-- May 26th 1998 mg -->
 3  <!ELEMENT invitation (front, body, back) >
 4  <!ELEMENT front      (to, date, where, why?) >
 5  <!ELEMENT date       (#PCDATA) >
 6  <!ELEMENT to         (#PCDATA) >
 7  <!ELEMENT where      (#PCDATA) >
 8  <!ELEMENT why        (#PCDATA) >
 9  <!ELEMENT body       (par+) >
10  <!ELEMENT par        (#PCDATA|emph)* >
11  <!ELEMENT emph       (#PCDATA) >
12  <!ELEMENT back       (signature) >
13  <!ELEMENT signature  (#PCDATA) >
\end{verbatim}

El  objetivo de esta práctica es escribir un programa Perl
que usando las extensiones para expresiones regulares presentes 
en la versión 5.10 reconozca el lenguaje anterior.

Véase también:

\begin{itemize}
\item
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
\item
\htmladdnormallink{Examples from The LaTeX Web Companion}{http://www.ctan.org/tex-archive/info/examples/lwc/} (véanse los subdirectorios
correspondietnes a los capítulos 6 y 7)
%\item
%\htmladdnormallink{CSS Tutorial}{http://www.w3schools.com/css/}
%\item
%\htmladdnormallink{Edición extremadamente simple de HTML}{http://www.psicobyte.com/html/index.html}
%\item
%\htmladdnormallink{Perl-XML Frequently Asked Questions}{http://perl-xml.sourceforge.net/faq/}
\end{itemize}

% see jeff Pinyan Regex::Parser

\section{Analisis Sintáctico con Expresiones Regulares Perl}

\subsection{Introducción al Anaĺisis Sintáctico con Expresiones Regulares}

Como se ha comentado en la sección
\ref{subsection:regexp510lenrec}
Perl 5.10 permite el reconocimiento de expresiones
definidas mediante gramáticas recursivas, siempre que 
estas puedan ser analizadas por un analizador recursivo descendente.
Sin embargo, las expresiones regulares Perl 5.10 
hace difícil construir una representación 
del árbol de análisis sintáctico abstracto. Además, la necesidad
de explicitar en la regexp los blancos existentes entre los símbolos
hace que la descripción sea menos robusta y menos legible.

\parrafo{Ejemplo: Traducción de expresiones aritméticas en infijo a postfijo}

El siguiente ejemplo muestra una expresión regular
que traduce expresiones de diferencias en infijo
a postfijo.

Se usa una variable \verb|$tran| 
para calcular la traducción de
la subexpresión vista hasta el momento.

La gramática original que consideramos
es recursiva a izquierdas:
\begin{verbatim}
 exp ->   exp '-' digits
        | digits
\end{verbatim}
aplicando las técnicas explicadas en
\ref{subsection:eliminaleftrec} y en 
el nodo de perlmonks
\pmm{Operator Associativity and Eliminating Left-Recursion in Parse::RecDescent}{553889}
transformamos la gramática en:
\begin{verbatim}
exp ->   digits rest
rest ->   '-' rest
        | # empty
\end{verbatim}

Sigue el código:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
  1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
  2    use v5.10;
  3  
  4    # Infix to postfix translator using 5.10 regexp
  5    # original grammar:
  6    #  exp ->   exp '-' digits
  7    #         | digits
  8    #
  9    # Applying left-recursion elimination we have:
 10    #  exp ->   digits rest
 11    #  rest ->   '-' rest
 12    #          | # empty
 13    #
 14    my $input;
 15    local our $tran = '';
 16  
 17    my $regexp = qr{
 18        (?&exp)
 19  
 20        (?(DEFINE)
 21            (?<exp>    ((?&digits)) \s* (?{ $tran .= "$^N "; say "tran=$tran"; }) (?&rest)
 22                          (?{
 23                             say "exp -> digits($^N) rest";
 24                          })
 25            )
 26  
 27            (?<rest>     \s* - ((?&digits)) (?{ $tran .= "$^N - "; say "tran=$tran"; }) (?&rest)
 28                            (?{
 29                               say "rest -> - digits($^N) rest";
 30                            })
 31                      |  # empty
 32                            (?{
 33                               say "rest -> empty";
 34                            })
 35            )
 36  
 37            (?<digits>  \s* (\d+)
 38            )
 39        )
 40    }xms;
 41  
 42    $input = <>;
 43    chomp($input);
 44    if ($input =~ $regexp) {
 45      say "matches: $&\ntran=$tran";
 46    }
 47    else {
 48      say "does not match";
 49    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n infixtopostfix.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># original grammar:</span>
<span class="synLinenum">    6</span>   <span class="synComment">#  exp -&gt;   exp '-' digits</span>
<span class="synLinenum">    7</span>   <span class="synComment">#         | digits</span>
<span class="synLinenum">    8</span>   <span class="synComment">#</span>
<span class="synLinenum">    9</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   10</span>   <span class="synComment">#  exp -&gt;   digits rest</span>
<span class="synLinenum">   11</span>   <span class="synComment">#  rest -&gt;   '-' rest</span>
<span class="synLinenum">   12</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   13</span>   <span class="synComment">#</span>
<span class="synLinenum">   14</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   15</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$tran</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   16</span> 
<span class="synLinenum">   17</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   18</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   21</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">((?</span><span class="synConstant">&amp;digits</span><span class="synSpecial">))</span><span class="synConstant"> </span><span class="synSpecial">\s*</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">{ </span><span class="synIdentifier">$tran</span><span class="synConstant"> </span><span class="synSpecial">.</span><span class="synConstant">= &quot;</span><span class="synIdentifier">$^</span><span class="synConstant">N &quot;; say &quot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;; }</span>) (?<span class="synIdentifier">&amp;rest</span>)
<span class="synLinenum">   22</span>                         (?{
<span class="synLinenum">   23</span>                            say <span class="synConstant">&quot;exp -&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest&quot;</span>;
<span class="synLinenum">   24</span>                         })
<span class="synLinenum">   25</span>           )
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span>           (?<span class="synIdentifier">&lt;rest&gt;</span>     \s* - ((?<span class="synIdentifier">&amp;digits</span>)) (?{ <span class="synIdentifier">$tran</span> .= <span class="synConstant">&quot;</span><span class="synIdentifier">$^</span><span class="synConstant">N - &quot;</span>; say <span class="synConstant">&quot;tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;</span>; }) (?<span class="synIdentifier">&amp;rest</span>)
<span class="synLinenum">   28</span>                           (?{
<span class="synLinenum">   29</span>                              say <span class="synConstant">&quot;rest -&gt; - digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rest&quot;</span>;
<span class="synLinenum">   30</span>                           })
<span class="synLinenum">   31</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   32</span>                           (?{
<span class="synLinenum">   33</span>                              say <span class="synConstant">&quot;rest -&gt; empty&quot;</span>;
<span class="synLinenum">   34</span>                           })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* (\d+)
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span>       )
<span class="synLinenum">   40</span>   }xms;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   43</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   44</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   45</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">tran=</span><span class="synIdentifier">$tran</span><span class="synConstant">&quot;</span>;
<span class="synLinenum">   46</span>   }
<span class="synLinenum">   47</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   48</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   49</span>   }
</pre>

\end{rawhtml}
%}}}
La variable \verb|$^N| contiene el valor que casó con el último paréntesis.
Al ejecutar el código anterior obtenemos:

Véase la ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./infixtopostfix.pl
ab 5 - 3 -2 cd;
tran= 5
tran= 5  3 -
tran= 5  3 - 2 -
rest -> empty
rest -> - digits(2) rest
rest -> - digits( 3) rest
exp -> digits( 5) rest
matches:  5 - 3 -2
tran= 5  3 - 2 -
\end{verbatim}

Como se ve, el recorrido primero profundo se 
traduce en la reconstrucción de una derivación a derechas.

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante acciones intermedias}

Es difícil extender el ejemplo anterior a lenguajes mas complejos debido a la 
limitación de que sólo se dispone de acceso al último paréntesis vía \verb|$^N|.
En muchos casos es necesario poder acceder a paréntesis/atributos anteriores.

El siguiente código considera el caso de expresiones con sumas, restas, multiplicaciones
y divisiones. Utiliza la variable \verb|op| y una acción intermedia (líneas 51-53) 
para almacenar el segundo paréntesis necesitado:
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21  
22    my $input;
23    my @stack;
24  
25    local our $op = '';
26    my $regexp = qr{
27        (?&exp)
28  
29        (?(DEFINE)
30            (?<exp>    (?&term) (?&re)
31                         (?{ say "exp -> term re" })
32            )
33  
34            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, $^N }) (?&re)
35                         (?{ say "re -> [+-] term re" })
36                     | # empty
37                         (?{ say "re -> empty" })
38            )
39  
40            (?<term>   ((?&digits))
41                          (?{ # intermediate action
42                              push @stack, $^N
43                          })
44                       (?&rt)
45                          (?{
46                              say "term-> digits($^N) rt";
47                          })
48            )
49  
50            (?<rt>     \s*([*/])
51                               (?{ # intermediate action
52                                  local $op = $^N;
53                               })
54                       ((?&digits)) \s*
55                               (?{  # intermediate action
56                                    push @stack, $^N, $op
57                                })
58                       (?&rt) # end of <rt> definition
59                               (?{
60                                    say "rt -> [*/] digits($^N) rt"
61                                })
62                      |  # empty
63                         (?{ say "rt -> empty" })
64            )
65  
66            (?<digits>  \s* \d+
67            )
68        )
69    }xms;
70  
71    $input = <>;
72    chomp($input);
73    if ($input =~ $regexp) {
74      say "matches: $&\nStack=(@stack)";
75    }
76    else {
77      say "does not match";
78    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withactions3.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   24</span> 
<span class="synLinenum">   25</span>   <span class="synStatement">local</span> <span class="synStatement">our</span> <span class="synIdentifier">$op</span> = <span class="synConstant">''</span>;
<span class="synLinenum">   26</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   27</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   30</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   31</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   32</span>           )
<span class="synLinenum">   33</span> 
<span class="synLinenum">   34</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   35</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   36</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   37</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   38</span>           )
<span class="synLinenum">   39</span> 
<span class="synLinenum">   40</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   41</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   42</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   43</span>                         })
<span class="synLinenum">   44</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   45</span>                         (?{
<span class="synLinenum">   46</span>                             say <span class="synConstant">&quot;term-&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>;
<span class="synLinenum">   47</span>                         })
<span class="synLinenum">   48</span>           )
<span class="synLinenum">   49</span> 
<span class="synLinenum">   50</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*([*/])
<span class="synLinenum">   51</span>                              (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   52</span>                                 <span class="synStatement">local</span> <span class="synIdentifier">$op</span> = <span class="synIdentifier">$^</span>N;
<span class="synLinenum">   53</span>                              })
<span class="synLinenum">   54</span>                      ((?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   55</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   56</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N, <span class="synIdentifier">$op</span>
<span class="synLinenum">   57</span>                               })
<span class="synLinenum">   58</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   59</span>                              (?{
<span class="synLinenum">   60</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>
<span class="synLinenum">   61</span>                               })
<span class="synLinenum">   62</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   63</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   64</span>           )
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span>       )
<span class="synLinenum">   69</span>   }xms;
<span class="synLinenum">   70</span> 
<span class="synLinenum">   71</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   72</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   73</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   74</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   75</span>   }
<span class="synLinenum">   76</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   77</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   78</span>   }
</pre>

\end{rawhtml}
%}}}

Sigue una ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withactions3.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
\end{verbatim}

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante {\tt @-}}

Sigue una solución alternativa que obvia la necesidad de introducir
incómodas acciones intermedias. Utilizamos 
las variables \verb|@-| y \verb|@+|:
 
\begin{it}\begin{quotation}
Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.
\end{quotation}\end{it}

Véanse los párrafos en las páginas
\pageref{parrafo:fincas}, \pageref{parrafo:iniciocas}) y
\pageref{parrafo:lastpar} para mas información sobre \verb|@-| y \verb|@+|.

Nótese la función \verb|rc| en las líneas
21-28. \verb|rc(1)| nos retorna lo que casó con el último paréntesis,
\verb|rc(2)| lo que casó con el penúltimo, etc.


\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21    sub rc {
22      my $ofs = - shift;
23  
24      # Number of parenthesis that matched
25      my $np = @-;
26      #      string, ofsset, length
27      substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
28    }
29  
30    my $input;
31    my @stack;
32  
33    my $regexp = qr{
34        (?&exp)
35  
36        (?(DEFINE)
37            (?<exp>    (?&term) (?&re)
38                         (?{ say "exp -> term re" })
39            )
40  
41            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, rc(1) }) (?&re)
42                         (?{ say "re -> [+-] term re" })
43                     | # empty
44                         (?{ say "re -> empty" })
45            )
46  
47            (?<term>   ((?&digits))
48                          (?{ # intermediate action
49                              push @stack, rc(1)
50                          })
51                       (?&rt)
52                          (?{
53                              say "term-> digits(".rc(1).") rt";
54                          })
55            )
56  
57            (?<rt>     \s*([*/]) ((?&digits)) \s*
58                               (?{  # intermediate action
59                                    push @stack, rc(1), rc(2)
60                                })
61                       (?&rt) # end of <rt> definition
62                               (?{
63                                    say "rt -> [*/] digits(".rc(1).") rt"
64                                })
65                      |  # empty
66                         (?{ say "rt -> empty" })
67            )
68  
69            (?<digits>  \s* \d+
70            )
71        )
72    }xms;
73  
74    $input = <>;
75    chomp($input);
76    if ($input =~ $regexp) {
77      say "matches: $&\nStack=(@stack)";
78    }
79    else {
80      say "does not match";
81    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n calc510withactions4.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span> <span class="synIdentifier">  </span><span class="synStatement">sub</span><span class="synIdentifier"> rc </span>{
<span class="synLinenum">   22</span>     <span class="synStatement">my</span> <span class="synIdentifier">$ofs</span> = - <span class="synStatement">shift</span>;
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span>     <span class="synComment"># Number of parenthesis that matched</span>
<span class="synLinenum">   25</span>     <span class="synStatement">my</span> <span class="synIdentifier">$np</span> = @-;
<span class="synLinenum">   26</span>     <span class="synComment"># $_ contains the string being matched</span>
<span class="synLinenum">   27</span>     <span class="synStatement">substr</span>(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>], <span class="synIdentifier">$+</span>[<span class="synIdentifier">$np</span>+<span class="synIdentifier">$ofs</span>] - <span class="synIdentifier">$-</span>[<span class="synIdentifier">$ofs</span>])
<span class="synLinenum">   28</span>   }
<span class="synLinenum">   29</span> 
<span class="synLinenum">   30</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span>;
<span class="synLinenum">   31</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   34</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   35</span> 
<span class="synLinenum">   36</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   37</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   38</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   39</span>           )
<span class="synLinenum">   40</span> 
<span class="synLinenum">   41</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>) }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   42</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   43</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   44</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   48</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>)
<span class="synLinenum">   50</span>                         })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   52</span>                         (?{
<span class="synLinenum">   53</span>                             say <span class="synConstant">&quot;term-&gt; digits(&quot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">&quot;) rt&quot;</span>;
<span class="synLinenum">   54</span>                         })
<span class="synLinenum">   55</span>           )
<span class="synLinenum">   56</span> 
<span class="synLinenum">   57</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*([*/]) ((?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   58</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   59</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, rc(<span class="synConstant">1</span>), rc(<span class="synConstant">2</span>)
<span class="synLinenum">   60</span>                               })
<span class="synLinenum">   61</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   62</span>                              (?{
<span class="synLinenum">   63</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(&quot;</span>.rc(<span class="synConstant">1</span>).<span class="synConstant">&quot;) rt&quot;</span>
<span class="synLinenum">   64</span>                               })
<span class="synLinenum">   65</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   66</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   67</span>           )
<span class="synLinenum">   68</span> 
<span class="synLinenum">   69</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   70</span>           )
<span class="synLinenum">   71</span>       )
<span class="synLinenum">   72</span>   }xms;
<span class="synLinenum">   73</span> 
<span class="synLinenum">   74</span>   <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   75</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   76</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   77</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   78</span>   }
<span class="synLinenum">   79</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   80</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   81</span>   }
</pre>

\end{rawhtml}
%}}}

Ahora accedemos a los atributos asociados con los dos paréntesis,
en la regla de \verb|<rt>| usando la función \verb|rc|:

\begin{verbatim}
         (?<rt>     \s*([*/]) ((?&digits)) \s*
                            (?{  # intermediate action
                                 push @stack, rc(1), rc(2)
                             })
\end{verbatim}

Sigue una ejecución del programa:

\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withactions4.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
pl@nereida:~/Lperltesting$
\end{verbatim}

\parrafo{Accediendo a los atributos de paréntesis anteriores mediante paréntesis 
con nombre}

Una nueva solución: dar nombre a los paréntesis y acceder a los mismos:
\begin{verbatim}
47          (?<rt>     \s*(?<op>[*/]) (?<num>(?&digits)) \s*
48                             (?{  # intermediate action
49                                  push @stack, $+{num}, $+{op}
50                              })
\end{verbatim}

Sigue el código completo:

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
 1    #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2    use v5.10;
 3  
 4    # Infix to postfix translator using 5.10 regexp
 5    # Original grammar:
 6  
 7    #  exp ->   exp [-+] term
 8    #         | term
 9    #  term ->   term [*/] digits
10    #          | digits
11  
12    # Applying left-recursion elimination we have:
13  
14    #  exp  ->   term re
15    #  re   ->   [+-] term re
16    #          | # empty
17    #  term ->   digits rt
18    #  rt   ->   [*/] rt
19    #          | # empty
20  
21    my @stack;
22  
23    my $regexp = qr{
24        (?&exp)
25  
26        (?(DEFINE)
27            (?<exp>    (?&term) (?&re)
28                         (?{ say "exp -> term re" })
29            )
30  
31            (?<re>     \s* ([+-]) (?&term) \s* (?{ push @stack, $^N }) (?&re)
32                         (?{ say "re -> [+-] term re" })
33                     | # empty
34                         (?{ say "re -> empty" })
35            )
36  
37            (?<term>   ((?&digits))
38                          (?{ # intermediate action
39                              push @stack, $^N
40                          })
41                       (?&rt)
42                          (?{
43                              say "term-> digits($^N) rt";
44                          })
45            )
46  
47            (?<rt>     \s*(?<op>[*/]) (?<num>(?&digits)) \s*
48                               (?{  # intermediate action
49                                    push @stack, $+{num}, $+{op}
50                                })
51                       (?&rt) # end of <rt> definition
52                               (?{
53                                    say "rt -> [*/] digits($^N) rt"
54                                })
55                      |  # empty
56                         (?{ say "rt -> empty" })
57            )
58  
59            (?<digits>  \s* \d+
60            )
61        )
62    }xms;
63  
64    my $input = <>;
65    chomp($input);
66    if ($input =~ $regexp) {
67      say "matches: $&\nStack=(@stack)";
68    }
69    else {
70      say "does not match";
71    }
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lperltesting$ cat -n ./calc510withnamedpar.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/local/lib/perl/5.10.1/bin//perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use </span>v5.<span class="synConstant">10</span>;
<span class="synLinenum">    3</span> 
<span class="synLinenum">    4</span>   <span class="synComment"># Infix to postfix translator using 5.10 regexp</span>
<span class="synLinenum">    5</span>   <span class="synComment"># Original grammar:</span>
<span class="synLinenum">    6</span> 
<span class="synLinenum">    7</span>   <span class="synComment">#  exp -&gt;   exp [-+] term</span>
<span class="synLinenum">    8</span>   <span class="synComment">#         | term</span>
<span class="synLinenum">    9</span>   <span class="synComment">#  term -&gt;   term [*/] digits</span>
<span class="synLinenum">   10</span>   <span class="synComment">#          | digits</span>
<span class="synLinenum">   11</span> 
<span class="synLinenum">   12</span>   <span class="synComment"># Applying left-recursion elimination we have:</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span>   <span class="synComment">#  exp  -&gt;   term re</span>
<span class="synLinenum">   15</span>   <span class="synComment">#  re   -&gt;   [+-] term re</span>
<span class="synLinenum">   16</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   17</span>   <span class="synComment">#  term -&gt;   digits rt</span>
<span class="synLinenum">   18</span>   <span class="synComment">#  rt   -&gt;   [*/] rt</span>
<span class="synLinenum">   19</span>   <span class="synComment">#          | # empty</span>
<span class="synLinenum">   20</span> 
<span class="synLinenum">   21</span>   <span class="synStatement">my</span> <span class="synIdentifier">@stack</span>;
<span class="synLinenum">   22</span> 
<span class="synLinenum">   23</span>   <span class="synStatement">my</span> <span class="synIdentifier">$regexp</span> = <span class="synConstant">qr{</span>
<span class="synLinenum">   24</span> <span class="synConstant">      </span><span class="synSpecial">(?</span><span class="synConstant">&amp;exp</span><span class="synSpecial">)</span>
<span class="synLinenum">   25</span> 
<span class="synLinenum">   26</span> <span class="synConstant">      </span><span class="synSpecial">(?(</span><span class="synConstant">DEFINE</span><span class="synSpecial">)</span>
<span class="synLinenum">   27</span> <span class="synConstant">          </span><span class="synSpecial">(?</span><span class="synConstant">&lt;exp&gt;    </span><span class="synSpecial">(?</span><span class="synConstant">&amp;term</span><span class="synSpecial">)</span><span class="synConstant"> </span><span class="synSpecial">(?</span><span class="synConstant">&amp;re</span><span class="synSpecial">)</span>
<span class="synLinenum">   28</span> <span class="synConstant">                       </span><span class="synSpecial">(?</span><span class="synConstant">{ say &quot;exp -&gt; term re&quot; }</span>)
<span class="synLinenum">   29</span>           )
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span>           (?<span class="synIdentifier">&lt;re&gt;</span>     \s* ([+-]) (?<span class="synIdentifier">&amp;term</span>) \s* (?{ <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N }) (?<span class="synIdentifier">&amp;re</span>)
<span class="synLinenum">   32</span>                        (?{ say <span class="synConstant">&quot;re -&gt; [+-] term re&quot;</span> })
<span class="synLinenum">   33</span>                    | <span class="synComment"># empty</span>
<span class="synLinenum">   34</span>                        (?{ say <span class="synConstant">&quot;re -&gt; empty&quot;</span> })
<span class="synLinenum">   35</span>           )
<span class="synLinenum">   36</span> 
<span class="synLinenum">   37</span>           (?<span class="synIdentifier">&lt;term&gt;</span>   ((?<span class="synIdentifier">&amp;digits</span>))
<span class="synLinenum">   38</span>                         (?{ <span class="synComment"># intermediate action</span>
<span class="synLinenum">   39</span>                             <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$^</span>N
<span class="synLinenum">   40</span>                         })
<span class="synLinenum">   41</span>                      (?<span class="synIdentifier">&amp;rt</span>)
<span class="synLinenum">   42</span>                         (?{
<span class="synLinenum">   43</span>                             say <span class="synConstant">&quot;term-&gt; digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>;
<span class="synLinenum">   44</span>                         })
<span class="synLinenum">   45</span>           )
<span class="synLinenum">   46</span> 
<span class="synLinenum">   47</span>           (?<span class="synIdentifier">&lt;rt&gt;</span>     \s*(?<span class="synIdentifier">&lt;op&gt;</span>[*/]) (?<span class="synIdentifier">&lt;num&gt;</span>(?<span class="synIdentifier">&amp;digits</span>)) \s*
<span class="synLinenum">   48</span>                              (?{  <span class="synComment"># intermediate action</span>
<span class="synLinenum">   49</span>                                   <span class="synStatement">push</span> <span class="synIdentifier">@stack</span>, <span class="synIdentifier">$+</span>{num}, <span class="synIdentifier">$+</span>{op}
<span class="synLinenum">   50</span>                               })
<span class="synLinenum">   51</span>                      (?<span class="synIdentifier">&amp;rt</span>) <span class="synComment"># end of &lt;rt&gt; definition</span>
<span class="synLinenum">   52</span>                              (?{
<span class="synLinenum">   53</span>                                   say <span class="synConstant">&quot;rt -&gt; [*/] digits(</span><span class="synIdentifier">$^</span><span class="synConstant">N) rt&quot;</span>
<span class="synLinenum">   54</span>                               })
<span class="synLinenum">   55</span>                     |  <span class="synComment"># empty</span>
<span class="synLinenum">   56</span>                        (?{ say <span class="synConstant">&quot;rt -&gt; empty&quot;</span> })
<span class="synLinenum">   57</span>           )
<span class="synLinenum">   58</span> 
<span class="synLinenum">   59</span>           (?<span class="synIdentifier">&lt;digits&gt;</span>  \s* \d+
<span class="synLinenum">   60</span>           )
<span class="synLinenum">   61</span>       )
<span class="synLinenum">   62</span>   }xms;
<span class="synLinenum">   63</span> 
<span class="synLinenum">   64</span>   <span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;;
<span class="synLinenum">   65</span>   <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   66</span>   <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synIdentifier">$regexp</span>) {
<span class="synLinenum">   67</span>     say <span class="synConstant">&quot;matches: </span><span class="synIdentifier">$&amp;</span><span class="synSpecial">\n</span><span class="synConstant">Stack=(</span><span class="synIdentifier">@stack</span><span class="synConstant">)&quot;</span>;
<span class="synLinenum">   68</span>   }
<span class="synLinenum">   69</span>   <span class="synStatement">else</span> {
<span class="synLinenum">   70</span>     say <span class="synConstant">&quot;does not match&quot;</span>;
<span class="synLinenum">   71</span>   }
</pre>

\end{rawhtml}
%}}}

Ejecución:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./calc510withnamedpar.pl
5-8/4/2-1
rt -> empty
term-> digits(5) rt
rt -> empty
rt -> [*/] digits(2) rt
rt -> [*/] digits(4) rt
term-> digits(8) rt
rt -> empty
term-> digits(1) rt
re -> empty
re -> [+-] term re
re -> [+-] term re
exp -> term re
matches: 5-8/4/2-1
Stack=(5 8 4 / 2 / - 1 -)
\end{verbatim}


\parrafo{Véase También}
\begin{itemize}
\item
El nodo {\it Backreference variables in code embedded inside Perl 5.10 regexps} en 
\perlmonk{794424}

\item
El nodo {\it Strange behavior of @- and @+ in perl5.10 regexps} en 
\perlmonk{794736}

\end{itemize}


\subsection{Construyendo el AST con Expresiones Regulares 5.10}

Construiremos en esta sección un traductor de infijo a postfijo
utilizando una aproximación general: construiremos una representación
del Abstract Syntax Tree o AST (véase la sección 
\ref{section:aat}
Árbol de Análisis Abstracto para una definición detallada de que es un árbol sintáctico).

Como la aplicación es un poco mas compleja la hemos dividido en varios ficheros.
Esta es la estructura:

\begin{verbatim}
.
|-- ASTandtrans3.pl    # programa principal
|-- BinaryOp.pm        # clases para el manejo de los nodos del AST
|-- testreegxpparen.pl # prueba para Regexp::Paren
`-- Regexp
    `-- Paren.pm       # módulo de extensión de $^N
\end{verbatim}


La salida del programa puede ser dividida en tres partes.
La primera muestra una antiderivación a derechas inversa:
\begin{verbatim}
pl@nereida:~/Lperltesting$ ./ASTandtrans3.pl
2*(3-4)
factor -> NUM(2)
factor -> NUM(3)
rt -> empty
term-> factor rt
factor -> NUM(4)
rt -> empty
term-> factor rt
re -> empty
re -> [+-] term re
exp -> term re
factor -> ( exp )
rt -> empty
rt -> [*/] factor rt
term-> factor rt
re -> empty
exp -> term re
matches: 2*(3-4)
\end{verbatim}
Que leída de abajo a arriba nos da una derivación a derechas de la cadena \verb|2*(3-4)|:
\begin{verbatim}
exp => term re => term => factor rt => 
factor [*/](*) factor rt => factor [*/](*) factor => 
factor [*/](*) ( exp ) => factor [*/](*) ( term re ) =>  
factor [*/](*) ( term [+-](-) term re ) =>  
factor [*/](*) ( term [+-](-) term ) => 
factor [*/](*) ( term [+-](-) factor rt ) =>
factor [*/](*) ( term [+-](-) factor ) => 
factor [*/](*) ( term [+-](-) NUM(4) ) =>
factor [*/](*) ( factor rt [+-](-) NUM(4) ) => 
factor [*/](*) ( factor [+-](-) NUM(4) ) =>
factor [*/](*) ( NUM(3) [+-](-) NUM(4) )  => 
NUM(2) [*/](*) ( NUM(3) [+-](-) NUM(4) )
\end{verbatim}
La segunda parte nos muestra la representación del AST para la entrada dada (\verb|2*(3-4)|):
\begin{tabular}{|p{5cm}|p{4cm}|}
\begin{verbatim}
AST:
$VAR1 = bless( {
  'left' => bless( { 'val' => '2' }, 'NUM' ),
  'right' => bless( {
    'left' => bless( { 'val' => '3' }, 'NUM' ),
    'right' => bless( { 'val' => '4' }, 'NUM' ),
    'op' => '-'
  }, 'ADD' ),
  'op' => '*'
}, 'MULT' );
\end{verbatim}
&
\begin{rawhtml}
<img src="ast234.png" alt="MUL(2,ADD(3,4))" height=200>
\end{rawhtml}
\end{tabular}

La última parte de la salida nos muestra la traducción a postfijo
de la expresión en infijo
suministrada en la entrada (\verb|2*(3-4)|):
\begin{verbatim}
2 3 4 - *
\end{verbatim}

\parrafo{Programa Principal: usando la pila de atributos}

La gramática original que consideramos
es recursiva a izquierdas:
\begin{verbatim}
 exp    ->   exp [-+] term
           | term
 term   ->   term [*/] factor
           | factor
 factor ->  \( exp \)
           | \d+
\end{verbatim}
aplicando las técnicas explicadas en
\ref{subsection:eliminarecesquem}
es posible transformar la gramática 
en una no recursiva por la izquierda:
\begin{verbatim}
 exp       ->   term restoexp
 restoexp  ->   [-+] term restoexp
              | # vacío
 term      ->   term restoterm
 restoterm ->   [*/] factor restoterm
              | # vacío
 factor    ->   \( exp \)
              | \d+
\end{verbatim}

Ahora bien, no basta con transformar la gramática en una equivalente.
Lo que tenemos como punto de partida no es una gramática sino un \cei{esquema de traducción}
(véase la sección 
\ref{section:esquemas})
que construye el AST asociado con la expresión.
Nuestro esquema de traducción conceptual es algo así:
\begin{verbatim}
 exp    ->   exp ([-+]) term       { ADD->new(left => $exp, right => $term, op => $1) }
           | term                  { $term }
 term   ->   term ([*/]) factor    { MULT->new(left => $exp, right => $term, op => $1) } 
           | factor                { $factor }
 factor ->  \( exp \)              { $exp }
           | (\d+)                 { NUM->new(val => $1) }
\end{verbatim}

Lo que queremos conseguir un conjunto de acciones semánticas
asociadas para gramática no recursiva que sea equivalente 
a este.

Este es el programa resultante una vez aplicadas las transformaciones.
La implementación de la asociación entre símbolos y atributos la realizamos
manualmente mediante una pila de atributos:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n ./ASTandtrans3.pl
 1  #!/usr/local/lib/perl/5.10.1/bin//perl5.10.1
 2  use v5.10;
 3  use strict;
 4  use Regexp::Paren qw{g};
 5  use BinaryOp;
 6
 7  use Data::Dumper;
 8  $Data::Dumper::Indent = 1;
 9
10  # Builds AST
11  my @stack;
12  my $regexp = qr{
13      (?&exp)
14
15      (?(DEFINE)
16          (?<exp>    (?&term) (?&re)
17                       (?{ say "exp -> term re" })
18          )
19
20          (?<re>     \s* ([+-]) (?&term)
21                        (?{  # intermediate action
22                            local our ($ch1, $term) = splice @stack, -2;
23
24                            push @stack, ADD->new( {left => $ch1, right => $term, op => g(1)});
25                        })
26                     (?&re)
27                       (?{ say "re -> [+-] term re" })
28                   | # empty
29                       (?{ say "re -> empty" })
30          )
31
32          (?<term>   ((?&factor)) (?&rt)
33                        (?{
34                            say "term-> factor rt";
35                        })
36          )
37
38          (?<rt>     \s*([*/]) (?&factor)
39                         (?{  # intermediate action
40                              local our ($ch1, $ch2) = splice @stack, -2;
41
42                              push @stack, MULT->new({left => $ch1, right => $ch2, op => g(1)});
43                          })
44                     (?&rt) # end of <rt> definition
45                         (?{
46                              say "rt -> [*/] factor rt"
47                          })
48                   | # empty
49                         (?{ say "rt -> empty" })
50          )
51
52          (?<factor> \s* (\d+)
53                          (?{
54                             say "factor -> NUM($^N)";
55                             push @stack, bless { 'val' => g(1) }, 'NUM';
56                          })
57                     | \s* \( (?&exp) \s* \)
58                          (?{ say "factor -> ( exp )" })
59          )
60      )
61  }xms;
62
63  my $input = <>;
64  chomp($input);
65  if ($input =~ $regexp) {
66    say "matches: $&";
67    my $ast = pop @stack;
68    say "AST:\n", Dumper $ast;
69
70    say $ast->translate;
71  }
72  else {
73    say "does not match";
74  }
\end{verbatim}

\parrafo{Las Clases representando a los AST}

Cada nodo del AST es un objeto. La clase del nodo nos dice que tipo de nodo es.
Así los nodos de la clase \verb|MULT| agrupan a los nódos de multiplicación y división.
Los nodos de la clase \verb|ADD| agrupan a los nódos de suma y resta.
El procedimiento general es asociar un método \verb|translate| con cada clase de nodo.
De esta forma se logra el polimorfismo necesario: cada clase de nodo sabe como traducirse
y el método \verb|translate| de cada clase puede escribirse como
\begin{itemize}
\item Obtener los resultados de llamar a \verb|$child->translate| para cada uno
de los nodos hijos \verb|$child|. Por ejemplo, si el nodo fuera un nodo \verb|IF_ELSE|
de un hipotético lenguaje de programación, se llamaría a los métodos \verb|translate| sobre sus tres hijos
\verb|boolexpr|, \verb|ifstatement| y \verb|elsestatement|.
\item Combinar los resultados para producir la traducción adecuada del nodo actual.
\end{itemize}
Es esta combinación la que mas puede cambiar según el tipo de nodo. Así, en el caso de 
el nodo \verb|IF_ELSE| el seudocódigo para la traducción sería algo parecido a esto:

\begin{verbatim}
my $self = shift;
my $etiqueta1 = generar_nueva_etiqueta;
my $etiqueta2 = generar_nueva_etiqueta;

my $boolexpr      = $self->boolexpr->translate;
my $ifstatement   = $self->ifstatement->translate,  
my $elsestatement = $self->elsestatement->translate, 
return << "ENDTRANS";
    $boolexpr
    JUMPZERO $etiqueta1:
    $ifstatement
    JUMP     $etiqueta2:
  $etiqueta1:
    $elsestatement
  $etiqueta2:
ENDTRANS
\end{verbatim}

Siguiendo estas observaciones el código de \verb|BinaryOp.pm| queda así:
\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n BinaryOp.pm
 1  package BinaryOp;
 2  use strict;
 3  use base qw(Class::Accessor);
 4
 5  BinaryOp->mk_accessors(qw{left right op});
 6
 7  sub translate {
 8    my $self = shift;
 9
10    return $self->left->translate." ".$self->right->translate." ".$self->op;
11  }
12
13  package ADD;
14  use base qw{BinaryOp};
15
16  package MULT;
17  use base qw{BinaryOp};
18
19  package NUM;
20
21  sub translate {
22    my $self = shift;
23
24    return $self->{val};
25  }
26
27  1;
\end{verbatim}

Véase también:
\begin{itemize}
\item \cpan{Class::Accessor}
\end{itemize}

\parrafo{Accediendo a los paréntesis lejanos: El módulo {\tt Regexp::Paren}}

En esta solución utilizamos 
las variables \verb|@-| y \verb|@+| para construir una función que nos 
permite acceder a lo que casó con 
los últimos paréntesis con memoria:
 
\begin{it}\begin{quotation}
Since Perl 5.6.1 the special variables \verb|@-| and \verb|@+| can functionally replace
\verb|$`|, \verb|$&| and \verb|$'|. These arrays contain pointers to the beginning and end of
each match (see \perldoc{perlvar} for the full story), so they give you essentially
the same information, but without the risk of excessive string copying.
\end{quotation}\end{it}

Véanse los párrafos en las páginas
\pageref{parrafo:fincas}, \pageref{parrafo:iniciocas}) y
\pageref{parrafo:lastpar} para mas información sobre \verb|@-| y \verb|@+|.

\verb|g(1)| nos retorna lo que casó con el último paréntesis,
\verb|g(2)| lo que casó con el penúltimo, etc.

\begin{verbatim}
pl@nereida:~/Lperltesting$ cat -n Regexp/Paren.pm
 1  package Regexp::Paren;
 2  use strict;
 3
 4  use base qw{Exporter};
 5
 6  our @EXPORT_OK = qw{g};
 7
 8  sub g {
 9    die "Error in 'Regexp::Paren::g'. Not used inside (?{ code }) construct\n" unless defined($_);
10    my $ofs = - shift;
11
12    # Number of parenthesis that matched
13    my $np = @-;
14    die "Error. Illegal 'Regexp::Paren::g' ref inside (?{ code }) construct\n" unless ($np > - $ofs && $ofs < 0);
15    # $_ contains the string being matched
16    substr($_, $-[$ofs], $+[$np+$ofs] - $-[$ofs])
17  }
18
19  1;
20
21  =head1 NAME
22
23  Regexp::Paren - Extends $^N inside (?{ ... }) constructs
24
25  =head1 SYNOPSIS
26
27    use Regexp::Paren qw{g};
28
29    'abcde' =~ qr{(.)(.)(.)
30                         (?{ print g(1)." ".g(2)." ".g(3)."\n" })                   # c b a
31                 (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)."\n" })          # d c b a
32                 (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n" }) # e d c b a
33                }x;
34
35    print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n"; # error!
36
37  =head1 DESCRIPTION
38
39  Inside a C<(?{ ... })> construct, C<g(1)> refers to what matched the last parenthesis
40  (like C<$^N>), C<g(2)> refers to the string that matched with the parenthesis before
41  the last, C<g(3)> refers to the string that matched with the parenthesis at distance 3,
42  etc.
43
44  =head1 SEE ALSO
45
46  =over 2
47
48  =item * L<perlre>
49
50  =item * L<perlretut>
51
52  =item * PerlMonks node I<Strange behavior o> C<@-> I<and> C<@+> I<in perl5.10 regexps> L<http://www.perlmonks.org/?node_id=794736>
53
54  =item * PerlMonks node I<Backreference variables in code embedded inside Perl 5.10 regexps> L<http://www.perlmonks.org/?node_id=794424>
55
56  =back
57
58  =head1 AUTHOR
59
60  Casiano Rodriguez-Leon (casiano@ull.es)
61
62  =head1 ACKNOWLEDGMENTS
63
64  This work has been supported by CEE (FEDER) and the Spanish Ministry of
65  I<Educacion y Ciencia> through I<Plan Nacional I+D+I> number TIN2005-08818-C04-04
66  (ULL::OPLINK project L<http://www.oplink.ull.es/>).
67  Support from Gobierno de Canarias was through GC02210601
68  (I<Grupos Consolidados>).
69  The University of La Laguna has also supported my work in many ways
70  and for many years.
71
72  =head1 LICENCE AND COPYRIGHT
73
74  Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
75
76  These modules are free software; you can redistribute it and/or
77  modify it under the same terms as Perl itself. See L<perlartistic>.
78
79  This program is distributed in the hope that it will be useful,
80  but WITHOUT ANY WARRANTY; without even the implied warranty of
81  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{verbatim}

Al ejecutar \verb|perldoc Regexp::Paren| podemos ver la documentación
incluida (véase la documentación en \perldoc{perlpod} y \perldoc{perlpodspec}
así como la sección \gnereida{La Documentación en Perl} 
para mas detalles):

\begin{tabular}{|p{22cm}|}
\hline
\begin{verbatim}
NAME
    Regexp::Paren - Extends $^N inside (?{ ... }) constructs

SYNOPSIS
      use Regexp::Paren qw{g};

      'abcde' =~ qr{(.)(.)(.)
                           (?{ print g(1)." ".g(2)." ".g(3)."\n" })                   # c b a
                   (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)."\n" })          # d c b a
                   (.)     (?{ print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n" }) # e d c b a
                  }x;

      print g(1)." ".g(2)." ".g(3)." ".g(4)." ".g(5)."\n"; # error!

DESCRIPTION
    Inside a "(?{ ... })" construct, g(1) refers to what matched the last
    parenthesis (like $^N), g(2) refers to the string that matched with the
    parenthesis before the last, g(3) refers to the string that matched with
    the parenthesis at distance 3, etc.

SEE ALSO
    * perlre
    * perlretut
    * PerlMonks node *Strange behavior o* "@-" *and* "@+" *in perl5.10
      regexps* <http://www.perlmonks.org/?node_id=794736>
    * PerlMonks node *Backreference variables in code embedded inside Perl
      5.10 regexps* <http://www.perlmonks.org/?node_id=794424>

AUTHOR
    Casiano Rodriguez-Leon (casiano@ull.es)

ACKNOWLEDGMENTS
    This work has been supported by CEE (FEDER) and the Spanish Ministry of
    *Educacion y Ciencia* through *Plan Nacional I+D+I* number
    TIN2005-08818-C04-04 (ULL::OPLINK project <http://www.oplink.ull.es/>).
    Support from Gobierno de Canarias was through GC02210601 (*Grupos
    Consolidados*). The University of La Laguna has also supported my work
    in many ways and for many years.

LICENCE AND COPYRIGHT
    Copyright (c) 2009- Casiano Rodriguez-Leon (casiano@ull.es). All rights

\end{verbatim}\\
\hline
\end{tabular}

\sectionpractica{Traducción de {\tt invitation} a {\tt HTML}}

Esta práctica es continuación
de la práctica {\it un lenguaje para componer invitaciones}
especificada en la sección
\ref{practica:invitaciones}.

El objetivo es traducir la entrada escrita en el lenguaje de invitaciones
a HTML. La traducción del ejemplo anterior debería ser parecida a esta:
\begin{tabular}{|p{12cm}|p{12cm}|}
\hline
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invitation.xml
 1  <?xml version="1.0"?>
 2  <!DOCTYPE invitation SYSTEM "invitation.dtd">
 3  <invitation>
 4  <!-- ++++ The header part of the document ++++ -->
 5  <front>
 6  <to>Anna, Bernard, Didier, Johanna</to>
 7  <date>Next Friday Evening at 8 pm</date>
 8  <where>The Web Cafe</where>
 9  <why>My first XML baby</why>
10  </front>
11  <!-- +++++ The main part of the document +++++ -->
12  <body>
13  <par>
14  I would like to invite you all to celebrate
15  the birth of <emph>Invitation</emph>, my
16  first XML document child.
17  </par>
18  <par>
19  Please do your best to come and join me next Friday
20  evening. And, do not forget to bring your friends.
21  </par>
22  <par>
23  I <emph>really</emph> look forward to see you soon!
24  </par>
25  </body>
26  <!-- +++ The closing part of the document ++++ -->
27  <back>
28  <signature>Michel</signature>
29  </back>
30  </invitation>
\end{verbatim}
&
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat invcss.html.save
<HTML>
<HEAD>
<TITLE> Invitation (sgmlpl/CSS formatting) </TITLE>
<LINK href="invit.css" rel="style-sheet" type="text/css">
<!-- 24 August 1998 mg -->
</HEAD>
<BODY>
<H1>INVITATION</H1>
<P><TABLE>
<TBODY>
<TR><TD class="front">To: </TD>
<TD>Anna, Bernard, Didier, Johanna</TD></TR>
<TR><TD class="front">When: </TD>
<TD>Next Friday Evening at 8 pm</TD></TR>
<TR><TD class="front">Venue: </TD>
<TD>The Web Cafe</TD></TR>
<TR><TD class="front">Occasion: </TD>
<TD>My first XML baby</TD></TR>
</TBODY>
</TABLE>
<P>
I would like to invite you all to celebrate
the birth of <EM>Invitation</EM>, my
first XML document child.
</P>
<P>
Please do your best to come and join me next Friday
evening. And, do not forget to bring your friends.
</P>
<P>
I <EM>really</EM> look forward to see you soon!
</P>
<P CLASS="signature">Michel</P>
</BODY>
</HTML>
\end{verbatim}\\
\hline
\end{tabular}
Para ver el resultado en su navegador visite el fichero
\htmladdnormallink{invitation.html}{invitation.html}

Su programa deberá producir un Abstract Syntax Tree.
Los nodos serán objetos. Cada clase (\verb|FRONT|, \verb|TO|, etc.)
deberá de disponer de un método \verb|translate|.

Para simplificar el proceso de traducción a \verb|HTML| se sugiere  utilizar una 
hoja de estilo parecida a la siguiente (tomada de la seción 7.4.4 del citado libro de Goosens):
\begin{verbatim}
pl@nereida:~/Lpl0910/Practicas/161009/src$ cat -n invit.css
 1  /* CSS stylesheet for invitation1 in HTML */
 2  BODY {margin-top: 1em;     /* global page parameters */
 3        margin-bottom: 1em;
 4        margin-left: 1em;
 5        margin-right: 1em;
 6        font-family: serif;
 7        line-height: 1.1;
 8        color: black;
 9  }
10  H1   {text-align: center;  /* for global title   */
11        font-size: x-large;
12  }
13  P    {text-align: justify; /* paragraphs in body */
14        margin-top: 1em;
15  }
16  TABLE { border-width: 0pt }
17  TBODY { border-width: 0pt }
18  TD[class="front"] {        /* table data in front matter */
19        text-align: left;
20        font-weight: bold;
21  }
22  TD.front {        /* table data in front matter */
23        text-align: left;
24        font-weight: bold;
25  }
26  EM   {font-style: italic;  /* emphasis in body   */
27  }
28  P.signature {     /* signature          */
29        text-align: right;
30        font-weight: bold;
31  }
\end{verbatim}

Véase también:

\begin{itemize}
\item
\htmladdnormallink{The LaTex Web Companion}{http://books.google.es/books?id=B93uJGLZhAoC\&lpg=PP1\&ots=-JFhDfZPwN\&dq=The\%20LaTEX\%20web\%20companion\&hl=en\&pg=PP1\#v=onepage\&q=\&f=false}
\item
\htmladdnormallink{Examples from The LaTeX Web Companion}{http://www.ctan.org/tex-archive/info/examples/lwc/} (véanse los subdirectorios
correspondietnes a los capítulos 6 y 7)
\item
\htmladdnormallink{CSS Tutorial}{http://www.w3schools.com/css/}
\item
\htmladdnormallink{Edición extremadamente simple de HTML}{http://www.psicobyte.com/html/index.html}
\item
\htmladdnormallink{Perl-XML Frequently Asked Questions}{http://perl-xml.sourceforge.net/faq/}
\end{itemize}


\section{Análisis Sintáctico con {\tt Regexp::Grammars}}

El módulo \cpan{Regexp::Grammars} escrito por \wikip{Damian Conway}{Damian\_Conway} extiende
las expresiones regulares Perl con 
la capacidad de generar representaciones del árbol 
de análisis sintáctico abstracto y obviando la necesidad 
de explicitar los blancos. El módulo necesita para funcionar una versión de Perl superior
o igual a la 5.10. 

\subsection{Introducción}

\parrafo{El Problema}

La documentación de \regexpg{} establece cual es el problema que aborda 
el módulo:
\begin{it}\begin{quotation}
\ldots Perl5.10 makes possible to use regexes to recognize complex,
hierarchical--and even recursive--textual structures. The problem is that
Perl 5.10 doesn’t provide any support for extracting that
hierarchical data into nested data structures. In other words,
using Perl 5.10 you can match complex data, but not parse it into an internally useful form.

An additional problem when using Perl 5.10 regexes to match
complex data formats is that you have to make sure you remember
to insert whitespace- matching constructs (such as \verb"\s*") at every
possible position where the data might contain ignorable whitespace. This
reduces the readability of such patterns, and increases the chance of
errors (typically caused by overlooking a location where whitespace
might appear).

\parrafo{Una solución: {\tt Regexp::Grammars}}

The \regexpg{} module solves both those problems.

If you import the module into a particular lexical scope, it preprocesses
any regex in that scope, so as to implement a number of extensions to the
standard Perl 5.10 regex syntax. These extensions simplify the task of
defining and calling subrules within a grammar, and allow those subrule
calls to capture and retain the components of they match in a proper
hierarchical manner.

\end{quotation}\end{it}

\parrafo{La sintaxis de una expresión regular {\tt Regexp::Grammars}}

Las expresiones regulares \regexpg{} aumentan las regexp Perl 5.10. La sintáxis
se expande y se modifica:

\begin{it}\begin{quotation}
A \regexpg{} specification consists of a pattern (which may include both standard Perl 5.10 regex syntax, as well as special
\cpan{Regexp::Grammars} directives), followed by one or more rule or token definitions.
\end{quotation}\end{it}

Sigue un ejemplo:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n balanced_brackets.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        (<pp>)
    10
    11        <rule: pp>   \( (?: [^()]*+ | <escape> | <pp> )* \)
    12
    13        <token: escape> \\.
    14
    15      }xs;
    16  };
    17
    18  while (my $input = <>) {
    19      while ($input =~ m{$rbb}g) {
    20          say("matches: <$&>");
    21          say Dumper \%/;
    22      }
    23  }
\end{verbatim}

\begin{it}\begin{quote}
Note that there is no need to explicitly place \verb"\s*" 
subpatterns throughout the rules; that is taken care of automatically.

\ldots

The initial pattern (\verb|(<pp>)|) acts like the \emph{top} rule of the grammar, and must
be matched completely for the grammar to match.

The rules and tokens are declarations only and they are not directly
matched.  Instead, they act like subroutines, and are invoked by name
from the initial pattern (or from within a rule or token).

Each rule or token extends from the directive that introduces it up to
either the next rule or token directive, or (in the case of the final
rule or token) to the end of the grammar.  

\end{quote}\end{it}

\parrafo{El hash {\tt  \%/}: Una representación del AST}
Al ejecutar el programa anterior con entrada \verb|(2*(3+5))*4+(2-3)| produce:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 balanced_brackets.pl
(2*(3+5))*4+(2-3)
matches: <(2*(3+5))>
$VAR1 = {
          '' => '(2*(3+5))',
          'pp' => {
                    '' => '(2*(3+5))',
                    'pp' => '(3+5)'
                  }
        };

matches: <(2-3)>
$VAR1 = {
          '' => '(2-3)',
          'pp' => '(2-3)'
        };
\end{verbatim}


\begin{it}\begin{quotation}
Each rule calls the
subrules specified within it, and then return a hash containing whatever
result each of those subrules returned, with each result indexed by the
subrule’s name.

In this way, each level of the hierarchical regex can generate hashes
recording everything its own subrules matched, so when the entire pattern
matches, it produces a tree of nested hashes that represent the structured
data the pattern matched.

\ldots

In addition each result-hash has one extra key: the empty string. The
value for this key is whatever string the entire subrule call matched.
\end{quotation}\end{it}

\parrafo{Diferencias entre {\tt token} y {\tt rule}}

\begin{it}\begin{quotation}
The difference between a token and a rule is that a token treats any
whitespace within it exactly as a normal Perl regular expression would.
That is, a sequence of whitespace in a token is ignored if the \verb"/x"
modifier is in effect, or else matches the same literal sequence of
whitespace characters (if \verb"/x" is not in effect).

\end{quotation}\end{it}

En el ejemplo anterior el comportamiento es el mismo si se reescribe la regla 
para el token \verb|escape| como:
\begin{verbatim}
    13        <rule: escape> \\.
\end{verbatim}
En este otro ejemplo mostramos que la diferencia entre token y rule
es significativa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsrule.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        <s>
    10
    11        <rule: s> <a> <c>
    12
    13        <rule: c>  c d
    14
    15        <token: a>  a b
    16
    17      }xs;
    18  };
    19
    20  while (my $input = <>) {
    21      if ($input =~ m{$rbb}) {
    22          say("matches: <$&>");
    23          say Dumper \%/;
    24      }
    25      else {
    26          say "Does not match";
    27      }
    28  }
\end{verbatim}

Al ejecutar este programa vemos la diferencia en la interpretación de los blancos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 tokenvsrule.pl
ab c d
matches: <ab c d>
$VAR1 = {
          '' => 'ab c d',
          's' => {
                   '' => 'ab c d',
                   'c' => 'c d',
                   'a' => 'ab'
                 }
        };

a b c d
Does not match
ab cd
matches: <ab cd>
$VAR1 = {
          '' => 'ab cd',
          's' => {
                   '' => 'ab cd',
                   'c' => 'cd',
                   'a' => 'ab'
                 }
        };
\end{verbatim}
Obsérvese como la entrada \verb|a b c d| es rechazada mientras
que la entrada \verb|ab c d| es aceptada.

\parrafo{Redefinición de los espacios en blanco}

\begin{it}\begin{quotation}
In a rule, any sequence of whitespace (except those at the very start
and the very end of the rule) is treated as matching the implicit subrule
\verb"<.ws>", which is automatically predefined to match optional whitespace 
(i.e. \verb"\s*").

You can explicitly define a \verb"<ws>" token to change that default
behaviour. For example, you could alter the definition of whitespace
to include Perlish comments, by adding an explicit \verb"<token: ws>":

\begin{verbatim}
                      <token: ws>
                         (?: \s+ | #[^\n]* )*
\end{verbatim}

But be careful not to define \verb"<ws>" as a rule, as this will lead
to all kinds of infinitely recursive unpleasantness.
\end{quotation}\end{it}
El siguiente ejemplo ilustra como redefinir \verb|<ws>|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n tokenvsruleandws.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      no warnings 'uninitialized';
 9      qr{
10        <s>
11
12        <token: ws> (?: \s+ | /\* .*? \*/)*+
13
14        <rule: s> <a> <c>
15
16        <rule: c>  c d
17
18        <token: a>  a b
19
20      }xs;
21  };
22
23  while (my $input = <>) {
24      if ($input =~ m{$rbb}) {
25          say Dumper \%/;
26      }
27      else {
28          say "Does not match";
29      }
30  }
\end{verbatim}
Ahora podemos introducir comentarios en la entrada:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 -w tokenvsruleandws.pl
ab /* 1 */ c d
$VAR1 = {
          '' => 'ab /* 1 */ c d',
          's' => {
                   '' => 'ab /* 1 */ c d',
                   'c' => 'c d',
                   'a' => 'ab'
                 }
        };

\end{verbatim}

\parrafo{Llamando a las subreglas}

\begin{it}\begin{quotation}
To invoke a rule to match at any point, just enclose the rule’s name
in angle brackets (like in \wikip{Perl 6}{Perl\_6}). There must be no space between the
opening bracket and the rulename. For example:

\begin{verbatim}
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               <name>            # Call <rule: name>
               <options>?        # Call <rule: options> (it's okay if it fails)

               <rule: name>
                   # etc.
           }x;
\end{verbatim}

If you need to match a literal pattern that would otherwise look like a subrule call, just backslash-escape the leading angle:

\begin{verbatim}
           qr{
               file:             # Match literal sequence 'f' 'i' 'l' 'e' ':'
               \<name>           # Match literal sequence '<' 'n' 'a' 'm' 'e' '>'
               <options>?        # Call <rule: options> (it's okay if it fails)

               <rule: name>
                   # etc.
           }x;
\end{verbatim}
\end{quotation}\end{it}

El siguiente programa ilustra algunos puntos discutidos en la cita anterior:
\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n badbracket.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        (<pp>)
10
11        <rule: pp>   \( (?: <b  > | \< | < escape> | <pp> )* \)
12
13        <token: b  > b
14
15        <token: escape> \\.
16
17      }xs;
18  };
19
20  while (my $input = <>) {
21      while ($input =~ m{$rbb}g) {
22          say("matches: <$&>");
23          say Dumper \%/;
24      }
25  }
\end{verbatim}

Obsérvense los blancos en \verb|< escape>| y en \verb|<token: b  > b|.
Pese a ello el programa funciona:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ perl5.10.1 badbracket.pl
(\(\))
matches: <(\(\))>
$VAR1 = {
          '' => '(\\(\\))',
          'pp' => {
                    '' => '(\\(\\))',
                    'escape' => '\\)'
                  }
        };

(b)
matches: <(b)>
$VAR1 = {
          '' => '(b)',
          'pp' => {
                    '' => '(b)',
                    'b' => 'b'
                  }
        };

(<)
matches: <(<)>
$VAR1 = {
          '' => '(<)',
          'pp' => '(<)'
        };

(c)

casiano@millo:
\end{verbatim}

\parrafo{Eliminación del anidamiento de ramas unarias en {\tt \%/}}

\begin{it}\begin{quotation}
\ldots Note, however, that if the result-hash at any level contains only the
empty-string key (i.e. the subrule did not call any sub-subrules or
save any of their nested result-hashes), then the hash is {\it unpacked}
and just the matched substring itself if returned.

For example, if \verb|<rule: sentence>| had been defined:

\begin{verbatim}
    <rule: sentence>
        I see dead people
\end{verbatim}

then a successful call to the rule would only add:

\begin{verbatim}
    sentence => 'I see dead people'
\end{verbatim}

to the current result-hash.

This is a useful feature because it prevents a series of nested subrule
calls from producing very unwieldy data structures. For example, without
this automatic unpacking, even the simple earlier example:

\begin{verbatim}
    <rule: sentence>
        <noun> <verb> <object>
\end{verbatim}

would produce something needlessly complex, such as:

\begin{verbatim}
    sentence => {
        ""     => 'I saw a dog',
        noun   => {
            "" => 'I',
        },
        verb   => {
            "" => 'saw',
        },
        object => {
            ""      => 'a dog',
            article => {
                "" => 'a',
            },
            noun    => {
                "" => 'dog',
            },
        },
    }
\end{verbatim}
\end{quotation}\end{it}

El siguiente ejemplo ilustra este punto:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n unaryproductions.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        <s>
10
11        <rule: s> <noun> <verb> <object>
12
13        <token: noun> he | she | Peter | Jane
14
15        <token: verb> saw | sees
16
17        <token: object> a\s+dog | a\s+cat
18
19      }x;
20  };
21
22  while (my $input = <>) {
23      while ($input =~ m{$rbb}g) {
24          say("matches: <$&>");
25          say Dumper \%/;
26      }
27  }
\end{verbatim}

Sigue una ejecución del programa anterior:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 unaryproductions.pl
he saw a dog
matches: <he saw a dog>
$VAR1 = {
          '' => 'he saw a dog',
          's' => {
                   '' => 'he saw a dog',
                   'object' => 'a dog',
                   'verb' => 'saw',
                   'noun' => 'he'
                 }
        };

Jane sees a cat
matches: <Jane sees a cat>
$VAR1 = {
          '' => 'Jane sees a cat',
          's' => {
                   '' => 'Jane sees a cat',
                   'object' => 'a cat',
                   'verb' => 'sees',
                   'noun' => 'Jane'
                 }
        };


\end{verbatim}

\parrafo{Ámbito de uso de {\tt Regexp::Grammars}}

Cuando se usa \cpan{Regexp::Grammars} como parte de 
un programa que utiliza otras regexes hay que evitar 
que \cpan{Regexp::Grammars} procese las mismas. \cpan{Regexp::Grammars}
reescribe las expresiones regulares durante la fase de preproceso. Esta por ello 
presenta las mismas limitaciones que cualquier otra forma de 
'source filtering' (véase \perldoc{perlfilter}). Por ello es una buena idea declarar
la gramática en un bloque \verb|do| restringiendo de esta forma el ámbito de 
acción del módulo.

\begin{verbatim}
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 .          ........
28      }xms
29  };
\end{verbatim}

\subsection{Objetos}

\begin{it}\begin{quotation}
When a grammar has parsed successfully, the \verb|%/| variable will contain
a series of nested hashes (and possibly arrays) representing the
hierarchical structure of the parsed data.

Typically, the next step is to walk that tree, extracting or converting
or otherwise processing that information. If the tree has nodes of many
different types, it can be difficult to build a recursive subroutine
that can navigate it easily.

A much cleaner solution is possible if the nodes of the tree are proper
objects. In that case, you just define a \verb|trasnlate()| method
for each of the classes, and have every node call that method on each
of its children.  The chain of \verb|translate()| calls would cascade down the
nodes of the tree, each one invoking the appropriate \verb|translate()| method
according to the type of node encountered.

The only problem is that, by default, \cpan{Regexp::Grammars} returns a tree
of plain-old hashes, not \verb|Class::Whatever| objects. Fortunately, it's
easy to request that the result hashes be automatically blessed into
the appropriate classes, using the \verb|<objrule:...>| and \verb|<objtoken:...>|
directives.

These directives are identical to the \verb|<rule:...>| and \verb|<token:...>|
directives (respectively), except that the rule or token they create will
also bless the hash it normally returns, converting it to an object of
a class whose name is the same as the rule or token itself.

For example:

\begin{verbatim}
    <objrule: Element>
        # ...Defines a rule that can be called as <Element>
        # ...and which returns a hash-based Element object
\end{verbatim}

The \verb|IDENTIFIER| of the rule or token may also be fully qualified. In
such cases, the rule or token is defined using only the final \emph{short
name}, but the result object is blessed using the fully qualified \emph{long
name}. For example:

\begin{verbatim}
    <objrule: LaTeX::Element> 
        # ...Defines a rule that can be called as <Element>
        # ...and which returns a hash-based LaTeX::Element object
\end{verbatim}

This can be useful to ensure that returned objects don't collide with
other namespaces in your program.

Note that you can freely mix object-returning and plain-old-hash-returning
rules and tokens within a single grammar, though you have to be careful
not to subsequently try to call a method on any of the unblessed nodes.

\end{quotation}\end{it}

\subsection{Renombrando los resultados de una subregla}

\parrafo{Nombre de la regla versus Nombre del Resultado}
 
No siempre el nombre de la regla es el mas apropiado
para ser el nombre del resultado:

\begin{it}\begin{quotation}
It is not always convenient to have subrule results stored under the same
name as the rule itself. Rule names should be optimized for understanding
the behaviour of the parser, whereas result names should be optimized
for understanding the structure of the data. Often those two goals are
identical, but not always; sometimes rule names need to describe what the
data looks like, while result names need to describe what the data means.
\end{quotation}\end{it}

\parrafo{Colisión de nombres de reglas}

\begin{it}\begin{quotation}
For example, sometimes you need to call the same rule twice, to match two
syntactically identical components whose positions give then semantically
distinct meanings:

\begin{verbatim}
    <rule: copy_cmd>
        copy <file> <file>
\end{verbatim}

The problem here is that, if the second call to \verb|<file>| succeeds, its
result-hash will be stored under the key \verb'file', clobbering the data
that was returned from the first call to \verb|<file>|.
\end{quotation}\end{it}

\parrafo{Aliasing}

\begin{it}\begin{quotation}
To avoid such problems, \cpan{Regexp::Grammars} allows you to alias any
subrule call, so that it is still invoked by the original name, but its
result-hash is stored under a different key. The syntax for that is:
\verb|<alias=rulename>|. For example:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file> <to=file>
\end{verbatim}

Here, \verb|<rule: file>| is called twice, with the first result-hash
being stored under the key \verb'from', and the second result-hash being
stored under the key \verb'to'.

Note, however, that the alias before the \verb|=| must be a proper identifier
(i.e. a letter or underscore, followed by letters, digits, and/or
underscores). Aliases that start with an underscore and aliases named
\verb|MATCH| have special meaning.
\end{quotation}\end{it}

\parrafo{Normalización de los resultados mediante aliasing}

\begin{it}\begin{quotation}
Aliases can also be useful for normalizing data that may appear in
different formats and sequences. For example:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>
      | dup    <to=file>  as  <from=file>
      |      <from=file>  ->    <to=file>
      |        <to=file>  <-  <from=file>

\end{verbatim}

Here, regardless of which order the old and new files are specified,
the result-hash always gets:

\begin{verbatim}
    copy_cmd => {
        from => 'oldfile',
          to => 'newfile',
    }
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Ejemplo}

El siguiente programa ilustra los comentarios de la documentación:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n copygrammar.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8      qr{
     9        <copy_cmd>
    10
    11        <rule: copy_cmd>
    12              copy <from=file> <to=file>
    13          |   <from=file> ->   <to=file>
    14          |   <to=file>   <- <from=file>
    15
    16        <token: file> [\w./\\]+
    17      }x;
    18  };
    19
    20  while (my $input = <>) {
    21      while ($input =~ m{$rbb}g) {
    22          say("matches: <$&>");
    23          say Dumper \%/;
    24      }
    25  }
\end{verbatim}
Cuando lo ejecutamos obtenemos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 copygrammar.pl
copy a b
matches: <copy a b>
$VAR1 = {
          '' => 'copy a b',
          'copy_cmd' => {
                          '' => 'copy a b',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };

b <- a
matches: <b <- a>
$VAR1 = {
          '' => 'b <- a',
          'copy_cmd' => {
                          '' => 'b <- a',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };

a -> b
matches: <a -> b>
$VAR1 = {
          '' => 'a -> b',
          'copy_cmd' => {
                          '' => 'a -> b',
                          'to' => 'b',
                          'from' => 'a'
                        }
        };
\end{verbatim}

\subsection{Listas}


\parrafo{El operador de cierre positivo}

\begin{it}
\begin{quotation}
If a subrule call is quantified with a repetition specifier:

\begin{verbatim}
           <rule: file_sequence>
               <file>+
\end{verbatim}

then each repeated match overwrites the corresponding entry in the
surrounding rule’s result-hash, so only the result of the final
repetition will be
retained. That is, if the above example matched the string  \verb"foo.pl bar.py baz.php", 
then the result-hash would contain:

\begin{verbatim}
           file_sequence {
               ""   => 'foo.pl bar.py baz.php',
               file => 'baz.php',
           }
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Operadores de listas y espacios en blanco}

Existe un caveat con el uso de los operadores de repetición
y el manejo de los blancos. Véase el siguiente programa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers3.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <numbers>
11
12        <rule: numbers>
13          (<number>)+
14
15        <token: number> \s*\d+
16      }xms;
17  };
18
19  while (my $input = <>) {
20      if ($input =~ m{$rbb}) {
21          say("matches: <$&>");
22          say Dumper \%/;
23      }
24  }
\end{verbatim}
Obsérvese el uso explícito 
de espacios \verb|\s*\d+| en la definición de \verb|number|.

Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers3.pl
1 2 3 4
matches: <1 2 3 4>
$VAR1 = {
          '' => '1 2 3 4',
          'numbers' => {
                         '' => '1 2 3 4',
                         'number' => ' 4'
                       }
        };
\end{verbatim}

Si se eliminan los blancos de la definición de 
\verb|number|: 
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        <numbers>
    11  
    12        <rule: numbers> 
    13          (<number>)+
    14  
    15        <token: number> \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
se obtiene una conducta que puede sorprender:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers.pl 
12 34 56
matches: <12>
$VAR1 = {
          '' => '12',
          'numbers' => {
                         '' => '12',
                         'number' => '12'
                       }
        };
\end{verbatim}

La explicación está en la documentación: véase la sección \rgsec{Grammar Syntax}{Grammar\_syntax}:
\begin{it}\begin{quotation}
\verb|<rule: IDENTIFIER>|

    Define a rule whose name is specified by the supplied identifier.

Everything following the \verb|<rule:...>| directive (up to the next \verb|<rule:...>| or \verb|<token:...>| directive) 
is treated as part of the rule being defined.

\emph{Any whitespace in the rule is replaced by a call to the} \verb|<.ws>| subrule (which defaults to matching \verb|\s*|, but may be explicitly redefined).

\end{quotation}\end{it}
También podríamos haber resuelto el problema introduciendo un
blanco explícito dentro del cierre positivo:

\begin{verbatim}
      <rule: numbers>
        (<number> )+

      <token: number> \d+
\end{verbatim}

\parrafo{Una Solución al problema de recordar los resultados de una lista: El uso de brackets}

\begin{it}\begin{quotation}
Usually, that’s not the desired outcome, so \cpan{Regexp::Grammars} provides
another mechanism by which to call a subrule; one that saves all
repetitions of its results.

A regular subrule call consists of the rule’s name surrounded by angle
brackets. If, instead, you surround the rule’s name with  \verb"<[...]>"
(angle and square brackets) like so:

\begin{verbatim}
           <rule: file_sequence>
               <[file]>+
\end{verbatim}

then the rule is invoked in exactly the same way, but the result of that
submatch is pushed onto an array nested inside the appropriate result-hash
entry. In other words, if the above example matched the same  
\verb"foo.pl bar.py baz.php" string, the result-hash would contain:

\begin{verbatim}
           file_sequence {
               ""   => 'foo.pl bar.py baz.php',
               file => [ 'foo.pl', 'bar.py', 'baz.php' ],
           }
\end{verbatim}
\end{quotation}
\end{it}

Teniendo en cuenta lo dicho anteriormente sobre los blancos
dentro de los cuantificadores, es necesario introducir
blancos dentro del operador de repetición:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers4.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8
     9      qr{
    10        <numbers>
    11
    12        <rule: numbers>
    13          (?:  <[number]> )+
    14
    15        <token: number> \d+
    16      }xms;
    17  };
    18
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
Al ejecutar este programa obtenemos:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5_10_1 numbers4.pl
1 2 3 4
matches: <1 2 3 4
>
$VAR1 = {
          '' => '1 2 3 4
',
          'numbers' => {
                         '' => '1 2 3 4
',
                         'number' => [ '1', '2', '3', '4' ]
                       }
        };
\end{verbatim}

\parrafo{Otra forma de resolver las colisiones de nombres: salvarlos en una lista}

\begin{it}\begin{quotation}
This \emph{listifying subrule call} can also be useful for non-repeated
subrule calls, if the same subrule is invoked in several places in a
grammar. For example if a cmdline option could be given either one or
two values, you might parse it:

\begin{verbatim}
    <rule: size_option>   
        -size <[size]> (?: x <[size]> )?
\end{verbatim}

The result-hash entry for \verb'size' would then always contain an array,
with either one or two elements, depending on the input being parsed.
\end{quotation}\end{it}
Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n sizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <command>
11
12        <rule: command> ls <size_option>
13
14        <rule: size_option>
15            -size <[size]> (?: x <[size]> )?
16
17        <token: size> \d+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}
Veamos su comportamiento con diferentes entradas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 sizes.pl
ls -size 4
matches: <ls -size 4
>
$VAR1 = {
          '' => 'ls -size 4
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 4
',
                                            'size' => [ '4' ]
                                          },
                         '' => 'ls -size 4
'
                       }
        };

ls -size 2x8
matches: <ls -size 2x8
>
$VAR1 = {
          '' => 'ls -size 2x8
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 2x8
',
                                            'size' => [ '2', '8' ]
                                          },
                         '' => 'ls -size 2x8
'
                       }
        };
\end{verbatim}

\parrafo{Aliasing de listas}

\begin{it}\begin{quotation}
Listifying subrules can also be given aliases, just like ordinary
subrules. The alias is always specified inside the square brackets:

\begin{verbatim}
    <rule: size_option>   
        -size <[size=pos_integer]> (?: x <[size=pos_integer]> )?
\end{verbatim}

Here, the sizes are parsed using the \verb|pos_integer| rule, 
but saved in the result-hash in an array under the key \verb'size'.
\end{quotation}\end{it}

Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedsizes.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10        <command>
11
12        <rule: command> ls <size_option>
13
14        <rule: size_option>
15            -size <[size=int]> (?: x <[size=int]> )?
16
17        <token: int> \d+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}
Veamos el resultado de una ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedsizes.pl
ls -size 2x4
matches: <ls -size 2x4
>
$VAR1 = {
          '' => 'ls -size 2x4
',
          'command' => {
                         'size_option' => {
                                            '' => '-size 2x4
',
                                            'size' => [
                                                        '2',
                                                        '4'
                                                      ]
                                          },
                         '' => 'ls -size 2x4
'
                       }
        };
\end{verbatim}

\parrafo{Caveat: Cierres y Warnings}

En este ejemplo aparece \verb|<number>+| sin 
corchetes ni paréntesis:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numbers5.pl 
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  
     6  my $rbb = do {
     7      use Regexp::Grammars;
     8  
     9      qr{
    10        <numbers>
    11  
    12        <rule: numbers> 
    13          <number>+
    14  
    15        <token: number> \d+
    16      }xms;
    17  };
    18  
    19  while (my $input = <>) {
    20      if ($input =~ m{$rbb}) {
    21          say("matches: <$&>");
    22          say Dumper \%/;
    23      }
    24  }
\end{verbatim}
Este programa produce un mensaje de advertencia:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numbers5.pl 
  warn | Repeated subrule <number>+ will only capture its final match
       | (Did you mean <[number]>+ instead?)
       | 

\end{verbatim}

Si se quiere evitar el mensaje y se está dispuesto a asumir la pérdida
de los valores asociados con los elementos de la lista se deberán poner 
el operando entre paréntesis (con o sin memoria).

Esto es lo que dice la documentación sobre este warning:

\begin{it}\begin{quotation}
\verb|Repeated subrule <rule> will only capture its final match|

You specified a subrule call with a repetition qualifier, such as:

\begin{verbatim}
        <ListElem>*
\end{verbatim}

    or:

\begin{verbatim}
        <ListElem>+
\end{verbatim}

Because each subrule call saves its result in a hash entry of the
same name, each repeated match will overwrite the previous ones,
so only the last match will ultimately be saved. If you want to
save all the matches, you need to tell \cpan{Regexp::Grammars} to save the
sequence of results as a nested array within the hash entry, like so:

\begin{verbatim}
        <[ListElem]>*
\end{verbatim}

    or:

\begin{verbatim}
        <[ListElem]>+
\end{verbatim}

If you really did intend to throw away every result but the final
one, you can silence the warning by placing the subrule call inside
any kind of parentheses. For example:

\begin{verbatim}
        (<ListElem>)*
\end{verbatim}

    or:

\begin{verbatim}
        (?: <ListElem> )+
\end{verbatim}

\end{quotation}\end{it}


\subsection{Pseudo sub-reglas}

\parrafo{Subpatrones}

\begin{it}\begin{quotation}
Aliases can also be given to standard Perl subpatterns, as well as to
code blocks within a regex. The syntax for subpatterns is:

\begin{verbatim}
    <ALIAS= (SUBPATTERN) >
\end{verbatim}

In other words, the syntax is exactly like an aliased subrule call, except
that the rule name is replaced with a set of parentheses containing the
subpattern. Any parentheses--capturing or non-capturing--will do.

The effect of aliasing a standard subpattern is to cause whatever that
subpattern matches to be saved in the result-hash, using the alias as
its key. For example:

\begin{verbatim}
    <rule: file_command>

        <cmd=(mv|cp|ln)>  <from=file>  <to=file>
\end{verbatim}

Here, the \verb#<cmd=(mv|cp|ln)># is treated exactly like a regular \verb#(mv|cp|ln)#,
but whatever substring it matches is saved in the result-hash under the
key \verb|'cmd'|.
\end{quotation}\end{it}
Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n subpattern.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8
 9      qr{
10          <file_command>
11
12          <rule: file_command>
13
14          <cmd=(mv|cp|ln)>  <from=([\w./]+)>  <to=([\w./]+)>
15
16      }x;
17  };
18
19  while (my $input = <>) {
20      while ($input =~ m{$rbb}g) {
21          say("matches: <$&>");
22          say Dumper \%/;
23      }
24  }
\end{verbatim}
y una ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 subpattern.pl
mv a b
matches: <mv a b>
$VAR1 = {
          '' => 'mv a b',
          'file_command' => {
                              '' => 'mv a b',
                              'to' => 'b',
                              'cmd' => 'mv',
                              'from' => 'a'
                            }
        };

cp c d
matches: <cp c d>
$VAR1 = {
          '' => 'cp c d',
          'file_command' => {
                              '' => 'cp c d',
                              'to' => 'd',
                              'cmd' => 'cp',
                              'from' => 'c'
                            }
        }
\end{verbatim}

\parrafo{Bloques de código}

\begin{it}\begin{quotation}
The syntax for aliasing code blocks is:

\begin{verbatim}
    <ALIAS= (?{ your($code->here) }) >
\end{verbatim}

Note, however, that the code block must be specified in the standard
Perl 5.10 regex notation: \verb|(?{...})|. A common mistake is to write:

\begin{verbatim}
    <ALIAS= { your($code->here } >
\end{verbatim}

instead, which will attempt to interpolate \verb|$code| before the
regex is even compiled, as such variables are only \emph{protected} from
interpolation inside a \verb|(?{...})|.

When correctly specified, this construct executes the code in the block
and saves the result of that execution in the result-hash, using the
alias as its key. Aliased code blocks are useful for adding semantic
information based on which branch of a rule is executed. For example,
consider the \verb|copy_cmd| alternatives shown earlier:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>
      | dup    <to=file>  as  <from=file>
      |      <from=file>  ->    <to=file>
      |        <to=file>  <-  <from=file>
\end{verbatim}

Using aliased code blocks, you could add an extra field to the result-
hash to describe which form of the command was detected, like so:

\begin{verbatim}
    <rule: copy_cmd>
        copy <from=file>        <to=file>  <type=(?{ 'std' })> 
      | dup    <to=file>  as  <from=file>  <type=(?{ 'rev' })> 
      |      <from=file>  ->    <to=file>  <type=(?{ 'fwd' })> 
      |        <to=file>  <-  <from=file>  <type=(?{ 'bwd' })> 
\end{verbatim}

Now, if the rule matched, the result-hash would contain something like:

\begin{verbatim}
    copy_cmd => {
        from => 'oldfile',
          to => 'newfile',
        type => 'fwd',
    }
\end{verbatim}
\end{quotation}\end{it}

El siguiente ejemplo ilustra lo dicho en la documentación.
En la línea 15 hemos introducido una regla para el control de 
errores\footnote{Versión de {\tt Grammar.pm} obtenida por email 
con las correcciones de Damian}:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n aliasedcodeblock2.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5
 6  my $rbb = do {
 7      use Regexp::Grammars;
 8      qr{
 9        <copy_cmd>
10
11        <rule: copy_cmd>
12              copy (<from=file>) (<to=file>) <type=(?{ 'std' })>
13          |   <from=file> ->   <to=file> <type=(?{ 'fwd' })>
14          |   <to=file>   <- <from=file> <type=(?{ 'bwd' })>
15          |   .+ (?{ die "Syntax error!\n" })
16
17        <token: file> [\w./\\]+
18      }x;
19  };
20
21  while (my $input = <>) {
22      while ($input =~ m{$rbb}g) {
23          say("matches: <$&>");
24          say Dumper \%/;
25      }
26  }
\end{verbatim}

La ejecución muestra el comportamiento del programa con tres entradas válidas
y una errónea:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 aliasedcodeblock2.pl
copy a b
matches: <copy a b
>
$VAR1 = {
          '' => 'copy a b
',
          'copy_cmd' => {
                          '' => 'copy a b
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'std'
                        }
        };

b <- a
matches: <b <- a
>
$VAR1 = {
          '' => 'b <- a
',
          'copy_cmd' => {
                          '' => 'b <- a
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'bwd'
                        }
        };

a -> b
matches: <a -> b
>
$VAR1 = {
          '' => 'a -> b
',
          'copy_cmd' => {
                          '' => 'a -> b
',
                          'to' => 'b',
                          'from' => 'a',
                          'type' => 'fwd'
                        }
        };

cp a b
Syntax error!
\end{verbatim}

\parrafo{Pseudo subreglas y depuración}

\begin{it}\begin{quotation}
Note that, in addition to the semantics described above, aliased
subpatterns and code blocks also become visible to \cpan{Regexp::Grammars}
integrated debugger (see \rgsec{Debugging}{Debugging}).
\end{quotation}\end{it}

\subsection{Llamadas a subreglas desmemoriadas}

\begin{it}\begin{quotation}
By default, every subrule call saves its result into the result-hash,
either under its own name, or under an alias.

However, sometimes you may want to refactor some literal part of a rule
into one or more subrules, without having those submatches added to the
result-hash. The syntax for calling a subrule, but ignoring its return
value is:

\begin{verbatim}
    <.SUBRULE>
\end{verbatim}

(which is stolen directly from Perl 6).

For example, you may prefer to rewrite a rule such as:

\begin{verbatim}
    <rule: paren_pair> 

        \( 
            (?: <escape> | <paren_pair> | <brace_pair> | [^()] )*
        \)
\end{verbatim}

without any literal matching, like so:

\begin{verbatim}
    <rule: paren_pair> 

        <.left_paren>
            (?: <escape> | <paren_pair> | <brace_pair> | <.non_paren> )*
        <.right_paren>
    
    <token: left_paren>   \(
    <token: right_paren>  \)
    <token: non_paren>    [^()]
\end{verbatim}

Moreover, as the individual components inside the parentheses probably
aren't being captured for any useful purpose either, you could further
optimize that to:

\begin{verbatim}
    <rule: paren_pair> 

        <.left_paren>
            (?: <.escape> | <.paren_pair> | <.brace_pair> | <.non_paren> )*
        <.right_paren>
\end{verbatim}

Note that you can also use the dot modifier on an aliased subpattern:

\begin{verbatim}
    <.Alias= (SUBPATTERN) >
\end{verbatim}

This seemingly contradictory behaviour (of giving a subpattern a name,
then deliberately ignoring that name) actually does make sense in
one situation. Providing the alias makes the subpattern visible to the
debugger, while using the dot stops it from affecting the result-hash. See
\emph{Debugging non-grammars} for an example of this usage.
\end{quotation}\end{it}

\parrafo{Ejemplo: Números entre comas}

Por ejemplo, queremos reconocer listas de números separados por comas.
Supongamos también que queremos
darle un nombre a la expresión regular de separación.
Quizá, aunque no es el caso, porque la expresión
regular de separación sea suficientemente compleja.
Si no usamos la notación \emph{punto} la coma aparecerá en la estructura:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n numberscomma.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        <numbers>
    12
    13        <objrule: numbers>
    14          <[number]> (<comma> <[number]>)*
    15
    16        <objtoken: number> \s*\d+
    17        <token: comma>  \s*,
    18      }xms;
    19  };
    20
    21  while (my $input = <>) {
    22      if ($input =~ m{$rbb}) {
    23          say("matches: <$&>");
    24          say Dumper \%/;
    25      }
    26  }
\end{verbatim}
En efecto, aparece la clave \verb|comma|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma.pl
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
  '' => '2, 3, 4',
  'numbers' => bless( {
    '' => '2, 3, 4',
    'number' => [
      bless( { '' => '2' }, 'number' ),
      bless( { '' => '3' }, 'number' ),
      bless( { '' => '4' }, 'number' )
    ],
    'comma' => ','
  }, 'numbers' )
};
\end{verbatim}
Si cambiamos la llamada a la regla \verb|<comma>| por 
\verb|<.comma>| 

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ diff numberscomma.pl numberscomma2.pl
14c14
<         <[number]> (<comma> <[number]>)*
---
>         <[number]> (<.comma> <[number]>)*
\end{verbatim}
eliminamos la aparición de la innecesaria clave:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 numberscomma2.pl
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
  '' => '2, 3, 4',
  'numbers' => bless( {
    '' => '2, 3, 4',
    'number' => [
      bless( { '' => '2' }, 'number' ),
      bless( { '' => '3' }, 'number' ),
      bless( { '' => '4' }, 'number' )
    ]
  }, 'numbers' )
};

\end{verbatim}

\subsection{Destilación del resultado}

\parrafo{Destilación manual}

\begin{it}\begin{quotation}
\cpan{Regexp::Grammars} also offers full manual control over the distillation
process. If you use the reserved word \verb|MATCH| as the alias for a subrule
call:

\begin{verbatim}
    <MATCH=filename>
\end{verbatim}

or a subpattern match:

\begin{verbatim}
    <MATCH=( \w+ )>
\end{verbatim}

or a code block:

\begin{verbatim}
    <MATCH=(?{ 42 })>
\end{verbatim}

then the current rule will treat the return value of that subrule,
pattern, or code block as its complete result, and return that value
instead of the usual result-hash it constructs. This is the case even
if the result has other entries that would normally also be returned.

For example, in a rule like:

\begin{verbatim}
    <rule: term>
          <MATCH=literal>
        | <left_paren> <MATCH=expr> <right_paren>
\end{verbatim}

The use of \verb|MATCH| aliases causes the rule to return either whatever
\verb|<literal>| returns, or whatever \verb|<expr>| returns (provided it's between
left and right parentheses).

Note that, in this second case, even though \verb|<left_paren>| and \verb|<right_paren>|
are captured to the result-hash, they are not returned, because the
\verb|MATCH| alias overrides the normal \emph{return the result-hash} semantics and
returns only what its associated subrule (i.e. \verb|<expr>|) produces.
\end{quotation}\end{it}

El siguiente ejemplo ilustra el uso del alias \verb|MATCH|:

\begin{verbatim}
$ cat -n demo_calc.pl
 1  #!/usr/local/lib/perl/5.10.1/bin/perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  my $calculator = do{
 6      use Regexp::Grammars;
 7      qr{
 8          <Answer>
 9
10          <rule: Answer>
11              <X=Mult> <Op=([+-])> <Y=Answer>
12            | <MATCH=Mult>
13
14          <rule: Mult>
15              <X=Pow> <Op=([*/%])> <Y=Mult>
16            | <MATCH=Pow>
17
18          <rule: Pow>
19              <X=Term> <Op=(\^)> <Y=Pow>
20            | <MATCH=Term>
21
22          <rule: Term>
23                 <MATCH=Literal>
24            | \( <MATCH=Answer> \)
25
26          <token: Literal>
27              <MATCH=( [+-]? \d++ (?: \. \d++ )?+ )>
28      }xms
29  };
30
31  while (my $input = <>) {
32      if ($input =~ $calculator) {
33          use Data::Dumper 'Dumper';
34          warn Dumper \%/;
35      }
36  }
\end{verbatim}

Veamos una ejecución:

\begin{verbatim}
$ ./demo_calc.pl
2+3*5
$VAR1 = {
          '' => '2+3*5',
          'Answer' => {
                        '' => '2+3*5',
                        'Op' => '+',
                        'X' => '2',
                        'Y' => {
                                 '' => '3*5',
                                 'Op' => '*',
                                 'X' => '3',
                                 'Y' => '5'
                               }
                      }
        };
4-5-2
$VAR1 = {
          '' => '4-5-2',
          'Answer' => {
                        '' => '4-5-2',
                        'Op' => '-',
                        'X' => '4',
                        'Y' => {
                                 '' => '5-2',
                                 'Op' => '-',
                                 'X' => '5',
                                 'Y' => '2'
                               }
                      }
        };
\end{verbatim}
Obsérvese como el árbol construido para la expresión \verb'4-5-2' 
se hunde a derechas dando lugar a una jerarquía errónea.
Para arreglar el problema sería necesario eliminar la 
recursividad por la izquierda en las reglas correspondientes.

\parrafo{Destilación en el programa}

\begin{it}\begin{quotation}
It's also possible to control what a rule returns from within a code
block. \cpan{Regexp::Grammars} provides a set of reserved variables that give
direct access to the result-hash.

The result-hash itself can be accessed as \verb|%MATCH| within any code block
inside a rule. For example:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            <MATCH=(?{ $MATCH{X} + $MATCH{Y} })>
\end{verbatim}

Here, the rule matches a product (aliased \verb|'X'| in the result-hash), then a
literal \verb|'+'|, then another product (aliased to \verb|'Y'| in the result-hash). The
rule then executes the code block, which accesses the two saved values
(as \verb|$MATCH{X}| and \verb|$MATCH{Y}|), adding them together. Because the block
is itself aliased to \verb|MATCH|, the sum produced by the block becomes the
(only) result of the rule.

It is also possible to set the rule result from within a code block
(instead of aliasing it). The special \emph{override} return value is
represented by the special variable \verb|$MATCH|. So the previous example
could be rewritten:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })
\end{verbatim}
Both forms are identical in effect. Any assignment to \verb|$MATCH| overrides
the normal \emph{return all subrule results} behaviour.


Assigning to \verb|$MATCH| directly is particularly handy if the result may
not always be \emph{distillable}, for example:

\begin{verbatim}
    <rule: sum> 
        <X=product> \+ <Y=product>
            (?{ if (!ref $MATCH{X} && !ref $MATCH{Y}) {
                    # Reduce to sum, if both terms are simple scalars...
                    $MATCH = $MATCH{X} + $MATCH{Y};
                }
                else {
                    # Return full syntax tree for non-simple case...
                    $MATCH{op} = '+';
                }
            })
\end{verbatim}

Note that you can also partially override the subrule return
behaviour. Normally, the subrule returns the complete text it matched
under the \emph{empty key} of its result-hash. That is, of course, 
\verb|$MATCH{""}|,
so you can override just that behaviour by directly assigning to that
entry.

For example, if you have a rule that matches key/value pairs from a
configuration file, you might prefer that any trailing comments not
be included in the {\it matched text} entry of the rule's result-hash. You
could hide such comments like so:

\begin{verbatim}
    <rule: config_line>
        <key> : <value>  <comment>?
            (?{
                # Edit trailing comments out of "matched text" entry...
                $MATCH = "$MATCH{key} : $MATCH{value}";
            })
\end{verbatim}

Some more examples of the uses of \verb|$MATCH|:

\begin{verbatim}
    <rule: FuncDecl>
      # Keyword  Name               Keep return the name (as a string)...
        func     <Identifier> ;     (?{ $MATCH = $MATCH{'Identifier'} })


    <rule: NumList>
      # Numbers in square brackets...
        \[ 
            ( \d+ (?: , \d+)* )
        \]

      # Return only the numbers...
        (?{ $MATCH = $CAPTURE })


    <token: Cmd>
      # Match standard variants then standardize the keyword...
        (?: mv | move | rename )      (?{ $MATCH = 'mv'; })
\end{verbatim}

\verb|$CAPTURE| and \verb|$CONTEXT|
    are both aliases for the built-in read-only \verb|$^N |variable, 
which always contains the substring matched by 
the nearest preceding \verb|(...)| capture. 
\verb|$^N| still works perfectly well, but these are provided 
to improve the readability of code blocks and error messages respectively.
\end{quotation}\end{it}

El siguiente código implementa una calculadora
usando destilación en  el código:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_calc_inline.pl
 1  use v5.10;
 2  use warnings;
 3
 4  my $calculator = do{
 5      use Regexp::Grammars;
 6      qr{
 7          <Answer>
 8
 9          <rule: Answer>
10              <X=Mult> \+ <Y=Answer>
11                  (?{ $MATCH = $MATCH{X} + $MATCH{Y}; })
12            | <X=Mult> - <Y=Answer>
13                  (?{ $MATCH = $MATCH{X} - $MATCH{Y}; })
14            | <MATCH=Mult>
15
16          <rule: Mult>
17              <X=Pow> \* <Y=Mult>
18                  (?{ $MATCH = $MATCH{X} * $MATCH{Y}; })
19            | <X=Pow>  / <Y=Mult>
20                  (?{ $MATCH = $MATCH{X} / $MATCH{Y}; })
21            | <X=Pow>  % <Y=Mult>
22                  (?{ $MATCH = $MATCH{X} % $MATCH{Y}; })
23            | <MATCH=Pow>
24
25          <rule: Pow>
26              <X=Term> \^ <Y=Pow>
27                  (?{ $MATCH = $MATCH{X} ** $MATCH{Y}; })
28            | <MATCH=Term>
29
30          <rule: Term>
31                 <MATCH=Literal>
32            | \( <MATCH=Answer> \)
33
34          <token: Literal>
35              <MATCH=( [+-]? \d++ (?: \. \d++ )?+ )>
36      }xms
37  };
38
39  while (my $input = <>) {
40      if ($input =~ $calculator) {
41          say '--> ', $/{Answer};
42      }
43  }
\end{verbatim}

\begin{exercise}
Cual es la salida del programa anterior para las entradas:
\begin{itemize}
\item \verb|4-2-2|
\item \verb|8/4/2|
\item \verb|2^2^3|
\end{itemize}
\end{exercise}

\subsection{Llamadas privadas a subreglas y subreglas privadas}

\begin{it}\begin{quotation}
If a rule name (or an alias) begins with an underscore:

\begin{verbatim}
     <_RULENAME>       <_ALIAS=RULENAME>  
    <[_RULENAME]>     <[_ALIAS=RULENAME]>
\end{verbatim}

then matching proceeds as normal, and any result that is returned is
stored in the current result-hash in the usual way.

However, when any rule finishes (and just before it returns) it first
filters its result-hash, removing any entries whose keys begin with an
underscore. This means that any subrule with an underscored name (or with
an underscored alias) remembers its result, but only until the end of
the current rule. Its results are effectively private to the current rule.

This is especially useful in conjunction with result distillation.
\end{quotation}\end{it}

\subsection{Mas sobre listas}

\parrafo{Reconocimiento manual de listas}


\parrafo{Analizando listas manualmente}

El siguiente ejemplo muestra como construir un reconocedor de 
listas (posiblemente vacías) de números:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           <digit> <List>
    11         | # empty
    12
    13      <rule: digit>
    14          <MATCH=(\d+)>
    15
    16  }xms;
    17
    18  while (my $input = <>) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
\end{verbatim}
Sigue una ejecución:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      '' => '2 3 4',
                      'digit' => '2'
                      'List' => {
                                  '' => '3 4',
                                  'digit' => '3'
                                  'List' => {
                                              '' => '4',
                                              'digit' => '4'
                                              'List' => '',
                                            },
                                },
                    }
        };
\end{verbatim}

\parrafo{Influencia del orden en el lenguaje reconocido}

Tenga en cuenta que el orden de las reglas
influye en el lenguaje reconocido. Véase lo que ocurre si cambiamos 
en el ejemplo anterior el orden de las reglas:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_empty_first.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           # empty
    11         | <digit> <List>
    12
    13      <rule: digit>
    14          <MATCH=(\d+)>
    15
    16  }xms;
    17
    18  while (my $input = <>) {
    19      chomp $input;
    20      if ($input =~ $list) {
    21          use Data::Dumper 'Dumper';
    22          warn Dumper \%/;
    23      }
    24      else {
    25        warn "Does not match\n"
    26      }
    27  }
\end{verbatim}
Al ejecutar se obtiene:
\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ ./simple_list_empty_first.pl
2 3 4
$VAR1 = {
          '' => '',
          'List' => ''
        };
\end{verbatim}

Por supuesto basta poner anclas en el patrón a buscar para forzar a que se reconozca
la lista completa:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ diff simple_list_empty_first.pl simple_list_empty_first_with_anchors.pl
7c7
<     <List>
---
>     ^<List>$
\end{verbatim}
En efecto, la nueva versión reconoce la lista:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_anchors.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      'List' => {
                                  'List' => {
                                              'List' => '',
                                              '' => '4',
                                              'digit' => '4'
                                            },
                                  '' => '3 4',
                                  'digit' => '3'
                                },
                      '' => '2 3 4',
                      'digit' => '2'
                    }
        };
\end{verbatim}

Si se quiere mantener la producción vacía en primer lugar 
pero forzar el reconocimiento de la lista completa, se puede
hacer uso de un lookahead negativo:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_empty_first_with_lookahead.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use strict;
     5  use Regexp::Grammars;
     6
     7  my $list = qr{
     8      <List>
     9
    10      <rule: List>
    11           (?! <digit> ) # still empty production
    12         | <digit> <List>
    13
    14      <rule: digit>
    15          <MATCH=(\d+)>
    16
    17  }xms;
    18
    19  while (my $input = <>) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
\end{verbatim}
Así, sólo se reducirá por la regla vacía si el siguiente token no es un
número. Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_empty_first_with_lookahead.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => {
                      'List' => {
                                  'List' => {
                                              'List' => '',
                                              '' => '4',
                                              'digit' => '4'
                                            },
                                  '' => '3 4',
                                  'digit' => '3'
                                },
                      '' => '2 3 4',
                      'digit' => '2'
                    }
        };

\end{verbatim}

\parrafo{Aplanamiento manual de listas}

¿Cómo podemos hacer que la estructura retornada por el reconocedor 
sea una lista?. Podemos añadir acciones como sigue:

\begin{verbatim}
casiano@millo:~/Lregexp-grammar-examples$ cat -n simple_list_action.pl
     1  #!/soft/perl5lib/bin/perl5.10.1
     2  use v5.10;
     3
     4  use Regexp::Grammars;
     5
     6  my $list = qr{
     7      <List>
     8
     9      <rule: List>
    10           <digit> <X=List> <MATCH= (?{ unshift @{$MATCH{X}}, $MATCH{digit}; $MATCH{X} })>
    11         | # empty
    12           <MATCH= (?{ [] })>
    13
    14      <rule: digit>
    15          <MATCH=(\d+)>
    16
    17  }xms;
    18
    19  while (my $input = <>) {
    20      chomp $input;
    21      if ($input =~ $list) {
    22          use Data::Dumper 'Dumper';
    23          warn Dumper \%/;
    24      }
    25      else {
    26        warn "Does not match\n"
    27      }
    28  }
\end{verbatim}

Al ejecutarse este programa produce una salida como:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 simple_list_action.pl
2 3 4
$VAR1 = {
          '' => '2 3 4',
          'List' => [ '2', '3', '4' ]
        };
\end{verbatim}

\parrafo{Los operadores de repetición}

Los operadores de repetición como \verb|*|, \verb|+|, etc. 
permiten simplificar el análisis de lenguajes de listas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n simple_list_star.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list = qr{
 7      <List>
 8
 9      <rule: List>
10          (?: <[digit]>)*
11
12      <rule: digit>
13          <MATCH=(\d+)>
14
15  }xms;
16
17  while (my $input = <>) {
18      chomp $input;
19      if ($input =~ $list) {
20          use Data::Dumper 'Dumper';
21          warn Dumper \%/;
22      }
23      else {
24        warn "Does not match\n"
25      }
26  }
\end{verbatim}
Los corchetes alrededor de \verb|digit| hacen 
que el valor asociado con el patrón sea la lista de números.
Si no los ponemos el valor asociado sería el último valor de la lista.

\parrafo{Listas separadas por Algo}

\begin{it}\begin{quotation}
One of the commonest tasks in text parsing is to match a list of
unspecified length, in which items are separated by a fixed token. Things
like:

\begin{verbatim}
    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces

    g-c-a-g-t-t-a-c-a          # Bases separated by dashes

    /usr/local/bin             # Names separated by directory markers

    /usr:/usr/local:bin        # Directories separated by colons
\end{verbatim}

The usual construct required to parse these kinds of structures is either:

\begin{verbatim}
    <rule: list>

        <item> <separator> <list               # recursive definition
      | <item>                                 # base case
\end{verbatim}

Or, more efficiently, but less prettily:

\begin{verbatim}
    <rule: list>

        <[item]> (?: <separator> <[item]> )*   # iterative definition
\end{verbatim}

Because this is such a common requirement, \cpan{Regexp::Grammars} provides a
cleaner way to specify the iterative version. The syntax is taken from
Perl 6:

\begin{verbatim}
    <rule: list>

        <[item]> ** <separator>                # iterative definition
\end{verbatim}

This is a repetition specifier on the first subrule (hence the use of \verb|**|
as the marker, to reflect the repetitive behaviour of \verb|*|). However, the
number of repetitions is controlled by the second subrule: the first
subrule will be repeatedly matched for as long as the second subrule
matches immediately after it.

So, for example, you can match a sequence of numbers separated by
commas with:

\begin{verbatim}
    <[number]> ** <comma>

    <token: number>  \d+
    <token: comma>   \s* , \s*
\end{verbatim}

Note that it's important to use the \verb|<[...]>| form for the items being
matched, so that all of them are saved in the result hash. You can also
save all the separators (if that's important):

\begin{verbatim}
    <[number]> ** <[comma]>
\end{verbatim}

The repeated item must be specified as a subrule call fo some kind,
but the separators may be specified either as a subrule or a bracketed
pattern. For example:

\begin{verbatim}
    <[number]> ** ( , )
\end{verbatim}

The separator must always be specified in matched delimiters of some kind:
either matching \verb|<...>| or matching \verb|(...)|. 
A common error is to write:

\begin{verbatim}
    <[number]> ** ,
\end{verbatim}

You can also use a pattern as the item matcher, but it must be aliased
into a subrule:

\begin{verbatim}
    <[item=(\d+)]> ** ( , )
\end{verbatim}
\end{quotation}\end{it}

\parrafo{Ejemplo: Listas de números separados por comas}

Veamos un ejemplo sencillo:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ cat -n demo_list.pl
 1  #!/soft/perl5lib/bin/perl5.10.1
 2  use v5.10;
 3
 4  use Regexp::Grammars;
 5
 6  my $list_nonempty = qr{
 7      <List>
 8
 9      <rule: List>
10          \(  <[Value]> ** (,)  \)
11
12      <token: Value>
13          \d+
14  }xms;
15
16  my $list_empty = qr{
17      <List>
18
19      <rule: List>
20          \(  (?: <[Value]> ** <_Sep=(,)> )?  \)
21
22      <token: Value>
23          \d+
24  }xms;
25
26  use Smart::Comments;
27
28
29  while (my $input = <>) {
30      my $input2 = $input;
31      if ($input =~ $list_nonempty) {
32          ### nonempty: $/{List}
33      }
34      if ($input2 =~ $list_empty) {
35          ### empty: $/{List}
36      }
37  }
\end{verbatim}
Sigue un ejemplo de ejecución:

\begin{verbatim}
casiano@millo:~/src/perl/regexp-grammar-examples$ ./demo_list.pl
(3,4,5)

### nonempty: {
###             '' => '(3,4,5)',
###             Value => [
###                        '3',
###                        '4',
###                        '5'
###                      ]
###           }

### empty: {
###          '' => '(3,4,5)',
###          Value => [
###                     '3',
###                     '4',
###                     '5'
###                   ]
###        }
()

### empty: '()'
\end{verbatim}

\parrafo{Ejemplo: AST para las expresiones aritméticas}

Las expresiones aritméticas
puede definirse como una jerarquía de listas como
sigue:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n calcaslist.pl
 1  use strict;
 2  use warnings;
 3  use 5.010;
 4  use Data::Dumper;
 5  $Data::Dumper::Indent = 1;
 6
 7  my $rbb = do {
 8      use Regexp::Grammars;
 9
10      qr{
11        \A<expr>\z
12
13        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
14
15        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
16
17        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
18
19        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
20
21        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
22
23        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
24                           | \( <MATCH=expr> \)
25
26        <token: addop>        [+-]
27
28        <token: mulop>        [*/]
29
30        <token: powerop>      \*\*|\^
31
32        <token: minus>        - <MATCH=(?{ 'NEG' })>
33
34      }x;
35  };
36
37  while (my $input = <>) {
38      chomp($input);
39      if ($input =~ m{$rbb}) {
40          my $tree = $/{expr};
41          say Dumper $tree;
42
43      }
44      else {
45          say("does not match");
46      }
47  }
\end{verbatim}

Obsérvese el árbol generado para la expresión \verb|4-2-2|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 calcaslist.pl
4-2-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '4', 'val' => '4' }, 'factor' )
                  ],
                  '' => '4'
                }, 'factorial' )
              ],
              '' => '4'
            }, 'power' )
          ],
          '' => '4'
        }, 'uneg' )
      ],
      '' => '4'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' )
  ],
  '' => '4-2-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );
\end{verbatim}

\subsection{La directiva {\tt require}}

La directiva \verb|require| es similar 
en su funcionamiento al paréntesis 5.10 \verb|(??{ Código Perl })|
el cuál hace que el \verb|Código Perl| sea evaluado durante el tiempo de matching.
El resultado de la evaluación se trata como una expresión regular con la que deberá
casarse.
(véase la sección \ref{subsection:tiempodematching}
para mas detalles).

La sintáxis de la directiva \verb|<require:>| es

\begin{it}\begin{quotation}
\begin{verbatim}
                        <require: (?{ CODE }) >
\end{verbatim}

The code block is executed and if its final value is true, matching
continues from the same position. If the block's final value is false,
the match fails at that point and starts backtracking.
\end{quotation}\end{it}

\begin{it}\begin{quotation}
The \verb|<require:...>| directive is useful for testing conditions that it's
not easy (or even possible) to check within the syntax of the the regex
itself. For example:

\begin{verbatim}
    <rule: IPV4_Octet_Decimal>
        # Up three digits...
        <MATCH= ( \d{1,3}+ )>
        
        # ...but less that 256...
        <require: (?{ $MATCH <= 255 })>
\end{verbatim}

A require expects a regex codeblock as its argument and succeeds if
the final value of that codeblock is true. If the final value is false,
the directive fails and the rule starts backtracking.

Note, in this example that the digits are matched with \verb|\d{1,3}+| . \emph{The
trailing} \verb|+| prevents the \verb|{1,3}| repetition from backtracking to a smaller
number of digits if the \verb|<require:...>| fails.
\end{quotation}\end{it}

El programa \verb|demo_IP4.pl| ilustra el uso de la directiva:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n ./demo_IP4.pl
 1  #!/usr//bin/env perl5.10.1
 2  use v5.10;
 3  use warnings;
 4
 5  use Regexp::Grammars;
 6
 7  my $grammar = qr{
 8      \A <IP4_addr> \Z
 9
10      <token: quad>
11          <MATCH=(\d{1,3})>
12          <require: (?{ $MATCH < 256 })>
13
14      <token: IP4_addr>
15          <[MATCH=quad]>**(\.)
16          <require: (?{ @$MATCH == 4 })>
17  }xms;
18
19  while (my $line = <>) {
20      if ($line =~ $grammar) {
21          use Data::Dumper 'Dumper';
22          say Dumper \%/;
23      }
24      else {
25          say 'Does not match'
26      }
27  }
\end{verbatim}
Las condiciones usadas en el \verb|require| obligan a que cada 
quad\footnote{
A quad (pronounced KWAHD ) is a unit in a set of something that comes
in four units. The term is sometimes used to describe each of the four
numbers that constitute an Internet Protocol ( IP ) address. Thus, an
Internet address in its numeric form (which is also sometimes called a
dot address ) consists of four quads separated by "dots" (periods). 

A quad also means \emph{a quarter} in some usages. (A quarter as a U.S. coin
or monetary unit means \emph{a quarter of a dollar,} and in slang is sometimes
called \emph{two bits.} However, this usage does not mean two binary bits as
used in computers.)
} sea menor que 256 y a que existan sólo cuatro quads.

Sigue un ejemplo de ejecución:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123 . 145 . 105 . 252
Does not match
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
123.145.105.252
$VAR1 = {
          '' => '123.145.105.252',
          'IP4_addr' => [
                          123,
                          145,
                          105,
                          252
                        ]
        };
pl@nereida:~/Lregexpgrammars/demo$ ./demo_IP4.pl
148.257.128.128
Does not match
0.0.0.299
Does not match
pl@nereida:~/Lregexpgrammars/demo$  ./demo_IP4.pl
123.145.105.242.193
Does not match
\end{verbatim}
Obsérvese como no se aceptan blancos entre los puntos en esta versión.
¿Sabría explicar la causa?



\subsection{Casando con las claves de un hash}


\begin{it}\begin{quotation}
In some situations a grammar may need a rule that matches dozens,
hundreds, or even thousands of one-word alternatives. For example, when
matching command names, or valid userids, or English words. In such
cases it is often impractical (and always inefficient) to list all the
alternatives between \verb#|# alterators:

\begin{verbatim}
    <rule: shell_cmd>
        a2p | ac | apply | ar | automake | awk | ...
        # ...and 400 lines later
        ... | zdiff | zgrep | zip | zmore | zsh

    <rule: valid_word>
        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
        # ...and 40,000 lines later... 
        ... | zymotize | zymotoxic | zymurgy | zythem | zythum
\end{verbatim}

To simplify such cases, \cpan{Regexp::Grammars} provides a special construct
that allows you to specify all the alternatives as the keys of a normal
hash. The syntax for that construct is simply to put the hash name inside
angle brackets (with no space between the angles and the hash name).

Which means that the rules in the previous example could also be written:

\begin{verbatim}
    <rule: shell_cmd>
        <%cmds>

    <rule: valid_word>
        <%dict>
\end{verbatim}

provided that the two hashes (\verb|%cmds| and \verb|%dict|) 
are visible in the scope where the grammar is created.

Internally, the construct is converted to something equivalent to:

\begin{verbatim}
    <rule: shell_cmd>
        (<.hk>)  <require: exists $cmds{$CAPTURE}>

    <rule: valid_word>
        (<.hk>)  <require: exists $dict{$CAPTURE}>
\end{verbatim}

The special \verb|<hk>| rule is created automatically, and defaults to \verb|\S+|,
but you can also define it explicitly to handle other kinds of keys. For
example:

\begin{verbatim}
    <rule: hk>
        .+            # Key may be any number of chars on a single line

    <rule: hk>
        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs
\end{verbatim}

Matching a hash key in this way is typically significantly faster than
matching a full set of alternations. Specifically, it is O(length of
longest potential key), instead of O(number of keys).
\end{quotation}\end{it}

\parrafo{Ejemplo de uso de la directiva hash}

Sigue un ejemplo:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n hash.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Data::Dumper;
 6  $Data::Dumper::Deparse = 1;
 7
 8  my %cmd = map { ($_ => undef ) } qw( uname pwd date );
 9
10  my $rbb = do {
11      use Regexp::Grammars;
12
13      qr{
14        ^<command>$
15
16        <rule: command>
17          <cmd=%cmd> (?: <[arg]> )*
18
19        <token: arg> [^\s<>`&]+
20      }xms;
21  };
22
23  while (my $input = <>) {
24      chomp($input);
25      if ($input =~ m{$rbb}) {
26          say("matches: <$&>");
27          say Dumper \%/;
28          system $/{''}
29      }
30      else {
31          say("does not match");
32      }
33  }
\end{verbatim}

Sigue un ejemplo de ejecución:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 hash.pl
a2p f1 f2
matches: <a2p f1 f2>
$VAR1 = {
          '' => 'a2p f1 f2',
          'command' => {
                         '' => 'a2p f1 f2',
                         'cmd' => 'a2p',
                         'arg' => [
                                    'f1',
                                    'f2'
                                  ]
                       }
        };

pocho 2 5
does not match

\end{verbatim}

\subsection{Depuración}

\begin{it}\begin{quotation}
\cpan{Regexp::Grammars} provides a number of features specifically designed to
help debug both grammars and the data they parse.

    All debugging messages are written to a log file (which, by default, is
    just \verb|STDERR|). However, you can specify a disk file explicitly by placing
    a \verb|"<logfile:...>"| directive \emph{at the start of your grammar}\footnote{no funcionará si no se pone al principio
    de la gramática}:

\begin{verbatim}
        $grammar = qr{

            <logfile: LaTeX_parser_log >

            \A <LaTeX_file> \Z    # Pattern to match

            <rule: LaTeX_file>
                # etc.
        }x;
\end{verbatim}

    You can also explicitly specify that messages go to the terminal:

\begin{verbatim}
            <logfile: - >
\end{verbatim}

\parrafo{Debugging grammar creation}

Whenever a log file has been directly specified, \cpan{Regexp::Grammars}
automatically does verbose static analysis of your grammar. That is,
whenever it compiles a grammar containing an explicit \verb|"<logfile:...>"|
directive it logs a series of messages explaining how it has interpreted
the various components of that grammar. For example, the following
grammar:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n log.pl
     1  #!/usr/bin/env perl5.10.1
     2  use strict;
     3  use warnings;
     4  use 5.010;
     5  use Data::Dumper;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        <logfile: ->
    12
    13        <numbers>
    14
    15        <rule: numbers>
    16          <number> ** <.comma>
    17
    18        <token: number> \d+
    19
    20        <token: comma>   ,
    21      }xms;
    22  };
    23
    24  while (my $input = <>) {
    25      if ($input =~ m{$rbb}) {
    26          say("matches: <$&>");
    27          say Dumper \%/;
    28      }
    29  }
\end{verbatim}

would produce the following analysis in the terminal:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./log.pl
  warn | Repeated subrule <number>* will only capture its final match
       | (Did you mean <[number]>* instead?)
       |
  info | Processing the main regex before any rule definitions
       |    |
       |    |...Treating <numbers> as:
       |    |      |  match the subrule <numbers>
       |    |       \ saving the match in $MATCH{'numbers'}
       |    |
       |     \___End of main regex
       |
       | Defining a rule: <numbers>
       |    |...Returns: a hash
       |    |
       |    |...Treating <number> as:
       |    |      |  match the subrule <number>
       |    |       \ saving the match in $MATCH{'number'}
       |    |
       |    |...Treating <.comma> as:
       |    |      |  match the subrule <comma>
       |    |       \ but don't save anything
       |    |
       |    |...Treating <number> ** <.comma> as:
       |    |      |  repeatedly match the subrule <number>
       |    |       \ as long as the matches are separated by matches of <.comma>
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: <number>
       |    |...Returns: a hash
       |    |
       |    |...Treating '\d' as:
       |    |       \ normal Perl regex syntax
       |    |
       |    |...Treating '+ ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
       | Defining a rule: <comma>
       |    |...Returns: a hash
       |    |
       |    |...Treating ', ' as:
       |    |       \ normal Perl regex syntax
       |    |
       |     \___End of rule definition
       |
2, 3, 4
matches: <2, 3, 4>
$VAR1 = {
          '' => '2, 3, 4',
          'numbers' => {
                         '' => '2, 3, 4',
                         'number' => '4'
                       }
        };
\end{verbatim}

This kind of static analysis is a useful starting point in debugging a
\cei{miscreant grammar}\footnote{
miscreant - \it{One who has behaved badly, or illegally; One not restrained by
moral principles; an unscrupulous villain; One who holds an incorrect
religious belief; an unbeliever; Lacking in conscience or moral
principles; unscrupulous; Holding an incorrect religious belief.}
}, because it enables you to see what you actually
specified (as opposed to what you \emph{thought} you'd specified).

\parrafo{Debugging grammar execution}

\cpan{Regexp::Grammars} also provides a simple interactive debugger, with which
you can observe the process of parsing and the data being collected in
any result-hash.

To initiate debugging, place a \verb"<debug:...>" directive anywhere in your
grammar. When parsing reaches that directive the debugger will be
activated, and the command specified in the directive immediately
executed. The available commands are:

\begin{verbatim}
        <debug: on>    - Enable debugging, stop when entire grammar matches
        <debug: match> - Enable debugging, stope when a rule matches
        <debug: try>   - Enable debugging, stope when a rule is tried
        <debug: off>   - Disable debugging and continue parsing silently

        <debug: continue> - Synonym for <debug: on>
        <debug: run>      - Synonym for <debug: on>
        <debug: step>     - Synonym for <debug: try>
\end{verbatim}

    These directives can be placed anywhere within a grammar and take effect
    when that point is reached in the parsing. Hence, adding a
    \verb"<debug:step>" directive is very much like setting a breakpoint at that
    point in the grammar. Indeed, a common debugging strategy is to turn
    debugging on and off only around a suspect part of the grammar:

\begin{verbatim}
        <rule: tricky>   # This is where we think the problem is...
            <debug:step>
            <preamble> <text> <postscript>
            <debug:off>
\end{verbatim}

Once the debugger is active, it steps through the parse, reporting rules
that are tried, matches and failures, backtracking and restarts, and the
parser's location within both the grammar and the text being matched.
That report looks like this:

\begin{verbatim}
        ===============> Trying <grammar> from position 0
        > cp file1 file2 |...Trying <cmd>
                         |   |...Trying <cmd=(cp)>
                         |   |    \FAIL <cmd=(cp)>
                         |    \FAIL <cmd>
                          \FAIL <grammar>
        ===============> Trying <grammar> from position 1
         cp file1 file2  |...Trying <cmd>
                         |   |...Trying <cmd=(cp)>
         file1 file2     |   |    \_____<cmd=(cp)> matched 'cp'
        file1 file2      |   |...Trying <[file]>+
         file2           |   |    \_____<[file]>+ matched 'file1'
                         |   |...Trying <[file]>+
        [eos]            |   |    \_____<[file]>+ matched ' file2'
                         |   |...Trying <[file]>+
                         |   |    \FAIL <[file]>+
                         |   |...Trying <target>
                         |   |   |...Trying <file>
                         |   |   |    \FAIL <file>
                         |   |    \FAIL <target>
         <~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
        file2            |   |...Trying <target>
                         |   |   |...Trying <file>
                         |   |   |    \____ <file> matched 'file2'
        [eos]            |   |    \_____<target> matched 'file2'
                         |    \_____<cmd> matched ' cp file1 file2'
                          \_____<grammar> matched ' cp file1 file2'
\end{verbatim}

The first column indicates the point in the input at which the parser is
trying to match, as well as any backtracking or forward searching it may
need to do. The remainder of the columns track the parser's hierarchical
traversal of the grammar, indicating which rules are tried, which
succeed, and what they match.

Provided the logfile is a terminal (as it is by default), the debugger
also pauses at various points in the parsing process--before trying a
rule, after a rule succeeds, or at the end of the parse--according to
the most recent command issued. When it pauses, you can issue a new
command by entering a single letter:

\begin{verbatim}
        m       - to continue until the next subrule matches
        t or s  - to continue until the next subrule is tried
        r or c  - to continue to the end of the grammar
        o       - to switch off debugging
\end{verbatim}

Note that these are the first letters of the corresponding \verb"<debug:...>"
commands, listed earlier. Just hitting ENTER while the debugger is
paused repeats the previous command.

While the debugger is paused you can also type a \verb'd', which will display
the result-hash for the current rule. This can be useful for detecting
which rule isn't returning the data you expected.
\end{quotation}\end{it}

Veamos un ejemplo. El siguiente programa activa el depurador:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n demo_debug.pl
     1  #!/usr/bin/env perl5.10.1
     2  use 5.010;
     3  use warnings;
     4
     5      use Regexp::Grammars;
     6
     7      my $balanced_brackets = qr{
     8          <debug:on>
     9
    10          <left_delim=(  \( )>
    11          (?:
    12              <[escape=(  \\ )]>
    13          |   <recurse=( (?R) )>
    14          |   <[simple=(  .  )]>
    15          )*
    16          <right_delim=( \) )>
    17      }xms;
    18
    19      while (<>) {
    20          if (/$balanced_brackets/) {
    21              say 'matched:';
    22              use Data::Dumper 'Dumper';
    23              warn Dumper \%/;
    24          }
    25      }
\end{verbatim}
Al ejecutar obtenemos
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
(a)
=====> Trying <grammar> from position 0
(a)\n  |...Trying <left_delim=(  \( )>
a)\n   |    \_____<left_delim=(  \( )> matched '('      c
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 1
a)\n   |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
)\n    |    \_____<[simple=(  .  )]> matched 'a'
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 2
)\n    |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
\n     |    \_____<[simple=(  .  )]> matched ')'
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 3
\n     |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
[eos]  |    \_____<[simple=(  .  )]> matched ''
       |...Trying <[escape=(  \ )]>
       |    \FAIL <[escape=(  \ )]>
       |...Trying <recurse=( (?R) )>
=====> Trying <grammar> from position 4
[eos]  |   |...Trying <left_delim=(  \( )>
       |   |    \FAIL <left_delim=(  \( )>
        \FAIL <grammar>
       |...Trying <[simple=(  .  )]>
       |    \FAIL <[simple=(  .  )]>
       |...Trying <right_delim=( \) )>
       |    \FAIL <right_delim=( \) )>
 <~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying <right_delim=( \) )>
       |    \FAIL <right_delim=( \) )>
 <~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying <right_delim=( \) )>
\n     |    \_____<right_delim=( \) )> matched ')'
        \_____<grammar> matched '(a)'   d
              :         {
              :           '' => '(a)',
              :           'left_delim' => '(',
              :           'simple' => [
              :                         'a'
              :                       ],
              :           'right_delim' => ')'
              :         };      o
matched:
$VAR1 = {
          '' => '(a)',
          'left_delim' => '(',
          'simple' => [
                        'a'
                      ],
          'right_delim' => ')'
        };
\end{verbatim}
\end{latexonly}

\begin{rawhtml}
<PRE>
pl@nereida:~/Lregexpgrammars/demo$ ./demo_debug.pl
<span class="lightblue">(a)</span>
=====&gt; Trying &lt;grammar&gt; from position 0
(a)\n  |...Trying &lt;left_delim=(  \( )&gt;

a)\n   |    \_____&lt;left_delim=(  \( )&gt; matched '('      <span class="lightblue">c</span>
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 1
a)\n   |   |...Trying &lt;left_delim=(  \( )&gt;

       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
)\n    |    \_____&lt;[simple=(  .  )]&gt; matched 'a'
       |...Trying &lt;[escape=(  \ )]&gt;

       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 2
)\n    |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;

        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;
\n     |    \_____&lt;[simple=(  .  )]&gt; matched ')'
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;

       |...Trying &lt;recurse=( (?R) )&gt;
=====&gt; Trying &lt;grammar&gt; from position 3
\n     |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;

       |...Trying &lt;[simple=(  .  )]&gt;
[eos]  |    \_____&lt;[simple=(  .  )]&gt; matched ''
       |...Trying &lt;[escape=(  \ )]&gt;
       |    \FAIL &lt;[escape=(  \ )]&gt;
       |...Trying &lt;recurse=( (?R) )&gt;

=====&gt; Trying &lt;grammar&gt; from position 4
[eos]  |   |...Trying &lt;left_delim=(  \( )&gt;
       |   |    \FAIL &lt;left_delim=(  \( )&gt;
        \FAIL &lt;grammar&gt;
       |...Trying &lt;[simple=(  .  )]&gt;

       |    \FAIL &lt;[simple=(  .  )]&gt;
       |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;
 &lt;~~~~ |...Backtracking 1 char and trying new match
\n     |...Trying &lt;right_delim=( \) )&gt;
       |    \FAIL &lt;right_delim=( \) )&gt;

 &lt;~~~~ |...Backtracking 1 char and trying new match
)\n    |...Trying &lt;right_delim=( \) )&gt;
\n     |    \_____&lt;right_delim=( \) )&gt; matched ')'
        \_____&lt;grammar&gt; matched '(a)'   <span class="lightblue">d</span>
              :         {
              :           '' =&gt; '(a)',
              :           'left_delim' =&gt; '(',
              :           'simple' =&gt; [
              :                         'a'
              :                       ],
              :           'right_delim' =&gt; ')'
              :         };      <span class="lightblue">o</span>
matched:
$VAR1 = {
          '' =&gt; '(a)',
          'left_delim' =&gt; '(',
          'simple' =&gt; [
                        'a'
                      ],
          'right_delim' =&gt; ')'
        };

</PRE>

\end{rawhtml}

\subsection{Mensajes de {\tt log} del usuario}

\begin{it}\begin{quotation}
    Both static and interactive debugging send a series of predefined log
    messages to whatever log file you have specified. It is also possible to
    send additional, user-defined messages to the log, using the \verb|"<log:...>"|
    directive.

    This directive expects either a simple text or a codeblock as its single
    argument. If the argument is a code block, that code is expected to
    return the text of the message; if the argument is anything else, that
    something else \emph{is} the literal message. For example:

\begin{verbatim}
        <rule: ListElem>

            <Elem=   ( [a-z]\d+) >
                <log: Checking for a suffix, too...>

            <Suffix= ( : \d+   ) >?
                <log: (?{ "ListElem: $MATCH{Elem} and $MATCH{Suffix}" })>
\end{verbatim}

    User-defined log messages implemented using a codeblock can also specify
    a severity level. If the codeblock of a \verb"<log:...>" directive returns
    two or more values, the first is treated as a log message severity
    indicator, and the remaining values as separate lines of text to be
    logged. For example:

\begin{verbatim}
        <rule: ListElem>
            <Elem=   ( [a-z]\d+) >
            <Suffix= ( : \d+   ) >?

                <log: (?{
                    warn => "Elem was: $MATCH{Elem}",
                            "Suffix was $MATCH{Suffix}",
                })>
\end{verbatim}

    When they are encountered, user-defined log messages are interspersed
    between any automatic log messages (i.e. from the debugger), at the
    correct level of nesting for the current rule.
\end{quotation}\end{it}


\subsection{Depuración de Regexps}

\begin{it}\begin{quotation}
    It is possible to use \cpan{Regexp::Grammars} without creating \emph{any} subrule
    definitions, simply to debug a recalcitrant regex. For example, if the
    following regex wasn't working as expected:

\begin{verbatim}
        my $balanced_brackets = qr{
            \(             # left delim
            (?:
                \\         # escape or
            |   (?R)       # recurse or
            |   .          # whatever
            )*
            \)             # right delim
        }xms;
\end{verbatim}

    you could instrument it with aliased subpatterns and then debug it
    step-by-step, using \cpan{Regexp::Grammars}:

\begin{verbatim}
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            <debug:step>

            <.left_delim=  (  \(  )>
            (?:
                <.escape=  (  \\  )>
            |   <.recurse= ( (?R) )>
            |   <.whatever=(  .   )>
            )*
            <.right_delim= (  \)  )>
        }xms;

        while (<>) {
            say 'matched' if /$balanced_brackets/;
        }
\end{verbatim}

    Note the use of amnesiac aliased subpatterns to avoid needlessly
    building a result-hash. Alternatively, you could use listifying aliases
    to preserve the matching structure as an additional debugging aid:

\begin{verbatim}
        use Regexp::Grammars;

        my $balanced_brackets = qr{
            <debug:step>

            <[left_delim=  (  \(  )]>
            (?:
                <[escape=  (  \\  )]>
            |   <[recurse= ( (?R) )]>
            |   <[whatever=(  .   )]>
            )*
            <[right_delim= (  \)  )]>
        }xms;

        if ( '(a(bc)d)' =~ /$balanced_brackets/) {
            use Data::Dumper 'Dumper';
            warn Dumper \%/;
        }
\end{verbatim}
\end{quotation}\end{it}


\subsection{Manejo y recuperación de errores}

En este punto debo decir que no he podido reproducir el comportamiento
de las directivas \verb|<error:>| y \verb|<warning:>| tal y como las describe 
Conway en el manual de \regexpg{}. 

El siguiente ejemplo ilustra un conjunto de técnicas de gestión de errores
que son independientes del soprote dado por \regexpg{}.

Se trata de la misma calculadora explicada en la sección
\ref{subsection:recicla}.

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculatorwitherrmanagement.pl
 1  #!/usr/bin/env perl5.10.1
 2  use strict;
 3  use warnings;
 4  use 5.010;
 5  use Lingua::EN::Inflect qw(PL);
 6  use Scalar::Util qw{blessed};
 7
 8  my $rbb = do {
 9      my ($warnings, $errors);    # closure
10      sub warnings { $warnings }  # accessor
11      sub errors { $errors }      # accessor
12
13      use Regexp::Grammars;
14      qr{
15        (?{
16            $warnings = 0;
17            $errors = 0;
18        })
19        \A<expr>
20        (?:   \z
21             |
22               (.*) (?{
23                        # Accept the string but emit a warning
24                        $warnings++;
25                        local our $expr = \$MATCH{expr}{''};
26                        local our $endlegal = length($$expr) > 4? "... ".substr($$expr, -4) : $$expr;
27                        warn "Warning: Unexpected '". substr($^N, 0, 10)."' after '$endlegal'\n";
28                     })
29        )
30
31        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
32
33        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
34
35        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
36
37        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
38
39        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
40
41        <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
42                           | \( <MATCH=expr> \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) <MATCH=factor>
49
50        <token: addop>        [+-]
51
52        <token: mulop>        [*/]
53
54        <token: powerop>      \*\*|\^
55
56        <token: minus>        - <MATCH=(?{ 'NEG' })>
57
58      }x;
59  };
60
61  sub test_calc {
62    my $prompt = shift;
63
64    print $prompt;
65    while (my $input = <>) {
66        chomp($input);
67
68        local %/;
69        $input =~ m{$rbb};
70
71        say warnings." ".PL('warning',warnings) if warnings;
72        say errors." ".PL('error',errors)       if errors;
73
74        my $tree = $/{expr};
75        if (blessed($tree)) {
76            do "PostfixCalc.pm";
77            say "postfix: ".$tree->ceval;
78
79            do "EvalCalc.pm";
80            say "result: ".$tree->ceval;
81        }
82        print $prompt;
83    }
84    say "Bye!"
85  }
86
87  ########## main
88  test_calc(
89    'Parsing infix arithmetic expressions (CTRL-D to end in unix) ',
90  );
\end{verbatim}

Veamos algunas ejecuciones que incluyen entradas erróneas:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+3
postfix: 2 3 +
result: 5
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
Error: expecting a number or a open parenthesis, found: '#'
Error: expecting a number or a open parenthesis, found: ')'
Warning: Unexpected '*(3+#)' after '2'
4 warnings
3 errors
postfix: 2
result: 2
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2+#*4
Error: expecting a number or a open parenthesis, found: '#*'
1 warning
1 error
postfix: 2 4 +
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
\end{verbatim}
Obsérvese los mensajes de error repetidos para la entrada 
\verb|2*(3+#)|. Ellos son debidos a los reiterados intentos de
casar \verb|<factor>| en la regla de recuperación de errores:
\begin{verbatim}
41        <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
42                           | \( <MATCH=expr> \)
43                           | ([^-+(0-9]+) (?{
44                                            # is + and not * to avoid infinite recursion
45                                            warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
46                                            $warnings++;
47                                            $errors++;
48                                        }) <MATCH=factor>
\end{verbatim}
en este caso resulta imposible encontrar un factor.
Se puede cambiar la conducta indicando un \verb|(* COMMIT)| antes de la
llamada a \verb|<MATCH=factor>|:
\begin{verbatim}
 41       <objrule: factor>    (<val=([+-]?\d+(?:\.\d*)?)>)
 42                          | \( <MATCH=expr> \)
 43                          | ([^-+(0-9]+) (?{
 44                                           # is + and not * to avoid infinite recursion
 45                                           warn "Error: expecting a number or a open parenthesis, found: '". substr($^N, 0, 10)."'\n";
 46                                           $warnings++;
 47                                           $errors++;
 48                                       }) (*COMMIT) <MATCH=factor>
\end{verbatim}

en este caso la conducta es abandonar en el caso de que no se pueda encontrar un \verb|<factor>|:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ ./calculatorwitherrmanagement.pl
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*(3+#)
Error: expecting a number or a open parenthesis, found: '#)'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) 2*3
postfix: 2 3 *
result: 6
Parsing infix arithmetic expressions (CTRL-D to end in unix) @
Error: expecting a number or a open parenthesis, found: '@'
1 warning
1 error
Parsing infix arithmetic expressions (CTRL-D to end in unix) Bye!
\end{verbatim}

\subsection{Mensajes de Warning}

\begin{it}\begin{quotation}
   Sometimes, you want to detect problems, but not invalidate the entire
   parse as a result. For those occasions, the module provides a \emph{less
   stringent} form of error reporting: the \verb"<warning:...>" directive.

   This directive is exactly the same as an \verb"<error:...>" in every respect
   except that it does not induce a failure to match at the point it
   appears.

   The directive is, therefore, useful for reporting \emph{non-fatal} problems
   in a parse. For example:

\begin{verbatim}
       qr{ \A            # ...Match only at start of input
           <ArithExpr>   # ...Match a valid arithmetic expression

           (?:
               # Should be at end of input...
               \s* \Z
             |
               # If not, report the fact but don't fail...
               <warning: Expected end-of-input>
               <warning: (?{ "Extra junk at index $INDEX: $CONTEXT" })>
           )

           # Rule definitions here...
       }xms;
\end{verbatim}

   Note that, because they do not induce failure, two or more
   \verb"<warning:...>" directives can be "stacked" in sequence, as in the
   previous example.

\end{quotation}\end{it}

\subsection{Simplificando el AST}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n exprdamian.pl
     1  use strict;
     2  use warnings;
     3  use 5.010;
     4  use Data::Dumper;
     5  $Data::Dumper::Indent = 1;
     6
     7  my $rbb = do {
     8      use Regexp::Grammars;
     9
    10      qr{
    11        \A<expr>\z
    12
    13        <objrule: expr>    <MATCH=term> (?! <addop> )                  # bypass
    14                         | <[operands=term]> ** <[operators=addop]>
    15
    16        <objrule: term>    <MATCH=factor> (?! <mulop> )                # bypass
    17                         | <[operands=factor]> ** <[operators=mulop]>
    18
    19        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
    20                         | \( <MATCH=expr> \)
    21
    22        <token: addop> [+-]
    23
    24        <token: mulop> [*/]
    25
    26      }x;
    27  };
    28
    29  while (my $input = <>) {
    30      chomp($input);
    31      if ($input =~ m{$rbb}) {
    32          my $tree = $/{expr};
    33          say Dumper $tree;
    34          say $tree->ceval;
    35
    36      }
    37      else {
    38          say("does not match");
    39      }
    40  }
    41
    42  BEGIN {
    43
    44    package LeftBinaryOp;
    45    use strict;
    46    use base qw(Class::Accessor);
    47
    48    LeftBinaryOp->mk_accessors(qw{operators operands});
    49
    50    my %f = (
    51      '+' => sub { shift() + shift() },
    52      '-' => sub { shift() - shift() },
    53      '*' => sub { shift() * shift() },
    54      '/' => sub { shift() / shift() },
    55    );
    56
    57    sub ceval {
    58      my $self = shift;
    59
    60      # recursively evaluate the children first
    61      my @operands = map { $_->ceval } @{$self->operands};
    62
    63      # then combine them
    64      my $s = shift @operands;
    65      for (@{$self->operators}) {
    66        $s = $f{$_}->($s, shift @operands);
    67      }
    68      return $s;
    69    }
    70
    71    package term;
    72    use base qw{LeftBinaryOp};
    73
    74    package expr;
    75    use base qw{LeftBinaryOp};
    76
    77    package factor;
    78
    79    sub ceval {
    80      my $self = shift;
    81
    82      return $self->{val};
    83    }
    84
    85    1;
    86  }
\end{verbatim}

Ejecuciones:
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ perl5.10.1 exprdamian.pl
4-2-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '4',
      'val' => '4'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' )
  ],
  '' => '4-2-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );

0
8/4/2
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '8',
      'val' => '8'
    }, 'factor' ),
    bless( {
      '' => '4',
      'val' => '4'
    }, 'factor' ),
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' )
  ],
  '' => '8/4/2',
  'operators' => [
    '/',
    '/'
  ]
}, 'term' );

1
3
$VAR1 = bless( {
  '' => '3',
  'val' => '3'
}, 'factor' );

3
2*(3+4)
$VAR1 = bless( {
  'operands' => [
    bless( {
      '' => '2',
      'val' => '2'
    }, 'factor' ),
    bless( {
      'operands' => [
        bless( {
          '' => '3',
          'val' => '3'
        }, 'factor' ),
        bless( {
          '' => '4',
          'val' => '4'
        }, 'factor' )
      ],
      '' => '3+4',
      'operators' => [
        '+'
      ]
    }, 'expr' )
  ],
  '' => '2*(3+4)',
  'operators' => [
    '*'
  ]
}, 'term' );

14
\end{verbatim}


\subsection{Reciclando una {\tt Regexp::Grammar}}
\label{subsection:recicla}

\parrafo{Ejecución}

El siguiente programa \verb|calculator.pl|
recibe como entrada una expresión en infijo.

La ejecución consta de dos bucles.
En la primera parte se inyecta a la jerarquía de
clases de los AST generados para las expresiones en infijo
una semántica que permite 
evaluar la expresión:
\begin{verbatim}
    58  require EvalCalc;
    59
    60  test_calc(
    61    'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
    62    sub { print &Data::Dumper::Dumper(shift()) },
    63  );
\end{verbatim}
En esta primera parte mostraremos además el AST
construido para la expresión infija de entrada.
\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
8-4-2
$VAR1 = bless( {
  'operands' => [
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '8', 'val' => '8' }, 'factor' )
                  ],
                  '' => '8'
                }, 'factorial' )
              ],
              '' => '8'
            }, 'power' )
          ],
          '' => '8'
        }, 'uneg' )
      ],
      '' => '8'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '4', 'val' => '4' }, 'factor' )
                  ],
                  '' => '4'
                }, 'factorial' )
              ],
              '' => '4'
            }, 'power' )
          ],
          '' => '4'
        }, 'uneg' )
      ],
      '' => '4'
    }, 'term' ),
    bless( {
      'operands' => [
        bless( {
          'operands' => [
            bless( {
              'operands' => [
                bless( {
                  'operands' => [
                    bless( { '' => '2', 'val' => '2' }, 'factor' )
                  ],
                  '' => '2'
                }, 'factorial' )
              ],
              '' => '2'
            }, 'power' )
          ],
          '' => '2'
        }, 'uneg' )
      ],
      '' => '2'
    }, 'term' )
  ],
  '' => '8-4-2',
  'operators' => [
    '-',
    '-'
  ]
}, 'expr' );
2
\end{verbatim}
\end{latexonly}
%{{{ % raw html perldeb
\begin{rawhtml}
<pre>
pl@nereida:~/Lregexpgrammars/demo$ ./calculator.pl
Evaluating infix arithmetic expressions (CTRL-D to end in unix)
<span class='lightblue'>8-4-2</span>
$VAR1 = bless( {
  'operands' =&gt; [
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '8', 'val' =&gt; '8' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '8'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '8'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '8'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '8'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '4', 'val' =&gt; '4' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '4'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '4'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '4'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '4'
    }, <span class='lightblue'>'term'</span> ),
    bless( {
      'operands' =&gt; [
        bless( {
          'operands' =&gt; [
            bless( {
              'operands' =&gt; [
                bless( {
                  'operands' =&gt; [
                    bless( { '' =&gt; '2', 'val' =&gt; '2' }, <span class='lightblue'>'factor'</span> )
                  ],
                  '' =&gt; '2'
                }, <span class='lightblue'>'factorial'</span> )
              ],
              '' =&gt; '2'
            }, <span class='lightblue'>'power'</span> )
          ],
          '' =&gt; '2'
        }, <span class='lightblue'>'uneg'</span> )
      ],
      '' =&gt; '2'
    }, <span class='lightblue'>'term'</span> )
  ],
  '' =&gt; '8-4-2',
  <span class='red'>'operators' =&gt; [
    '-',
    '-'
  ]</span>
}, <span class='lightblue'>'expr'</span> );
2
</pre>
\end{rawhtml}
%}}}
Observamos que la asociatividad es la correcta.
El \verb|2| final es el resultado de la evaluación de
\verb|8-4-2|.

La estructura del árbol se corresponde con la de la gramática:
\begin{verbatim}
 8  my $rbb = do {
 9      use Regexp::Grammars;
10
11      qr{
12        \A<expr>\z
13
14        <objrule: expr>      <[operands=term]> ** <[operators=addop]>
15
16        <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
17
18        <objrule: uneg>      <[operators=minus]>* <[operands=power]>
19
20        <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
21
22        <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
23
24        <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
25                           | \( <MATCH=expr> \)
26
27        <token: addop>        [+-]
28
29        <token: mulop>        [*/]
30
31        <token: powerop>      \*\*|\^
32
33        <token: minus>        - <MATCH=(?{ 'NEG' })>
34
35      }x;
36  };
\end{verbatim}

Ahora, en una segunda parte sobreescribimos los métodos
\verb|sem| que describen la semántica para producir una traducción
de infijo a postfijo:
\begin{verbatim}
 66  require PostfixCalc;
 67  test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
\end{verbatim}
Ahora al proporcionar la entrada \verb|6--3!| obtenemos:
\begin{verbatim}
Translating expressions to postfix (CTRL-D to end in unix)
6--3!
6 3 ! ~ -
\end{verbatim}
Aquí \verb|~| es el operador de negación unaria y \verb|!| es el operador
factorial.

\parrafo{Estructura de la aplicación}

Estos son los ficheros que integran la aplicación:

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ tree
.
|-- EvalCalc.pm            # Soporte para la evaluación de la expresión: sem
|-- Operator.pm            # Soporte a las clases nodo: recorridos
|-- PostfixCalc.pm         # Soporte para la traducción a postfijo: sem
`-- calculator.pl          # programa principal
\end{verbatim}

\parrafo{Programa principal}

En el programa principal definimos la gramática
y escribimos una subrutina \verb|test_calc|
que realiza el parsing. 

\begin{latexonly}
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
 1    #!/usr/bin/env perl5.10.1
 2    use strict;
 3    use warnings;
 4    use 5.010;
 5    use Data::Dumper;
 6    $Data::Dumper::Indent = 1;
 7  
 8    my $rbb = do {
 9        use Regexp::Grammars;
10  
11        qr{
12          \A<expr>\z
13  
14          <objrule: expr>      <[operands=term]> ** <[operators=addop]>
15  
16          <objrule: term>      <[operands=uneg]> ** <[operators=mulop]>
17  
18          <objrule: uneg>      <[operators=minus]>* <[operands=power]>
19  
20          <objrule: power>     <[operands=factorial]> ** <[operators=powerop]>
21  
22          <objrule: factorial> <[operands=factor]>  <[operators=(!)]>*
23  
24          <objrule: factor>    <val=([+-]?\d+(?:\.\d*)?)>
25                             | \( <MATCH=expr> \)
26  
27          <token: addop>        [+-]
28  
29          <token: mulop>        [*/]
30  
31          <token: powerop>      \*\*|\^
32  
33          <token: minus>        - <MATCH=(?{ 'NEG' })>
34  
35        }x;
36    };
37  
38    sub test_calc {
39      my $prompt = shift;
40      my $handler = shift;
41  
42      say $prompt;
43      while (my $input = <>) {
44          chomp($input);
45          if ($input =~ m{$rbb}) {
46              my $tree = $/{expr};
47              $handler->($tree) if $handler;
48  
49              say $tree->ceval;
50  
51          }
52          else {
53              say("does not match");
54          }
55      }
56    }
57  
58    require EvalCalc;
59  
60    test_calc(
61      'Evaluating infix arithmetic expressions (CTRL-D to end in unix) ',
62      sub { print &Data::Dumper::Dumper(shift()) },
63    );
64  
65  
66    require PostfixCalc;
67    test_calc('Translating expressions to postfix (CTRL-D to end in unix) ');
\end{verbatim}
\end{latexonly}
%{{{ % perl code in HTML
\begin{rawhtml}

<pre>
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n calculator.pl
<span class="synLinenum">    1</span>   <span class="synComment">#!/usr/bin/env perl5.10.1</span>
<span class="synLinenum">    2</span>   <span class="synStatement">use strict</span>;
<span class="synLinenum">    3</span>   <span class="synStatement">use warnings</span>;
<span class="synLinenum">    4</span>   <span class="synStatement">use </span><span class="synConstant">5.010</span>;
<span class="synLinenum">    5</span>   <span class="synStatement">use </span>Data::Dumper;
<span class="synLinenum">    6</span>   <span class="synIdentifier">$</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Indent</span> = <span class="synConstant">1</span>;
<span class="synLinenum">    7</span> 
<span class="synLinenum">    8</span>   <span class="synStatement">my</span> <span class="synIdentifier">$rbb</span> = <span class="synStatement">do</span> {
<span class="synLinenum">    9</span>       <span class="synStatement">use </span>Regexp::Grammars;
<span class="synLinenum">   10</span> 
<span class="synLinenum">   11</span>       <span class="synConstant">qr{</span>
<span class="synLinenum">   12</span> <span class="synConstant">        </span><span class="synSpecial">\A</span><span class="synConstant">&lt;expr&gt;</span><span class="synSpecial">\z</span>
<span class="synLinenum">   13</span> 
<span class="synLinenum">   14</span> <span class="synConstant">        &lt;objrule: expr&gt;      &lt;</span><span class="synSpecial">[operands=term]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=addop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   15</span> 
<span class="synLinenum">   16</span> <span class="synConstant">        &lt;objrule: term&gt;      &lt;</span><span class="synSpecial">[operands=uneg]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=mulop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   17</span> 
<span class="synLinenum">   18</span> <span class="synConstant">        &lt;objrule: uneg&gt;      &lt;</span><span class="synSpecial">[operators=minus]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operands=power]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   19</span> 
<span class="synLinenum">   20</span> <span class="synConstant">        &lt;objrule: power&gt;     &lt;</span><span class="synSpecial">[operands=factorial]</span><span class="synConstant">&gt; </span><span class="synSpecial">**</span><span class="synConstant"> &lt;</span><span class="synSpecial">[operators=powerop]</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   21</span> 
<span class="synLinenum">   22</span> <span class="synConstant">        &lt;objrule: factorial&gt; &lt;</span><span class="synSpecial">[operands=factor]</span><span class="synConstant">&gt;  &lt;</span><span class="synSpecial">[operators=(!)]</span><span class="synConstant">&gt;</span><span class="synSpecial">*</span>
<span class="synLinenum">   23</span> 
<span class="synLinenum">   24</span> <span class="synConstant">        &lt;objrule: factor&gt;    &lt;val=</span><span class="synSpecial">([+-]?\d+(?:\.\d*)?)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   25</span> <span class="synConstant">                           | </span><span class="synSpecial">\(</span><span class="synConstant"> &lt;MATCH=expr&gt; </span><span class="synSpecial">\)</span>
<span class="synLinenum">   26</span> 
<span class="synLinenum">   27</span> <span class="synConstant">        &lt;token: addop&gt;        </span><span class="synSpecial">[+-]</span>
<span class="synLinenum">   28</span> 
<span class="synLinenum">   29</span> <span class="synConstant">        &lt;token: mulop&gt;        </span><span class="synSpecial">[*/]</span>
<span class="synLinenum">   30</span> 
<span class="synLinenum">   31</span> <span class="synConstant">        &lt;token: powerop&gt;      </span><span class="synSpecial">\*\*</span><span class="synConstant">|</span><span class="synSpecial">\^</span>
<span class="synLinenum">   32</span> 
<span class="synLinenum">   33</span> <span class="synConstant">        &lt;token: minus&gt;        - &lt;MATCH=</span><span class="synSpecial">(?</span><span class="synConstant">{ 'NEG' </span>}<span class="synSpecial">)</span><span class="synConstant">&gt;</span>
<span class="synLinenum">   34</span> 
<span class="synLinenum">   35</span> <span class="synConstant">      }x</span>;
<span class="synLinenum">   36</span>   };
<span class="synLinenum">   37</span> 
<span class="synLinenum">   38</span>   <span class="synStatement">sub </span><span class="synIdentifier">test_calc </span>{
<span class="synLinenum">   39</span>     <span class="synStatement">my</span> <span class="synIdentifier">$prompt</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   40</span>     <span class="synStatement">my</span> <span class="synIdentifier">$handler</span> = <span class="synStatement">shift</span>;
<span class="synLinenum">   41</span> 
<span class="synLinenum">   42</span>     <span class="synStatement">say</span> <span class="synIdentifier">$prompt</span>;
<span class="synLinenum">   43</span>     <span class="synStatement">while</span> (<span class="synStatement">my</span> <span class="synIdentifier">$input</span> = &lt;&gt;) {
<span class="synLinenum">   44</span>         <span class="synStatement">chomp</span>(<span class="synIdentifier">$input</span>);
<span class="synLinenum">   45</span>         <span class="synStatement">if</span> (<span class="synIdentifier">$input</span> =~ <span class="synStatement">m{</span><span class="synIdentifier">$rbb</span><span class="synStatement">}</span>) {
<span class="synLinenum">   46</span>             <span class="synStatement">my</span> <span class="synIdentifier">$tree</span> = <span class="synIdentifier">$/</span>{expr};
<span class="synLinenum">   47</span>             <span class="synIdentifier">$handler</span>-&gt;(<span class="synIdentifier">$tree</span>) <span class="synStatement">if</span> <span class="synIdentifier">$handler</span>;
<span class="synLinenum">   48</span> 
<span class="synLinenum">   49</span>             <span class="synStatement">say</span> <span class="synIdentifier">$tree-&gt;ceval</span>;
<span class="synLinenum">   50</span> 
<span class="synLinenum">   51</span>         }
<span class="synLinenum">   52</span>         <span class="synStatement">else</span> {
<span class="synLinenum">   53</span>             <span class="synStatement">say</span>(<span class="synConstant">&quot;does not match&quot;</span>);
<span class="synLinenum">   54</span>         }
<span class="synLinenum">   55</span>     }
<span class="synLinenum">   56</span>   }
<span class="synLinenum">   57</span> 
<span class="synLinenum">   58</span>   <span class="synStatement">require</span> EvalCalc;
<span class="synLinenum">   59</span> 
<span class="synLinenum">   60</span>   test_calc(
<span class="synLinenum">   61</span>     <span class="synConstant">'Evaluating infix arithmetic expressions (CTRL-D to end in unix) '</span>,
<span class="synLinenum">   62</span>     <span class="synStatement">sub </span>{ <span class="synStatement">print</span> <span class="synIdentifier">&amp;</span><span class="synType">Data::Dumper::</span><span class="synIdentifier">Dumper</span>(<span class="synStatement">shift</span>()) },
<span class="synLinenum">   63</span>   );
<span class="synLinenum">   64</span> 
<span class="synLinenum">   65</span> 
<span class="synLinenum">   66</span>   <span class="synStatement">require</span> PostfixCalc;
<span class="synLinenum">   67</span>   test_calc(<span class="synConstant">'Translating expressions to postfix (CTRL-D to end in unix) '</span>);
</pre>

\end{rawhtml}
%}}}

Los nodos del AST poseen un método \verb|ceval| que se encarga de 
realizar la traducción del nodo.

\parrafo{Las Clases de nodos del AST}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n Operator.pm
   1  #   Class hierarchy diagram:
   2  #  $ vgg -t 'Operator(LeftBinaryOp(expr,term),RightBinaryOp(power),PreUnaryOp(uneg),PostUnaryOp(factorial))'
   3  #                           +--------+
   4  #                           |Operator|
   5  #                           +--------+
   6  #          .---------------.----^--------.-------------.
   7  #    +------------+ +-------------+ +----------+ +-----------+
   8  #    |LeftBinaryOp| |RightBinaryOp| |PreUnaryOp| |PostUnaryOp|
   9  #    +------------+ +-------------+ +----------+ +-----------+
  10  #      .---^--.        |              |               |
  11  #    +----+ +----+  +-----+         +----+       +---------+
  12  #    |expr| |term|  |power|         |uneg|       |factorial|
  13  #    +----+ +----+  +-----+         +----+       +---------+
  14  #
  15  #
  16  # NOTE: package "factor" actually implements numbers and is
  17  #       outside this hierarchy
  18  #
  19  package Operator;
  20  use strict;
  21  use Carp;
  22
  23  sub Operands {
  24    my $self = shift;
  25
  26    return () unless exists $self->{operands};
  27    return @{$self->{operands}};
  28  }
  29
  30  sub Operators {
  31    my $self = shift;
  32
  33    return () unless exists $self->{operators};
  34    return @{$self->{operators}};
  35  }
  36
  37  sub sem {
  38    confess "not defined sem";
  39  }
  40
  41  sub make_sem {
  42    my $class = shift;
  43    my %semdesc = @_;
  44
  45    for my $class (keys %semdesc) {
  46      my %sem = %{$semdesc{$class}};
  47
  48      # Install 'sem' method in $class
  49      no strict 'refs';
  50      no warnings 'redefine';
  51      *{$class."::sem"} = sub {
  52        my ($self, $op) = @_;
  53        $sem{$op}
  54      };
  55    }
  56  }
  57
  58  package LeftBinaryOp;
  59  use base qw{Operator};
  60
  61  sub ceval {
  62    my $self = shift;
  63
  64    # recursively evaluate the children first
  65    my @operands = map { $_->ceval } $self->Operands;
  66
  67    # then combine them
  68    my $s = shift @operands;
  69    for ($self->Operators) {
  70      $s = $self->sem($_)->($s, shift @operands);
  71    }
  72    return $s;
  73  }
  74
  75  package RightBinaryOp;
  76  use base qw{Operator};
  77
  78  sub ceval {
  79    my $self = shift;
  80
  81    # recursively evaluate the children first
  82    my @operands = map { $_->ceval } $self->Operands;
  83
  84    # then combine them
  85    my $s = pop @operands;
  86    for (reverse $self->Operators) {
  87      $s = $self->sem($_)->(pop @operands, $s);
  88    }
  89    return $s;
  90  }
  91
  92  package PreUnaryOp;
  93  use base qw{Operator};
  94
  95  sub ceval {
  96    my $self = shift;
  97
  98    # recursively evaluate the children first
  99    my @operands = map { $_->ceval } $self->Operands;
 100
 101    # then combine them
 102    my $s = shift @operands;
 103    for (reverse $self->Operators) {
 104      $s = $self->sem($_)->($s);
 105    }
 106    return $s;
 107  }
 108
 109  package PostUnaryOp;
 110  use base qw{Operator};
 111
 112  sub ceval {
 113    my $self = shift;
 114
 115    # recursively evaluate the children first
 116    my @operands = map { $_->ceval } $self->Operands;
 117
 118    # then combine them
 119    my $s = shift @operands;
 120    for ($self->Operators) {
 121      $s = $self->sem($_)->($s);
 122    }
 123    return $s;
 124  }
 125
 126  package term;
 127  use base qw{LeftBinaryOp};
 128
 129  package expr;
 130  use base qw{LeftBinaryOp};
 131
 132  package power;
 133  use base qw{RightBinaryOp};
 134
 135  package uneg;
 136  use base qw{PreUnaryOp};
 137
 138  package factorial;
 139  use base qw{PostUnaryOp};
 140
 141  package factor;
 142
 143  sub ceval {
 144    my $self = shift;
 145
 146    return $self->{val};
 147  }
 148
 149  1;
\end{verbatim}

\parrafo{Definiendo {\tt sem} para la evaluación de la expresión}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n EvalCalc.pm
 1  package EvalCalc;
 2  use strict;
 3  use Carp;
 4
 5  use Operator;
 6
 7  ####
 8  sub f {
 9    $_[0]>1?$_[0]*f($_[0]-1):1;
10  }
11
12  sub fac {
13    my $n = shift;
14
15    confess "Not valid number" unless $n =~ /^\d+$/;
16    f($n);
17  };
18
19  my $s = sub { shift() **  shift() };
20
21  Operator->make_sem(
22     expr => {
23        '+' => sub { shift()  +  shift() },
24        '-' => sub { shift()  -  shift() },
25     },
26     term => {
27       '*' => sub { shift()  *  shift() },
28       '/' => sub { shift()  /  shift() },
29     },
30     power => {
31        '^'  => $s,
32        '**' => $s,
33     },
34     uneg => {
35        'NEG' => sub { -shift() },
36     },
37     factorial => {
38        '!' => \&fac,
39     },
40  );
41
42  1;
\end{verbatim}

\parrafo{Definiendo {\tt sem} para la traducción a postfijo}

\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo/calculator$ cat -n PostfixCalc.pm
 1  package PostfixCalc;
 2  use strict;
 3
 4  use Operator;
 5
 6  # Modify semantics: now translate to postfix
 7  my $powers = sub { shift().' '.shift().' **' };
 8
 9  Operator->make_sem(
10     expr => {
11        '+' => sub { shift().' '.shift().' +'  },
12        '-' => sub { shift().' '.shift().' -' },
13      },
14      term => {
15        '*' => sub { shift().' '.shift().' *'  },
16        '/' => sub { shift().' '.shift().' /' },
17      },
18      power => {
19        '^'  => $powers,
20        '**' => $powers,
21      },
22      uneg => {
23         # use ~ for unary minus
24        'NEG' => sub { shift().' ~' },
25      },
26      factorial => {
27        '!' => sub { shift().' !'},
28      },
29  );
30
31  1;
\end{verbatim}


\begin{exercise}
\begin{itemize}
\item Explique el significado de la primera línea del programa principal
\begin{verbatim}
pl@nereida:~/Lregexpgrammars/demo$ cat -n calculator.pl
   1  #!/usr/bin/env perl5.10.1
\end{verbatim}
\item Explique el significado de \verb|$handler| en \verb|test_calc|:
\begin{verbatim}
  42  sub test_calc {
  43    my $prompt = shift;
  44    my $handler = shift;
  45
  46    say $prompt;
  47    while (my $input = <>) {
  48        chomp($input);
  49        if ($input =~ m{$rbb}) {
  50            my $tree = $/{expr};
  51            $handler->($tree) if $handler;
  52
  53            say $tree->ceval;
  54
  55        }
  56        else {
  57            say("does not match");
  58        }
  59    }
  60  }
\end{verbatim}

\item Aisle las funciones relacionadas con la creación de semántica
como \verb|make_sem|, \verb|fac| y las llamadas a \verb|make_sem|
en un módulo \verb|Calculator::Semantics| aparte. 

\item Añada un traductor de infijo a prefijo al código presentado 
en esta sección. Una expresión como
\verb|2*3+4|  se traducirá como \verb|+ * 2 3 4|
\end{itemize}
\end{exercise}
  
\subsectionpractica{Calculadora con {\tt Regexp::Grammars}}

\begin{itemize}
\item Reforme la estructura del ejemplo para que tenga una jerarquía
de desarrollo de acuerdo a los estándares de Perl. Use \perldoc{h2xs} 
o bien \cpan{Module::Starter}. Use el espacio de nombres \verb|Calculator|.
Mueva el módulo \verb|Operator| a \verb|Calculator::Operator|.
Lea el capítulo \lhp{Modulos}{170} de los apuntes de LHP.

\item Defina el conjunto de pruebas que deberá pasar su traductor.
Añádalas como pruebas \verb|TODO|. Cuando la funcionalidad 
a comprobar esté operativa cambie su estatus.

\item Añada variables y la expresión de asignación:

\begin{verbatim}
b = a = 4*2
\end{verbatim}
que será traducida a postfijo como:

\begin{verbatim}
4 2 * a = b =
\end{verbatim}
El operador de asignación es asociativo a derechas.
El valor devuelto por una expresión de asignación es el valor asignado.

Use un hash para implantar la relación nombre-valor
en el caso de la evaluación

\item Introduzca la expresión bloque:

\begin{verbatim}
c = { a = 4; b = 2*a }
\end{verbatim}

Los bloques son listas entre llaves de expresiones separadas por punto y coma.
El valor retornado por una expresión bloque es el último evaluado 
en el bloque.

El símbolo de arranque de la gramática (esto es, el patrón regular
contra el que hay que casar) será la expresión bloque.

\item Introduzca las expresiones de comparación \verb|<|, \verb|>|, \verb|<=|, \verb|>=|, \verb|==| y \verb|!=|
con la prioridad adecuada. Tenga en cuenta que una expresión como:
\begin{verbatim}
a = b+2 > c*4
\end{verbatim}
deberá entenderse como
\begin{verbatim}
a = ((b+2) > (c*4))
\end{verbatim}
Esto es, se traducirá como:
\begin{verbatim}
b 2 + c 4 * > a =
\end{verbatim}

\item Introduzca la expresión \verb|if ... then ... else|. La parte del \verb|else|
será opcional:
\begin{verbatim}
c = if a > 0 then { a = a -1; 2*a } else { b + 2 };
d = if a > 0 then { a = b -1; 2*b }; 
\end{verbatim}
un \verb|else| casa con el \verb|if| mas cercano. 
La sentencia:
\begin{verbatim}
if (a > 0) then if (b > 0) then {5} else {6}
\end{verbatim}
se interpreta como:
\begin{verbatim}
if (a > 0) then (if (b > 0) then {5} else {6})
\end{verbatim}
y no como:
\begin{verbatim}
if (a > 0) then (if (b > 0) then {5}) else {6}
\end{verbatim}
Se traducirá como:
\begin{verbatim}
        a
        0
        >
        jz endif124
        b
        0
        >
        jz else125
        5
        j endif126
:else125
        6
:endif124
:endif125
        ...

\end{verbatim}
\item Escriba un intérprete de la máquina orientada a pila definida en los apartados anteriores.
El código generado debería poder ejecutarse correctamente en el intérprete.
\end{itemize}
