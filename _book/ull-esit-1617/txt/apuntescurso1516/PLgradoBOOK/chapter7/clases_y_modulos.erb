
Véase el capítulo
\htmladdnormallink{Classes, Objects, and Variables}{http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_classes.html}
del libro {\it Programming Ruby.  The Pragmatic Programmer's Guide}

\section{Definición de una Clase Simple}

\subsection{Creando una Clase}

\subsubsection{Enlaces}
\begin{itemize}
  \item \htmladdnormallink{GIST: Ruby OOP example}{https://gist.github.com/3548473}
  \item \htmladdnormallink{GIST: Happy OOP examples using Ruby}{https://gist.github.com/647997}
  \item \htmladdnormallink{Los gist anteriores en subversion (orion)}{https://orion.pcg.ull.es/subversion/wsvn/casiano/LPP/rubytesting/oop/?\#acc7f2cd2e16b632d1f068c0979fb7ee1}
  \item \htmladdnormallink{calling\_initialize}{https://orion.pcg.ull.es/subversion/wsvn/casiano/LPP/rubytesting/calling\_initialize.rb}
\end{itemize}

\subsection{Instanciando un Punto}

\subsection{Inicializando un Punto}

El método \verb|initialize| es privado:

\begin{verbatim}
$ cat -n calling_initialize.rb 
     1  class Tutu
     2    def initialize(a,b)
     3      @a, @b = a,b
     4    end
     5  
     6    def titi
     7      initialize(2,3)
     8    end
     9  end
    10  if __FILE__ == $0
    11    x = Tutu.new(4,5)
    12    z = x.titi()
    13    puts z.class
    14    puts z
    15    x.initialize(4,2)
    16  end
\end{verbatim}

\begin{verbatim}
casiano@exthost:~/LPPsrc/151012$ ruby calling_initialize.rb 
Array
2
3
calling_initialize.rb:15:in `<main>': private method `initialize' called for #<Tutu:0x8bb576c @a=2, @b=3> (NoMethodError)
casiano@exthost:~/LPPsrc/151012$ 
\end{verbatim}

Aviso a los programadores Java:
\begin{verbatim}
casiano@exthost:~/LPPsrc/151012$ cat -n instance_variables_of_a_class.rb 
     1  class Tutu
     2    @x = 4
     3    @y = 9
     4  
     5    def initialize(x,y)
     6      @x, @y = x, y
     7    end
     8    def self.x
     9      @x
    10    end
    11  
    12    def self.y
    13      @y
    14    end
    15  
    16    def x
    17      @x
    18    end
    19  
    20    def y
    21      @y
    22    end
    23  end
    24  
    25  if __FILE__ == $0
    26    puts Tutu.x        # 4
    27    puts Tutu.y        # 9
    28    z = Tutu.new(5,7)
    29    puts z.x           # 5
    30    puts z.y           # 7
    31  end
\end{verbatim}

\begin{verbatim}
casiano@exthost:~/LPPsrc/151012$ ruby instance_variables_of_a_class.rb 
4
9
5
7
\end{verbatim}

\subsection{Definiendo un método {\tt to\_s}}

\subsection{Acceso a los Atributos}

\subsubsection{Utilización de  los Setters Dentro de una Clase}
Una vez que se ha definido un setter como \verb|x=| podemos sentirnos tentados de utilizarlo
dentro de otro método de instancia de la clase.
\begin{verbatim}
casiano@exthost:~/LPPsrc/221012$ cat -n setters.rb
     1  class Tutu
     2    attr_accessor :n
     3  
     4    def initialize(n)
     5      @n = n
     6    end
     7  
     8    def to_s
     9      "#{n*2}"
    10    end
    11  
    12    def square
    13      n = n * n #n here is a local variable!
    14    end
    15  
    16    def square2
    17      self.n = n * n
    18    end
    19  end
    20  
    21  if __FILE__ == $0
    22    x = Tutu.new(ARGV.shift || 4)
    23    puts x # to_s gets called: 8
    24    begin
    25      x.square
    26      rescue
    27        puts "Raised exception '#{$!.class}'. Message: <#{$!}>"
    28    end
    29    x.square2 # 32 = 16 *2
    30    puts x
    31  end
\end{verbatim}

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby setters.rb
8
Raised exception 'NoMethodError'. Message: <undefined method `*' for nil:NilClass>
32
\end{verbatim}


\subsubsection{Los Accessors como {\tt attr\_accessor} se Invocan Fuera de las Definiciones de Métodos}
\verb|attr_reader| et al. son proveídos por la clase \verb|Module|.
todas las clases son módulos:
\begin{verbatim}
ruby-1.9.2-head :004 > Class.class
 => Class 
ruby-1.9.2-head :005 > Class.superclass
 => Module 
ruby-1.9.2-head :006 > Class.superclass.superclass
 => Object 
ruby-1.9.2-head :007 > Class.superclass.superclass.superclass
 => BasicObject 
ruby-1.9.2-head :008 > Class.ancestors
 => [Class, Module, Object, InteractiveEditor::Editors, 
     Wirble::Shortcuts, 
     PP::ObjectMixin, 
     Kernel, BasicObject] 
\end{verbatim}

\begin{exercise}
¿\verb|attr_accessor| es un método de instancia o de clase?
\end{exercise}

\subsection{Definiendo Operadores}
\label{subsection:definiendooperadores}

\begin{verbatim}
[~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ cat -n point.rb 
     1	class Point
     2	  attr_reader :x, :y   # Define accessor methods for our instance variables
     3	
     4	  include Comparable
     5	  include Enumerable
     6	
     7	  def initialize(x,y)
     8	    @x,@y = x, y
     9	  end
    10	
    11	  def to_s        # Return a String that represents this point
    12	    "(#@x,#@y)"   # Just interpolate the instance variables into a string
    13	  end
    14	
    15	  def chuchu
    16	    "Point: chuchu"
    17	  end
    18	  private :chuchu
    19	
    20	  def +(other)         # Define + to do vector addition
    21	    Point.new(@x + other.x, @y + other.y)
    22	  end
    23	
    24	  def -@               # Define unary minus to negate both coordinates
    25	    Point.new(-@x, -@y)
    26	  end
    27	
    28	  def *(scalar)        # Define * to perform scalar multiplication
    29	    return Point.new(@x*scalar,   @y*scalar) if scalar.is_a? Numeric
    30	    return Point.new(@x*scalar.x, @y*scalar.y) if scalar.is_a? Point
    31	  end
    32	
    33	  def coerce(other)
    34	    [self, other]
    35	  end
    36	
    37	  def [](index)
    38	    case index
    39	    when 0, -2 then @x         # Index 0 (or -2) is the X coordinate
    40	    when 1, -1 then @y         # Index 1 (or -1) is the Y coordinate
    41	
    42	    when :x, "x" then @x       # Hash keys as symbol or string for X
    43	    when :y, "y" then @y       # Hash keys as symbol or string for Y
    44	    else nil               # Arrays and hashes just return nil on bad indexes
    45	    end
    46	  end
    47	
    48	  def hash
    49	    code = 17
    50	    code = 37*code + @x.hash
    51	    code = 37*code + @y.hash
    52	    code
    53	  end
    54	
    55	  def eql?(o)
    56	    return @x.eql?(o.x) && @y.eql?(o.y) if o.instance_of? Point
    57	    false
    58	  end
    59	
    60	  def ==(o)
    61	    return @x == o.x && @y  == o.y if o.instance_of? Point
    62	    false
    63	  end
    64	
    65	  def <=>(o)
    66	    return nil unless o.instance_of? Point
    67	    @x*@x+@y*@y <=> o.x*o.x+o.y*o.y
    68	  end
    69	
    70	end
    71	
    72	if __FILE__ == $0
    73	  p = Point.new(1,2)
    74	  q = Point.new(1,1)
    75	  puts p
    76	  puts -p
    77	  puts p+q
    78	  puts p*q
    79	  puts p*2
    80	  puts 2*p
    81	
    82	  puts "#{p[0]}, #{p[1]}"
    83	  puts "#{p[-2]}, #{p[-1]}"
    84	  puts "#{p[:x]}, #{p[:y]}"
    85	  puts "#{p['x']}, #{p['y']}"
    86	
    87	  m = { p => 1, q => 2 }
    88	  puts m[p]
    89	  puts m[q]
    90	
    91	
    92	  # It is not a total order relation
    93	  r = Point.new(2, 1)
    94	  puts p > r
    95	  puts r > p
    96	  puts r == p
    97	  puts q < p
    98	  puts "#{[p, q, r].sort}"
    99	  puts [p, q, r].min
   100	  puts [p, q, r, Point.new(4,3)].max
   101	
   102	
   103	end
\end{verbatim}

\subsection{Tabla de Operadores en Ruby}
\begin{itemize}
\item
\htmladdnormallink{Tabla de Operadores en Ruby}{http://www.techotopia.com/index.php/Ruby_Operator_Precedence\#Operator_Precedence_Table}
\end{itemize}
The following table provides a reference when you need to know the
operator precedence used by Ruby. The table lists all operators from
highest precedence to lowest.

\begin{rawhtml}
<table border="1" cellspacing="0">
<tr style="background:#efefef;">
        <caption>Ruby operators (highest to lowest precedence)</caption>
<tr style="background:#efefef;">
                <th>Method</th>
                <th>Operator</th>
                <th>Description</th>
        </tr>

        <tr class="firstRow">
                        <td>Yes</td>
                <td><code>[ ]</code> <code>[ ]=</code></td>
                <td>Element reference, element set</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>**</code></td>
                <td>Exponentiation (raise to the power)</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>!</code> <code>~</code> <code>+</code> <code>-</code></td>
                <td>Not, complement, unary plus and minus (method names for the last two are <code>+@</code> and <code>-@</code>)</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>*</code> <code>/</code> <code>%</code></td>
                <td>Multiply, divide, and modulo</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>+</code> <code>-</code></td>
                <td>Addition and subtraction</td>
        </tr><tr>

                <td>Yes</td>
                <td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
                <td>Right and left bitwise shift</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>&amp;</code></td>
                <td>Bitwise `AND'</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>^</code> <code>|</code></td>
                <td>Bitwise exclusive `OR' and regular `OR'</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
                <td>Comparison operators</td>
        </tr><tr>
                <td>Yes</td>
                <td><code>&lt;=&gt;</code> <code>==</code> <code>===</code> <code>!=</code> <code>=~</code> <code>!~</code></td>
                <td>Equality and pattern match operators (<code>!=</code> and <code>!~</code> may not be defined as methods)</td>
        </tr><tr>
                <td></td>
                <td><code>&amp;&amp;</code></td>
                <td>Logical `AND'</td>
        </tr><tr>
                <td></td>
                <td><code>||</code></td>
                <td>Logical `AND'</td>
        </tr><tr>
                <td></td>
                <td><code>..</code> <code>...</code></td>
                <td>Range (inclusive and exclusive)</td>
        </tr><tr>
                <td></td>
                <td><code>?&nbsp;:</code></td>
                <td>Ternary if-then-else</td>
        </tr><tr>
                <td></td>
                <td><code>=</code> <code>%=</code> <code></code>{ <code>/=</code> <code>-=</code> <code>+=</code> <code>|=</code> <code>&amp;=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>*=</code> <code>&amp;&amp;=</code> <code>||=</code> <code>**=</code></td>
                <td>Assignment</td>
        </tr><tr>
                <td></td>
                <td><code>defined?</code></td>
                <td>Check if specified symbol defined</td>
        </tr><tr>
                <td></td>
                <td><code>not</code></td>
                <td>Logical negation</td>
        </tr><tr>
                <td></td>
                <td><code>or</code> <code>and</code></td>
                <td>Logical composition</td>
        </tr><tr>
                <td></td>
                <td><code>if</code> <code>unless</code> <code>while</code> <code>until</code></td>
                <td>Expression modifiers</td>
        </tr><tr>

                <td></td>
                <td><code>begin/end</code></td>
                <td>Block expression</td>
        </tr>
</table>
<p>Operators with a <i>Yes</i> in the method column are actually methods, and as such may be overridden.
</p><p><br />
\end{rawhtml}

\subsubsection{Comprobación de Tipos y Tipado Pato (Duck Typing)}

\begin{quote}
Red or yellow, black or white, they are all ducks in the VM’s sight. 
\end{quote}

\label{subsub:tiposypatos}
\begin{verbatim}
casiano@exthost:~/LPPsrc/161012$ cat -n type_versus_class_checking.rb 
     1	# page 75
     2	require "stringio"
     3	class Tutu
     4	  def titi_type_check(x) # duck typing style
     5	    raise "Error in titi_type_check" unless x.respond_to? :"<<"
     6	
     7	    x << " chazam!"
     8	  end
     9	
    10	  def titi_class_check(x)
    11	    raise "Error in titi_class_check" unless x.is_a? IO
    12	    x.each_line do |line|
    13	      print "#{line.length} "
    14	    end
    15	    puts ""
    16	  end
    17	end
    18	    
    19	
    20	if __FILE__ == $0
    21	  t = Tutu.new
    22	  p t.titi_type_check("ban ban") # "ban ban chazam!"
    23	  p t.titi_type_check([1,2,3])   # [1, 2, 3, " chazam!"] 
    24	  begin
    25	  p t.titi_type_check(6) # can't convert String ...
    26	  rescue
    27	    puts "t.titi_type_check(6) fails:\n\tException type: <#{$!.class}>\n\tmessage: <#{$!}>"
    28	  end
    29	
    30	  t.titi_class_check(IO.open(File.open($0).to_i)) # 10 19 ...
    31	  begin
    32	    t.titi_class_check(StringIO.open("Hello World!\nHello Mars!")) # Error in titi_class_check
    33	  rescue
    34	    puts "t.titi_class_check fails with StringIO:\n\tException type: <#{$!.class}>\n\tmessage: <#{$!}>"
    35	  end
    36	end
\end{verbatim}

\begin{verbatim}
casiano@exthost:~/LPPsrc/161012$ ruby  type_versus_class_checking.rb 
"ban ban chazam!"
[1, 2, 3, " chazam!"]
t.titi_type_check(6) fails:
	Exception type: <TypeError>
	message: <can't convert String into Integer>
10 19 11 45 64 1 20 6 1 26 56 26 30 8 12 6 4 5 1 18 15 53 58 8 52 9 92 6 1 62 8 95 9 104 6 4 
t.titi_class_check fails with StringIO:
	Exception type: <RuntimeError>
	message: <Error in titi_class_check>
\end{verbatim}

Aunque quizá sea larga y requiera para su comprensión completa 
mas conocimientos de los que tenemos en este punto,
escuchar la charla 
\emph{
\htmladdnormallink{Less: The Path to a Better Design}{http://vimeo.com/53154357} por \cei{Sandi Metz}
}
en Vimeo puede resultar útil. 
Metz 
muestra como el uso de \cei{Tipado Pato} (\cei{Duck Typing}) 
puede ayudar a desacoplar nuestras
clases, mejorando así nuestros diseños y haciéndo que nuestro software 
sea mas adaptable a los cambios que necesariamente habrán de sobrevenir durante 
su vida útil.

Véanse algunos comentarios de 
\htmladdnormallink{Nathan Youngman}{http://nathany.com/poodr} sobre la lectura 
del libro
\htmladdnormallink{"Practical Object Oriented Design in Ruby: An Agile Primer"}{http://my.safaribooksonline.com/book/programming/ruby/9780132930895}
de Sandi Metz:
\begin{quote}
Procedural programs operate by performing a series of steps, whereas
object-oriented programs are about sending messages.

When one object tells another to perform a series of steps, it knows
too much! To minimize dependencies, an object needs to ask for what
it wants, and trust that the receiver takes the necessary steps.
It doesn't need to know the details.

\emph{The distinction between a message that asks for what the sender
wants and a message that tells the receiver how to behave may seem
subtle but the consequences are significant}.

Rather than depending on a concrete Class, consider relying on a
duck type that implements the necessary message. \emph{Depending on a
“duck-like” thing is much more flexible}.
\end{quote}


\subsubsection{Coerción}
Puesto que \verb|Integer| no sabe como multiplicarse por un \verb|Point|,
pide ayuda a \verb|Point| llamando a su método \verb|coerce|
(véase el código de \verb|point.rb| en la sección
\ref{subsection:definiendooperadores}).

\begin{verbatim}
$ cat coerce.rb 
require 'point'

p = Point.new(2,3)
q = 2*p
puts q
\end{verbatim}

\begin{verbatim}
[09:01][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ ruby -rdebug -I. coerce.rb 
coerce.rb:1:require 'point'
(rdb:1) n
coerce.rb:3:p = Point.new(2,3)
(rdb:1) 
n
coerce.rb:4:q = 2*p
(rdb:1) p p
(2,3)
(rdb:1) s
/Users/casianorodriguezleon/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point/point.rb:34:    [self, other]
(rdb:1) where
--> #1 /Users/casianorodriguezleon/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point/point.rb:34:in `coerce'
    #2 coerce.rb:4
(rdb:1) self
(2,3)
(rdb:1) other
2
(rdb:1) s
/Users/casianorodriguezleon/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point/point.rb:29:    return Point.new(@x*scalar,   @y*scalar) if scalar.is_a? Numeric
(rdb:1) n
coerce.rb:5:puts q
(rdb:1) 
n
(4,6)
[09:09][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ 
\end{verbatim}

\subsection{Acceso a Arrays y a Hashes}
Véase  el código en la sección
\ref{subsection:definiendooperadores}

\subsubsection{Nota Sobre el Case}
Ruby 1.9 introduces an incompatible syntax change for conditional statements such as 'if' and 'case/when'. Previously a colon could be used as a shorthand for a 'then' statement; this is perhaps most useful with multiple 'when' statements on one line.

The following is legitimate ruby in 1.8:

\begin{verbatim}
case x 
when Regexp  : puts 'a regex'
when Hash    : puts 'a regex'
when Numeric : puts 'a number'
when String  : puts 'a string'
end
\end{verbatim}
But not in ruby 1.9; now an explicit 'then' statement must be used:

\begin{verbatim}
case x
when Regexp then puts 'a regex'
...
\end{verbatim}

\subsection{Enumeración de Coordenadas}

\begin{verbatim}
09:37][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ export RUBYLIB=$RUBYLIB:.
[09:38][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ echo $RUBYLIB
:.
[09:39][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ irb
ruby-1.9.2-p290 :001 > require 'point' 
 => true 
ruby-1.9.2-p290 :002 > class Point
ruby-1.9.2-p290 :003?>   def each
ruby-1.9.2-p290 :004?>     yield @x
ruby-1.9.2-p290 :005?>     yield @y
ruby-1.9.2-p290 :006?>     end
ruby-1.9.2-p290 :007?>   end
 => nil 
ruby-1.9.2-p290 :008 > p = Point.new(2,1)
 => (2,1) 
ruby-1.9.2-p290 :009 > p.each do |x| puts "coord = #{x}" end
coord = 2
coord = 1
 => nil 

\end{verbatim}

\subsection{Igualdad de Puntos}

Repáse la sección \ref{section:objetos}.

\subsubsection{Tipado Pato e Igualdad}

\begin{verbatim}
$ cat equality.rb 
class Point
  attr_reader :x, :y   # Define accessor methods for our instance variables

  .............

  def ==(o) # a very persistent equality operator
    begin
      return @x == o.x && @y  == o.y if o.instance_of? Point
      return o == self if o.is_a? Point
      false
    rescue
      false
    end
  end

  ...........

end

if __FILE__ == $0
  require 'point3D'
  p = Point.new(1,2)
  q = Point3D.new(1,2,3)
  p p
  p q

  p "Comparison with Point: #{p == q}"
  p "Comparison with Point3D: #{q == p}"
  p "Comparison with Point3D.to_point: #{q.to_point == p}"

end

Ejecución:

\end{verbatim}

\begin{verbatim}
$ ruby equality.rb 
(1,2)
(1, 2, 3)
"Comparison with Point: false"
"Comparison with Point3D: false"
"Comparison with Point3D.to_point: true"

\end{verbatim}
Clase \verb|Point3D|:
\begin{verbatim}
$ cat point3D.rb 
require "point"
class Point3D < Point
  def initialize(x, y, z)
    super(x, y)
    @z = z
  end

  def ==(o)
    begin
      return (o.z == @z and super(to_point)) if o.instance_of?(Point3D)
      return o == self if o.is_a? Point3D # is not an instance of Point3D
      false
    rescue
      false
    end
  end

  def to_point
    Point.new(@x, @y)
  end

  def to_s
    "(#@x, #@y, #@z)"
  end
end

\end{verbatim}

\subsubsection{{\tt eql?} y las Claves de un hash}

El predicado \verb|eql?|
es usado por Ruby para comparar las claves de un hash.
Por ello, si redefinimos \verb|eql?| en nuestra clase,
es conveniente que también definamos el método
\verb|hash| que es usado por Ruby para calcular el {\it hascode}
del objeto. 

Se debe cumplir siempre 
que si dos objetos son iguales según \verb|eql?| entonces sus hashcodes
deben ser iguales.

No parece que sea una buena idea usar objetos mutables como índices de 
hashes. Si es el caso, es mejor congelar el objeto
(véase la sección \ref{subsection:freezing}).

Véase  el código en 
\ref{subsection:definiendooperadores}

\subsection{Ordenando Puntos}

Véase  el código en 
\ref{subsection:definiendooperadores}

\begin{itemize}
\item \htmladdnormallink{Comparable}{http://www.ruby-doc.org/core-1.9.3/Comparable.html}
\item \htmladdnormallink{Enumerable}{http://ruby-doc.org/core-1.9.3/Enumerable.html}
\end{itemize}

\subsection{Un Punto Mutable}

\begin{verbatim}
[~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/point]$ cat -n mutable_point.rb 
     1  #encoding : utf-8
     2  class MutablePoint
     3    def initialize(ñ,y)
     4     @ñ, @y = ñ, y 
     5    end
     6  
     7    def ñ; @ñ; end       # The getter method for @ñ
     8    def y; @y; end       # The getter method for @y
     9  
    10     def ñ=(value)        # The setter method for @ñ
    11       @ñ = value
    12     end
    13  
    14    def y=(value)        # The setter method for @y
    15      @y = value
    16    end
    17  
    18     def add!(p)          # Add p to self, return modified self
    19       @ñ += p.ñ
    20       @y += p.y
    21       self
    22     end
    23  #  ---------------------------
    24    def add(p)           # A nonmutating version of add!
    25      q = self.dup       # Make a copy of self
    26      q.add!(p)          # Invoke the mutating method on the copy
    27    end
    28  
    29  end
    30  
    31  if __FILE__ == $0
    32    z = MutablePoint.new(1,2)
    33    p z
    34    t = MutablePoint.new(2,1)
    35    p t 
    36    t.ñ = 4
    37    p t 
    38    z.add!(t)
    39    p z
    40  end
\end{verbatim}

\subsection{Clases Mutables: Fácil y Rapido}

\begin{verbatim}
$ cat -n struct_point.rb 
     1  Point = Struct.new(:x, :y)   # Creates new class, assigns to Point
     2  
     3  p = Point.new(1,2)   # => #<struct Point x=1, y=2>
     4  p p.x                  # => 1·
     5  p p.y                  # => 2
     6  p.x = 3                # => 3
     7  p p.x                  # => 3
     8  #---------------------------
     9  p[:x] = 7         
    10  p p[:x]              # => 7: same as p.x
    11  p p[1]               # => 2: same as p.y
    12  p.each {|c| print c}  # prints "72"
    13  puts
    14  p.each_pair {|n,c| print n,c; puts } 
    15  puts
    16  
    17  #---------------------------
    18  q = Point.new(4,2)
    19  p q == p        # => true
    20  h = {q => 1}  # Create a hash using q as a key
    21  p h[p]          # => 1: extract value using p as key
    22  p q.to_s        # => "#<struct Point x=4, y=2>"
    23  
    24  require 'extending_struct_point'
    25  
    26  puts "sorting!"
    27  puts [p, q].sort

\end{verbatim}
Por supuesto podemos abrir la clase creada con \verb|Struct| y extenderla:
\begin{verbatim}
$ cat -n extending_struct_point.rb 
     1  class Point                  # Open Point class for new methods
     2    def add!(other)            # Define an add! method
     3      self.x += other.x
     4      self.y += other.y
     5      self
     6    end
     7  
     8    include Comparable         # Include a module for the class
     9    def <=>(other)             # Define the <=> operator
    10      return nil unless other.instance_of? Point
    11      self.x**2 + self.y**2 <=> other.x**2 + other.y**2
    12    end
    13  end
\end{verbatim}

\begin{verbatim}
$ ruby -I. struct_point.rb 
1
2
3
7
2
72
x7
y2

false
nil
"#<struct Point x=4, y=2>"
sorting!
#<struct Point x=4, y=2>
#<struct Point x=7, y=2>

\end{verbatim}
Las clases creadas por \verb|Struct| son mutables. Si la queremos hacer inmutable:
\begin{verbatim}
$ cat -n making_struct_inmutable.rb 
     1  Point = Struct.new(:x, :y)  # Define mutable class
     2  class Point                 # Open the class
     3    undef x=,y=,[]=           # Undefine mutator methods
     4  end
     5  
     6  z = Point.new(2,3)
     7  
     8  z.x = 4
\end{verbatim}

\begin{verbatim}
[~/point]$ ruby making_struct_inmutable.rb 
making_struct_inmutable.rb:8:in `<main>': 
  undefined method `x=' for #<struct Point x=2, y=3> (NoMethodError)
\end{verbatim}

\subsection{Un Método de Clase}

\begin{verbatim}
[~/point]$ cat -n point_with_sum.rb 
     1  require 'point'
     2  class Point
     3    attr_reader :x, :y     # Define accessor methods for our instance variables
     4  
     5    def Point.sum(*points) # Return the sum of an arbitrary number of points
     6      x = y = 0
     7      points.each {|p| x += p.x; y += p.y }
     8      Point.new(x,y)
     9    end
    10  end
    11  
    12  if __FILE__ == $0
    13    z = [[1,1],[2,4],[3,2]].map { |p| Point.new(*p) }
    14    p z
    15    w = Point.sum(*z)
    16    p w
    17    r = Point.sum(z[0], z[1])
    18    p r
    19  end
    20  
\end{verbatim}

También podemos poner \verb|self.sum| o bien \verb|class << self ... end|

\begin{verbatim}
[~/point]$ ruby point_with_sum.rb 
[(1,1), (2,4), (3,2)]
(6,7)
(3,5)

\end{verbatim}

\subsection{Constantes}

\begin{verbatim}
 1 class Point
  2   attr_reader :x, :y   # Define accessor methods for our instance variables
  3 
  4   include Comparable
  5   include Enumerable
  6 
  7   def initialize(x,y)
  8     @x,@y = x, y
  9   end    
 10   
 11   ORIGIN = Point.new(0, 0)
 12   E_1    = Point.new(1, 0)
 13   E_2    = Point.new(0, 1)
\end{verbatim}

\begin{verbatim}
>> load "Point2.rb"
=> true
>> Point::E_1
=> #<Point:0x100589f20 @y=0, @x=1>
>> Point::E_1.x
=> 1
>> E_1
NameError: uninitialized constant E_1
  from (irb):4
>> 
\end{verbatim}

Puesto que las constantes crean instancias de la clase, no podemos definirlas antes 
de tener definido el método \verb|initialize|:
\begin{verbatim}
[~/rubytesting]$ cat constant_before_initialize.rb 
class Tutu

  C = Tutu.new(5)

  def initialize(x)
   @x = x 
  end
end
\end{verbatim}
Al ejecutar produce un error:
\begin{verbatim}
[~/rubytesting]$ ruby constant_before_initialize.rb 
constant_before_initialize.rb:3:in `initialize': wrong number of arguments(1 for 0) (ArgumentError)
  from constant_before_initialize.rb:3:in `new'
  from constant_before_initialize.rb:3:in `<class:Tutu>'
  from constant_before_initialize.rb:1:in `<main>'
\end{verbatim}
Es posible definir constantes de una clase desde fuera de la misma:
\begin{verbatim}
>> Point::E_3 = Point.new 1, 1
=> #<Point:0x100565df0 @y=1, @x=1>
\end{verbatim}

\subsection{Variables de Clase}

\subsection{Variables de Instancia de Clase}
\begin{enumerate}
\item
Una desventaja de las variables de instancia de clase
es que no pueden ser utilizadas dentro de los métodos de instancia,
mientras que las variables de clase si son accesibles.
\item
Otra desventaja es el riesgo potencial de confundirlas con variables de
instancia ordinarias
\end{enumerate}

El siguiente ejemplo muestra como crear accessors a las variables de instancia
de clase:

\begin{verbatim}
$ cat -n creating_class_accessors.rb 
     1  class Tutu
     2  
     3    class << self
     4        attr_accessor :n
     5    end
     6  
     7  end
     8  
     9  Tutu.n = 4
    10  p Tutu.n
    11  
    12  
[~/point]$ ruby creating_class_accessors.rb 
4

\end{verbatim}

\subsectionpractica{La Clase Punto del Plano}

\begin{itemize}
\item
Defina una clase \verb|Point| que represente puntos \verb|(x, y)|del plano cartesiano.
\item
Defina el método \verb|to_s|
\item
Defina métodos para el acceso a los atributos
\item
Defina la suma de puntos $(x_1,y_1) + (x_2, y_2) = (x_1 + y_1, x_2+y_2)$.
Compruebe que el objeto sumado hereda de la clase \verb|Point| usando el predicado \verb|is_a?|.
\item
Defina el producto de un vector/punto por un escalar $(x,y) * \lambda = (\lambda * x, \lambda * y)$
\item
Para que un entero se pueda multiplicar por un punto \verb|2 * p| es necesario definir un método
\verb|coerce| en la clase \verb|Point|:
\begin{verbatim}
  def coerce(other)
    [self, other]
  end 
\end{verbatim}
Los tipos numéricos definen un método de conversión denominado \verb|coerce|.
Cuando se llama al método \verb|*| de \verb|2|: \verb|2*(p)|
este llamará primero al método \verb|coerce| de \verb|Point| y después 
intentará multiplicar los elementos del array retornado.
\begin{verbatim}
>> 1.1.coerce(1)
=> [1.0, 1.1]
>> r = Rational(1,3)
=> Rational1, 3
>> r.coerce(2)
=> [Rational2, 1, Rational1, 3]
\end{verbatim}
defina \verb|coerce| de manera que pueda multiplicarse un escalar por un \verb|Point|.
\item
Defina el opuesto de un punto $-(x, y) = (-x, -y)$.
El método para definir el menos unario se llama \verb|-@|:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n unaryminus.rb 
     1  class Tutu
     2    def initialize(s)
     3      @s = s
     4    end
     5  
     6    def -@
     7      @s.reverse
     8    end
     9  
    10    def to_s
    11      @s
    12    end
    13  end
    14  
    15  if __FILE__ == $0
    16    a = Tutu.new("dlrow olleH")
    17    puts -a
    18  end
\end{verbatim}
Al ejecutarse produce:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby unaryminus.rb 
Hello world
\end{verbatim}
\item
Redefine el método \verb|[]| de manera que pueda accederse a un punto como si fuera un array
de sólo lectura.
Permite el uso de índices negativos.
También debería poder accederse usando una notación hash. Por ejemplo, el código:
\begin{verbatim}
  p = Point.new(1,2)
  puts "#{p[0]}, #{p[1]}"
  puts "#{p[-2]}, #{p[-1]}"
  puts "#{p[:x]}, #{p[:y]}"
  puts "#{p['x']}, #{p['y']}"
\end{verbatim}
Debería producir como salida:
\begin{verbatim}
$ ruby Point.rb 
1, 2
1, 2
1, 2
1, 2
\end{verbatim}
Un hash es una estructura de datos que asocia a cada uno de los elementos de un conjunto de objetos
denominados {\it claves}  un {\it valor}:
\begin{verbatim}
>> n = { :one => 1, :two => 2, :three => 3}
=> {:one=>1, :two=>2, :three=>3}
>> n[:four] = 4
=> 4
>> n
=> {:one=>1, :two=>2, :three=>3, :four=>4}
>> b = n[:one]+n[:four]
=> 5
>> n[:five]
=> nil
>> n.keys
=> [:one, :two, :three, :four]
>> n.values
>> n.each { |k,v| puts "value for #{k} is #{v}" }
value for one is 1
value for two is 2
value for three is 3
value for four is 4
=> [1, 2, 3, 4]
\end{verbatim}
\item
Si queremos que los objetos de una clase 
puedan ser usados como claves de un hash es necesario que dispongan de un método \verb|hash|
que retorne un código hash de tipo \htmladdnormallink{Fixnum}{http://www.ruby-doc.org/core-1.8.7/classes/Fixnum.html}.
La clase \htmladdnormallink{Hash}{http://www.ruby-doc.org/core-1.8.7/classes/Hash.html} compara las claves 
usando el predicado \verb|eql?|. Este predicado es similar a \verb|==| 
pero es mas restrictivo. Por ejemplo, en las subclases de \verb|Numeric|
\verb|==| permite la conversión de tipos mientras que \verb|eql?| no:
\begin{verbatim}
>> 1 == 1.0
=> true
>> 1.eql?(1.0)
=> false
\end{verbatim}
Permita que los objetos \verb|Point| puedan ser usados como índices de un hash.
El siguiente código:
\begin{verbatim}
  p = Point.new(1,2)
  q = Point.new(1,1)
  m = { p => 1, q => 2 } 
  puts m[p]
  puts m[q]
\end{verbatim}
deberá producir como salida:
\begin{verbatim}
1
2
\end{verbatim}
Para eso deberá definir:
\begin{itemize}
\item
El método \verb|hash| de un \verb|Point|:
Puede usar con algoritmo de hashcode el descrito 
en \htmladdnormallink{Effective Java (Addison-Wesley 2001) por Joshua Bloch }{http://www.linuxtopia.org/online_books/programming_books/thinking_in_java/TIJ313_029.htm}
\item El predicado \verb|eql?|. El predicado deberá retornar \verb|true| si el otro objeto es exactamente de la clase
\verb|Point|. Véase el método \verb|instance_of?|:
\begin{verbatim}
>> 4.class
=> Fixnum
>> 4.class.superclass
=> Integer
>> 4.class.superclass.superclass
=> Numeric
>> 4.class.superclass.superclass.superclass
=> Object
>> 4.class.superclass.superclass.superclass.superclass
=> nil
>> 4.instance_of? Fixnum
=> true
>> 4.instance_of? Integer
=> false
>> 4.instance_of? Numeric
=> false
>> 4.is_a? Numeric
=> true
\end{verbatim}
\end{itemize}
\item
Defina un método \verb|each| que produzca primero la primera coordenada y después la segunda.
Incluya el módulo 
\htmladdnormallink{Enumerable}{http://www.ruby-doc.org/core/classes/Enumerable.html}
y compruebe que puede usar algunos de los métodos proveídos 
por este como \verb|all?| y \verb|any?|.
\item Redefina el método \verb|==| para que dos puntos sean iguales si sus coordenadas son iguales.
%% El método debería devolver \verb|false| si el argumento de \verb|==| no es de la clase \verb|Point| (esto es, \verb|unless arg.is_a? Point|).
Siguen dos posibles implementaciones:
\begin{tabular}{|p{5cm}|p{5cm}|}
\hline
\begin{verbatim}
def ==(o)
  if o.is_a? Point
    @x==o.x && @y==o.y
  else
    false
  end
end
\end{verbatim}
&
\begin{verbatim}
def ==(o)
  @x==o.x && @y==o.y
  rescue
    false
end
\end{verbatim}\\
\hline
\end{tabular}
¿Sabría decir cual es la diferencia entre ambas?
\item
Incluya el módulo \htmladdnormallink{Comparable}{http://www.ruby-doc.org/core-1.8.7/classes/Comparable.html}.
Defina el método \verb|<=>| {\it guerra de las galaxias} de manera que  dos \verb|Point| se comparan según su distancia
al origen de coordenadas.  Si \verb|self| es menor que el objeto, \verb|<=>| deberá retornar \verb|-1|, si son iguales \verb|0|
y \verb|1| si es mayor.
Compruebe que puede usar los métodos proveídos por \verb|Comparable|.

Este programa:
\begin{verbatim}
  p = Point.new(1,2)
  q = Point.new(1,1)
  r = Point.new(2,1)

  # It is not a total order relation
  puts p > r 
  puts p < r 
  puts p == r
  puts p > q 
\end{verbatim}
Deberá producir una salida como esta:
\begin{verbatim}
false
false
false
true
\end{verbatim}
\item Incluya el módulo enumerable y compruebe que funcionan los métodos 
\verb|sort|, \verb|min| y \verb|max|
\item
Defina una clase \verb|Point3D| que reutilice y herede de \verb|Point| y que tenga las mismas funcionalidades.
\end{itemize}


\section{Visibilidad de los métodos: Público, Privado, Protegido}


\begin{itemize}
\item
Los métodos son normalmente \verb|public| a menos que sean explícitamente declarados como \verb|private| o \verb|protected|. 
\item
Una excepción es \verb|initialize| que es implícitamente privado.
\item
Otra excepción son los métodos declarados fuera de cualquier definición de clase: son declarados como métodos de instancia privados de la clase \verb|Object|
\end{itemize}

\begin{itemize}
\item Un método público puede ser llamado desde cualquier lugar
\item
Si \verb|m| es un método privado, deberá ser invocado implícitamente en \verb|self|,
esto es, como {\it función, \verb|m()|},
y no con receptor explícito: (\verb|obj.m| o bien \verb|self.m|).
\item
Esto es, un método privado es siempre invocado implícitamente en \verb|self|
y no debe ser invocado explícitamente en un objeto
\item Las subclases pueden invocar y sobreescribir los métodos \verb|private|

\item Al igual que los métodos privados, los métodos \verb|protected|
pueden ser invocados desde  la clase  o sus subclases
\item A diferencia de los métodos privados, los métodos \verb|protected|
pueden ser invocados en cualquier objeto de la clase
y no implican la invocación implícita via \verb|self|
\item La visibilidad de los métodos se declara mediante tres \emph{métodos}:
\verb|public|, \verb|private| y \verb|protected|. 

\item Estos tres métodos son métodos 
de instancia de la clase \verb|Module|.

\item Como todas las clases son módulos y dentro de una definición de clase
(pero fuera de las definiciones de métodos) \verb|self| se refiere a la clase, podemos usar 
estos métodos \verb|public|, \verb|private| y \verb|protected| como si de palabras reservadas se tratara.

\item Una clase puede usarlos así:
\begin{verbatim}
class Point
  # public methods go here

  # The following methods are protected
  protected

  # protected methods go here

  # The following methods are private
  private

  # private methods go here
end
\end{verbatim}
\item
También pueden ser invocados con los nombres de uno o mas métodos (como símbolos o como
cadenas). En tal caso la declaración de visibilidad viene después de la definición del método
y altera la visibilidad del método con ese nombre.

\item Una aproximación es declarar todos los métodos protegidos y privados de golpe,
al final de la clase

\item Otra aproximación es declarar la visbilidad justo después de la definición del método:
\begin{verbatim}
class Widget
  def x                       # Accessor method for @x
    @x
  end
  protected :x                # Make it protected

  def utility_method          # Define a method
    nil
  end
  private :utility_method     # And make it private
end
\end{verbatim}
\item Si se desea declarar un método de clase como privado se usa el \emph{método}
\verb|private_class_method|:
\begin{verbatim}
        private_class_method :new
\end{verbatim}
\item Si se desea hacer público de nuevo un método de clase privado se usa el 
método \verb|public_class_method|
\item
Las capacidades de metaprogramación de Ruby hacen posible
invocar métodos privados y protegidos e incluso el acceso a variables 
encapsuladas:
\begin{verbatim}
$ cat -n accesing_private_method.rb 
     1  class Widget
     2    def initialize()
     3      @x = 4
     4    end
     5  
     6    def x
     7      @x
     8    end
     9    protected :x                # Make it protected
    10  
    11    def utility_method          # Define a method
    12      puts "Inside utility_method"
    13    end
    14    private :utility_method     # And make it private
    15  end
    16  
    17  w = Widget.new                      # Create a Widget
    18  w.send :utility_method              # Invoke private method!
    19  w.instance_eval { utility_method }  # Another way to invoke it
    20  
    21  w.instance_eval { puts @x }              # Read instance variable of w
\end{verbatim}
Cuando ejecutamos, obtenemos:
\begin{verbatim}
[~/point]$ ruby accesing_private_method.rb 
Inside utility_method
Inside utility_method
4
\end{verbatim}

Utilice \verb|public_send| en vez de \verb|send| si no se quiere que, 
por error, se llame inadvertidamente a un método privado.
\end{itemize}

\subsection{Ejemplo de Visibilidad}
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n SubClass.rb 
     1  class Point
     2  
     3    def chuchu
     4      "Point: chuchu"
     5    end
     6  
     7    def chachi
     8      "Point: chachi"
     9    end
    10  
    11    private   :chuchu
    12    protected :chachi
    13  end
    14  
    15  class SubClass < Point
    16  
    17    def titi1 
    18      chuchu
    19    end
    20  
    21    def titi2 
    22      self.chuchu
    23    end
    24  
    25    def titi3
    26      chachi 
    27    end
    28  
    29    def titi4
    30      self.chachi 
    31    end
    32  end
    33  
    34  if __FILE__ == $0
    35    x = SubClass.new
    36    puts x.titi1
    37    begin
    38      puts x.titi2
    39      rescue 
    40        puts "Can't call private meth. via 'self'. Exception type: <#{$!.class}> message: <#{$!}>"
    41    end
    42  
    43    puts x.titi3
    44  
    45    puts x.titi4
    46  
    47    begin
    48      puts x.chachi
    49      rescue
    50        puts "Can't call protected meth. from outside. Exception type: <#{$!.class}> message: <#{$!}>"
    51    end
    52  end
\end{verbatim}

La ejecución del programa produce la salida:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby SubClass.rb 
Point: chuchu
Can't call private meth. via 'self'. Exception type: <NoMethodError> message: <private method `chuchu' called for #<SubClass:0x1001685b8>>
Point: chachi
Point: chachi
Can't call protected meth. from outside. Exception type: <NoMethodError> message: <protected method `chachi' called for #<SubClass:0x1001685b8>>
\end{verbatim}


\subsection{Ejemplo de Visibilidad}



\begin{verbatim}
~/rubytesting/programmingRuby$ !cat
cat -n Visibility.rb 
   1  class Visibility
   2  protected
   3    def tutu_prot
   4      puts "Prot"
   5    end
   6  
   7  private
   8    def tutu_priv
   9      puts "Priv"
  10    end
  11  
  12  public
  13    def tutu_pub
  14      puts "Pub"
  15    end
  16  end
  17  
  18  
  19  class Child < Visibility
  20  
  21    def chachi
  22      puts "in chachi"
  23      self.tutu_prot
  24    end
  25  
  26    def chuchu
  27      puts "in chuchu"
  28      self.tutu_priv
  29    end
  30  end
  31  
  32  if $0 == __FILE__
  33    b = Child.new
  34    b.tutu_pub       # <- Pub
  35    begin
  36      b.tutu_priv    # Exception <NoMethodError> raised <private method `tutu_priv' called for #<Child:0x100168068>> 
  37    rescue NoMethodError
  38        puts "Exception <#{$!.class}> raised <#{$!}>"
  39    end
  40    b.chachi  # <- in chachi
  41              #    Prot
  42    begin
  43      b.chuchu # <- Exception <NoMethodError> raised <private method `tutu_priv' called for #<Child:0x100168068>>
  44    rescue
  45        puts "Exception <#{$!.class}> raised <#{$!}>"
  46    end
  47  
  48    begin
  49      c = Visibility.new
  50      c.tutu_pub  # <- Pub
  51      c.tutu_prot # <- Exception <NoMethodError> raised <protected method `tutu_prot' called for #<Visibility:0x100167b40>>
  52    rescue NoMethodError
  53        puts "Exception <#{$!.class}> raised <#{$!}>"
  54    end
  55  end
\end{verbatim}

\section{Subclases y Herencia}

\begin{itemize}
\item
Si, cuando se define una clase no se especifica una superclase 
entonces nuestra clase hereda implíctamente de \verb|Object|.

\item
En Ruby 1.9 la raíz de la jerarquía de herencia es \verb|BasicObject|.

\item
Es posible heredar de una subclase definida mediante \verb|Struct|:
\begin{verbatim}
[~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ cat subclassing_a_struct.rb 
class Punto < Struct.new("Point3D", :x, :y, :z)
  # Superclass struct give us accessor methods, ==, to_s, etc.
   def modulo
     Math.sqrt(x*x+y*y+z*z)
   end
end
if $0 == __FILE__
  p = Punto.new(1,2,3)
  puts p.x
  puts p.modulo
end
\end{verbatim}
Ejecución:

\begin{verbatim}
[~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ ruby subclassing_a_struct.rb 
1
3.7416573867739413
\end{verbatim}
\end{itemize}

\subsection{Heredando Métodos}

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n Point3D.rb 
     1  require "Point"
     2  class Point3D < Point
     3  end
\end{verbatim}

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ irb
>> require "Point3D"
=> true
>> p1 = Point3D.new(1,2)
=> #<Point3D:0x10057d5e0 @y=2, @x=1>
>> p2 = Point.new(1,2)
=> #<Point:0x10056a440 @y=2, @x=1>
>> p1.class
=> Point3D
>> p2.class
=> Point
>> p1.to_s
=> "(1,2)"
\end{verbatim}

\subsection{Predominancia de Métodos (overriding)}
\label{subsection:overriding}

Se entiende por \wikip{overriding}{Method\_overriding} la posibilidad de reemplazar la conducta de un método en la superclase.

\begin{verbatim}
[19:28][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ cat overriding_methods.rb 
class WorldGreeter
  def greet                      # Display a greeting
    puts "#{greeting} #{who}"
  end 

  def greeting                   # What greeting to use 
    "Hello"
  end 

  def who                        # Who to greet
    "World"
  end 
end

# Greet the world in Spanish
class SpanishWorldGreeter < WorldGreeter
  def greeting                   # Override the greeting
    "Hola"
  end 
end

# We call a method defined in WorldGreeter, which calls the overridden
# version of greeting in SpanishWorldGreeter, and prints "Hola World"
SpanishWorldGreeter.new.greet
\end{verbatim}

Ejecución:
\begin{verbatim}
[19:28][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ ruby overriding_methods.rb 
Hola World

\end{verbatim}

\begin{itemize}
\item
Nótese que es posible definir una clase \cei{Abstracta} que invoca ciertos \cei{métodos abstractos}
cuya definición se delega a las subclases.
\item
Una clase que extiende una clase \cei{abstracta} es \cei{concreta} si define todos
los métodos abstractos de sus ancestros.
\end{itemize}


\begin{verbatim}
[19:34][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ cat abstract_and_concrete_classes.rb 
# This class is abstract; it doesn't define greeting or who
# No special syntax is required: any class that invokes methods that are
# intended for a subclass to implement is abstract.
class AbstractGreeter
  def greet
    puts "#{greeting} #{who}"
  end
end

# A concrete subclass
class WorldGreeter < AbstractGreeter
  def greeting; "Hello"; end
  def who; "World"; end
end

WorldGreeter.new.greet  # Displays "Hello World"
\end{verbatim}

Ejecución:
\begin{verbatim}
[19:34][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ ruby abstract_and_concrete_classes.rb 
Hello World

\end{verbatim}

\subsubsection{Predominancia de Métodos Privados}
\label{subsubsection:predominancia_de_metodos_privados}
Los métodos privados no pueden ser invocados con un receptor explícito pero son heredados por las subclases.
Si ocurre que 
\begin{enumerate}
\item Nuestra clase hereda de otra
\item Definimos un método (cualquiera que sea su visibilidad)
en nuestra subclase que tiene el mismo nombre que un método privado en la superclase
\item Entonces sobreescribimos el método privado. 
\item Si lo hemos hecho por equivocación y el método privado 
así llamado era usado como un helper por la superclase
\emph{es muy posible que esta colisión produzca una conducta indeseable}.
\item Cuando herede procure estar familiarizado con la implementación de la superclase.
\end{enumerate}

El siguiente ejemplo ilustra el problema:
\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/overriding_methods]$ cat overriding_private_methods.rb 
class MotherFoo
  def titi 
   foo
  end

  private
  def foo
   "mother foo"
  end
end

class ChildFoo < MotherFoo
  def foo 
    "child foo"
  end
end

c = ChildFoo.new
puts c.titi # child foo

print "Private methods of mother class: "
class MotherFoo
  puts MotherFoo.private_instance_methods(false)
end
\end{verbatim}

La llamada a \verb|titi| hace que se llame al método \verb|foo| de la clase hija en vez
de al método \verb|foo| de la clase madre que era lo que el programador pretendía.

Una manera de paliar este problema consiste en documentar los métodos privados de nuestra clase
en una sección para desarrolladores. 

Como muestra la ejecución del anterior ejemplo 
siempre es posible averiguar que métodos privados tiene la superclase llamando a 
\verb|MotherFoo.private_instance_methods|. De esta forma sabemos que nombres 
evitar en nuestra clase hija:

\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/overriding_methods]$ ruby overriding_private_methods.rb 
child foo
Private methods of mother class: foo
[~/srcLPP/Chapter7ClassesAndModules/overriding_methods]$ 
\end{verbatim}

Otra forma de aliviar el problema es: 
\begin{enumerate}
\item crear un método anónimo de clase \verb|Proc| o una lambda
\item usar una variable de instancia de la clase para guardarlo. 
\item crear un accessor de lectura para la variable de instancia de la clase como objeto
\end{enumerate}
Esto hace mas difícil que las clases que hereden
puedan colisionar con nuestro método {\it privado}.

\begin{verbatim}
11:10][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ cat overriding_private_methods3.rb 
class MotherFoo
  @ofoo = Proc.new do |x|
   "mother foo #{x}"
  end

  def self.foo(x)
    @ofoo.call(x)
  end

  def titi(y) 
    MotherFoo.foo(y) 
  end
end

class ChildFoo < MotherFoo
  # puts @ofoo.call # generates an exception: undefined method `call' for nil:NilClass (NoMethodError))
  def foo(z) 
    "child foo #{z}"
  end
  puts MotherFoo.foo(9)
end

c = ChildFoo.new
puts c.titi(4) 
puts c.foo(3) 
\end{verbatim}
Como se vé, es todavía posible - pero ahora explicitándolo con \verb|MotherFoo.foo| - acceder al método "privado"
evitando de este modo la colisión casual.

Ejecución:
\begin{verbatim}
[11:13][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ ruby overriding_private_methods3.rb 
mother foo 9
mother foo 4
child foo 3
\end{verbatim}

\subsection{Aumentando la Conducta Mediante Encadenamiento}

Cuando queremos aumentar la funcionalidad de un método de la clase de la que se hereda
es necesario invocar el método sobreescrito desde la nueva versión del  método.
Esto se consigue mediante la palabra reservada \verb|super|.
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n Point3D.rb 
     1  require "Point"
     2  class Point3D < Point
     3    def initialize(x, y, z)
     4      super(x, y)
     5      @z = z
     6    end
     7  end
     8  if __FILE__ == $0
     9    p = Point3D.new(1,2,3)
    10    puts p.inspect
    11  end
\end{verbatim}

Ejecución:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby Point3D.rb 
#<Point3D:0x1001622f8 @y=2, @x=1, @z=3>
\end{verbatim}

\begin{itemize}
\item
Si se usa \verb|super| sin argumentos y sin paréntesis
entonces se le pasarán todos los argumentos con los que ha sido llamado el método
actual.
\item \verb|super()| lo llamará sin argumentos
\item Si el método modifica los valores de los argumentos antes de la llamada a \verb|super|
entonces son los valores modificados los que son pasados en la invocación del correspondiente 
método de la superclase:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n Point3DSuper.rb 
     1  class Point
     2    attr_reader :x, :y   
     3  
     4    def initialize(x,y)
     5      @x,@y = x, y
     6    end
     7  end
     8  
     9  class Point3D < Point
    10    attr_reader :z
    11    def initialize(x, y, z)
    12      x, y = x+1, y+1
    13      super(x, y)
    14      @z = z
    15    end
    16  end
    17  if __FILE__ == $0
    18    p = Point3D.new(1,1,1)
    19    puts "#{p.x} #{p.y} #{p.z}"
    20  end
\end{verbatim}

Ejecución:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby Point3DSuper.rb 
2 2 1
\end{verbatim}
\end{itemize}


\subsection{Herencia y Métodos de Clase}

Si nuestra clase \verb|Point3D| hereda de \verb|Point| y 
\verb|Point| define un método de clase \verb|sum|
entonces la llamada \verb|Point3D.sum| invocará a \verb|Point.sum| 
en el caso de que la clase \verb|Point3D| no defina su propio método \verb|sum|.

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n Point3DSuper.rb
     1  class Point
     2    attr_reader :x, :y   
     3  
     4    def initialize(x,y)
     5      @x,@y = x, y
     6    end
     7  
     8    def self.sum(* points)
     9      x, y  = 0, 0
    10      points.each { |p| x += p.x; y += p.y }
    11      Point.new(x, y)
    12    end
    13  
    14    def to_s
    15      "#@x #@y"
    16    end
    17  end
    18  
    19  class Point3D < Point
    20    attr_reader :z
    21  
    22    def initialize(x, y, z)
    23      super(x, y)
    24      @z = z
    25    end
    26  
    27    def self.sum(* points)
    28      p = super
    29      z = points.inject(0) { |a,r| a  += r.z } 
    30      Point3D.new(p.x, p.y, z)
    31    end
    32  
    33    def to_s
    34      super+" #@z"
    35    end
    36  end
    37  
    38  if __FILE__ == $0
    39    q, r, s = Point3D.new(1,1,1), Point3D.new(2,2,2), Point3D.new(3,3,3)
    40  
    41    puts Point3D.sum(q, r, s)
    42  end
\end{verbatim}
Como se ve, podemos usar \verb|super| con métodos de clase con el mismo significado que en los métodos de objeto.

La línea 28 es equivalente a \verb|p = super(* points)| y también equivalente a \verb|p = Point.sum(* points)|
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby Point3DSuper.rb 
6 6 6
\end{verbatim}


\subsection{Herencia y Variables de la Instancia}

Considere el siguiente ejemplo:
\begin{verbatim}
[~/srcLPP/inheritance]$ cat VariableInheritance.rb 
class Point
  def initialize(x,y)
    @x,@y = x, y
  end

  def to_s
    "#@x #@y"
  end
end

class Point3D < Point
  def initialize(x, y, z)
    super(x, y)
    @z = z
  end

  def to_s
    "#@x #@y #@z"
  end
end

if __FILE__ == $0
  q, r, s = Point3D.new(1,1,1), Point3D.new(2,2,2), Point3D.new(3,3,3)
  puts q, r, s

  print "The instance variables of point 'q' are: "
  puts q.instance_variables.join(',')
end
\end{verbatim}
Observe como en la línea 18 accedemos a las referencias \verb|@x| y \verb|@y| de la superclase \verb|Point|.
Este código funciona como cabría esperar:

\begin{verbatim}
[~/srcLPP/inheritance]$ ruby VariableInheritance.rb 
1 1 1
2 2 2
3 3 3
The instance variables of point 'q' are: @x,@y,@z
[~/srcLPP/inheritance]$ 
\end{verbatim}

\begin{itemize}

\item Una variable de un objeto/instancia
se crea en el momento en el que se le asigna
un valor
\item Las variables de la instancia no son definidas por la clase
y no están relacionadas con los mecanismos de herencia
\item Si una subclase utiliza el mismo  nombre 
para una variable de instancia que alguno de sus ancestros la variable
será \emph{sobreescrita}
\end{itemize}

Puesto que las variables de instancia no están relacionadas con la
herencia, se deduce que una variable de instancia usada por una
subclase no puede
\emph{ocultar} una variable de instancia definida usada en la superclase.
Si una subclase usa una variable de instancia con el mismo nombre que una variable utilizada por uno de sus
ancestros, sobreescribirá el valor de la variable de su ancestro.
\emph{Esto puede ser que se haga con intencionalidad, para cambiar la conducta del ancestro
o puede que ocurra por accidente. En este último caso seguramente dará lugar a bugs}.


\begin{enumerate}
\item Observe que, como en el ejemplo, 
podemos siempre averiguar cuales son las variables de instancia
de un objeto \verb|q| llamando a \verb|q.instance_variables|
\item
En general, el mecanismo de herencia debe ser usado para extender clases en Ruby
sólo cuando estamos familiarizados y tenemos control de la superclase.
\item Compruebe que nombres usa la superclase para sus variables de instancia y evítelos
\item Documente sus variables de instancia en la sección para desarrolladores
\item Prefije los nombres de sus variables de instancia con el nombre de la clase. 
\end{enumerate}

\subsection{Herencia y Variables de Clase}

Las variables de clase (como \verb|@@count|) 
son compartidas por una clase y todas sus subclases.

Si una variable \verb|@@a| es definida por una clase \verb|A|
entonces cualquier subclase \verb|B| de \verb|A| puede usar dicha variable.

Si una subclase asigna un valor a una variable de clase en uso por una superclase no es que cree una copia
de dicha variable sino que altera el valor de la variable de la superclase.
Ese será el valor que vean todas las otras subclases de la superclase.

Este ejemplo ilustra el comportamiento:
\begin{verbatim}
[~/srcLPP/inheritance]$ cat InheritanceAndClassVariables.rb 
class A
  @@value = 1
  def A.value 
    @@value
  end
end

puts A.value

class B < A
  @@value = 2
end

puts A.value
puts B.value

class C < A; @@value = 3; end

puts B.value
puts C.value

puts "A.class_variables = #{A.class_variables.inspect}"
puts "B.class_variables = #{B.class_variables.inspect}"
puts "C.class_variables = #{C.class_variables.inspect}"
\end{verbatim}
Al ejecutar tenemos:
\begin{verbatim}
[~/srcLPP/inheritance]$ ruby InheritanceAndClassVariables.rb 
1
2
2
3
3
A.class_variables = [:@@value]
B.class_variables = []
C.class_variables = []
\end{verbatim}
\emph{Por esta razón es preferible usar variables de instancia de la clase en vez de variables de clase}.
Nótese que siempre podemos averiguar las variables de clase de una clase mediante el
método \verb|class_variables|.

Observa la diferencia cuando se usan variables de instancia de la clase:

\begin{verbatim}
13:11][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ cat InheritanceAndClassInstanceVariables.rb
class A
  @value = 1
  def self.value 
    @value
  end
end

puts A.value  # 1

class B < A
  @value = 2
end

puts A.value  # 1
puts B.value  # 2

class C < A; @value = 3; end

puts B.value # 2
puts C.value # 3
[13:12][~/Dropbox/src/ruby/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ ruby InheritanceAndClassInstanceVariables.rb
1
1
2
2
3
\end{verbatim}

\begin{enumerate}
\item 
Véase  el excelente artículo
\htmladdnormallink{Ruby, Smalltalk and Class Variables}{http://patshaughnessy.net/2012/12/17/ruby-smalltalk-and-class-variables} by Pat Shaughnessy 
\end{enumerate}

\subsection{Herencia y Constantes}
Las constantes son heredadas y pueden ser sobredominadas en la misma forma que los métodos.

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n  InheritanceAndConstants.rb 
     1  class Point
     2    def initialize(x,y)
     3      @x,@y = x, y
     4    end
     5  
     6    ORIGIN = Point.new(0,0)   
     7  
     8    def to_s;  "#@x #@y" end
     9  
    10    def chuchu
    11      puts ORIGIN
    12    end
    13  end
    14  
    15  class Point3D < Point
    16    def initialize(x, y, z)
    17      super(x, y); @z = z
    18    end
    19    def to_s; super+" #@z" end
    20  
    21    puts ORIGIN                  # 0 0
    22    ORIGIN = Point3D.new(0, 0, 0)
    23    puts ORIGIN                  # 0 0 0
    24    puts Point::ORIGIN           # 0 0
    25  
    26  end
    27  
    28  x = Point3D.new(1, 2, 3)
    29  x.chuchu                       # 0 0
\end{verbatim}
Obsérvese como la llamada al método \verb|chuchu|
de la línea 29  muestra \verb|Point::ORIGIN| y no
\verb|Point3D::ORIGIN|:

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby InheritanceAndConstants.rb 
0 0                 # linea 21
0 0 0               #       23
0 0                 #       24
0 0                 #       29
\end{verbatim}
\emph{La diferencia entre constantes y métodos es que las constantes se buscan en el ámbito 
léxico del lugar en el que son usadas antes de mirar en la jerarquía de herencia}.
Esto significa que si \verb|Point3D| hereda de 
\verb|Point| métodos que usan la constante \verb|ORIGIN|, la conducta de dichos métodos no cambia 
cuando \verb|Point3D| define su propia constante \verb|ORIGIN|.

\subsection{Delegación}

La delegación es un patrón de diseño que consiste en que ciertas tareas, en vez de ser realizadas por el objeto
son delegadas en ciertos objetos asistentes.

Una forma de delegar en Ruby consiste en que la clase sea una subclase de \verb|DelegateClass|,
a la que se le pasa el nombre de la clase en la que se delega como parámetro (\verb|Flintstone| en el ejemplo).
\begin{verbatim}
class Fred < DelegateClass(Flintstone)
  def initialize
    # ...
    super(Flintstone.new(...))
  end
  # ...
 end
\end{verbatim}
Luego, en el \verb|initialize| llamamos al de la superclase, pasandole como argumento el objeto en el que se delega.

Por ejemplo, podríamos reescribir la práctica de los conjuntos delegando en la clase \verb|Array| los métodos \verb|length|
e \verb|include?|:

\begin{verbatim}
~/rubytesting/sets$ cat -n setsdelegate.rb 
     1  require 'delegate'
     2  class Set2 < DelegateClass(Array)
     3  
     4    attr_accessor :sep
     5    attr_reader :a
     6    protected :a
     7  
     8    def initialize(a)
     9      @sep = ', '
    10      @a = a.uniq.sort
    11      super(@a)
    12    end
    13  
    14    def to_s
    15      @a.join(@sep)
    16    end
    17  
    18    # delegated
    19    #def length 
    20    #  @a.length
    21    #end
    22  
    23    alias cardinal length
    24  
    25    # delegated
    26    #def include?(x)
    27    #  @a.include? x
    28    #end
    29  
    30  end
    31  
    32  if __FILE__  == $0
    33    x = Set2.new [1, 2, 3, 3, 4]
    34    puts "x = #{x}"
    35    puts "x.length = #{x.length}"              # x.length = 4 
    36    puts "x.cardinal = #{x.cardinal}"          # x.cardinal = 4
    37  
    38    puts "x includes 2 = #{x.include? 2}"      # x includes 2 = true
    39    puts "x includes 8 = #{x.include? 8}"      # x includes 8 = false
    40  end
\end{verbatim}
En realidad \verb|DelegateClass(Array)| es una llamada al método \verb|DelegateClass|
del package \rubypackage{delegate}. Esta llamada crea y retorna una nueva clase, la cual define un \verb|method_missing| que redirecciona las llamadas al objeto en el que se 
delega.
\begin{verbatim}
~/rubytesting/sets$ ruby setsdelegate.rb 
x = 1, 2, 3, 4
x.length = 4
x.cardinal = 4
x includes 2 = true
x includes 8 = false
\end{verbatim}

Otra forma de delegar es usar el método \verb|delegate| de \verb|Rails|.
Podemos instalar \verb|rails| usando \verb|gem|:
\begin{verbatim}
~$ sudo gem install rails
Password:
Successfully installed rails-3.1.1
1 gem installed
Installing ri documentation for rails-3.1.1...
file 'lib' not found
Installing RDoc documentation for rails-3.1.1...
file 'lib' not found
~$ 
\end{verbatim}

El método \verb|delegate| recibe la lista de nombres de los métodos (especificados como
símbolos o strings) a delegar
y el nombre del objeto atributo en el que se delega, especificado mediante
la clave \verb|:to|.

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/chapter8ReflectionandMetaprogramming$ cat -n delegation2.rb 
   1  require "rails"
   2  module I
   3    def f
   4      puts "#{self.class}: doing f()"
   5    end
   6   
   7    def g
   8      puts "#{self.class}: doing g()"
   9    end
  10  end
  11   
  13  class A
  14    include I
  15  end
  16   
  18  class B
  19    include I
  20  end
  22   
  23  class C
  24    attr_accessor :i
  25    delegate :f, :g, :to => :i
  26   
  27    def initialize(klass = A)
  28      self.i = klass.new
  29    end
  30  end
  32   
  33  c = C.new
  34  c.f         # output: A: doing f()
  35  c.g         # output: A: doing g()
  36  c = C.new(B)
  37  c.f         # output: B: doing f()
  38  c.g         # output: B: doing g()
\end{verbatim}

\section{Creación e Inicialización de Objetos}

\subsection{new, allocate e initialize}
Todas las clases heredan el método de clase \verb|new|.
Este método tiene dos tareas: 

\begin{enumerate}
\item
debe alojar al objeto y 
\item
debe inicializarlo.
\end{enumerate}
Para estas tareas, delega en los métodos.
Este es el seudocódigo de \verb|new|: 
\verb|allocate| e \verb|initialize|:
\begin{verbatim}
def new(* args)
  o = self.allocate       # crear el objeto
  o.initialize(* args)    # inicializarlo
  o                       # retornar el objeto
end
\end{verbatim}

\begin{itemize}
\item
El método \verb|allocate| es un método de instancia de la clase \verb|Class|.
\item
Es heredado por todos los objetos clase. 
\item
Ruby invoca al
método directamente.
No puede ser sobreescrito. 
\end{itemize}

\begin{itemize}
\item \verb|initialize| es un método de instancia y privado
\item La mayor parte de las clases deberían usar \verb|super|
para encadenar con el \verb|initialize| de la superclase.
\item La tarea habitual de \verb|initialize| es crear e inicializar
las variables de instancia del objeto, cuyos valores normalmente 
se derivan de los argumentos pasados a \verb|new|.
\item El valor retornado por \verb|initialize| es ignorado.
\item
En realidad, \verb|Class| define dos métodos con nombre \verb|new|:
\begin{itemize}
\item
Uno \verb|Class#new| es el método de instancia descrito aquí.
\item
El otro \verb|Class::new| es un método de clase y se usa para crear nuevas clases.
\end{itemize}
\end{itemize}


\subsection{Métodos Factoría}

A veces se necesita mas de una forma de inicializar las instancias
de una clase.
Una manera simple de hacerlo es dando valores por defecto a los 
parámetros de \verb|initialize|:

\begin{verbatim}
class Point
  def initialize(x, y, z = nil)
    @x,@y,@z = x,y,z
  end
end
\end{verbatim}
Pero a menudo no es suficiente con esto. Necesitamos \cei{factory methods} o
\cei{métodos factoría} 
para crear los objetos de nuestra clase.

Supongamos que queremos crear objetos \verb|Point|
bien en coordenadas cartesianas
bien encoordenadas  polares:

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n CartAndPolar.rb 
     1  include Math
     2  class Point
     3    attr_accessor :x, :y
     4  
     5    def initialize(x, y)
     6      @x, @y = x,y
     7    end
     8  
     9    private_class_method :new
    10  
    11    def Point.cartesian(x,y)
    12      new(x,y)
    13    end
    14  
    15    def Point.polar(r,theta)
    16      new(r*cos(theta), r*sin(theta))
    17    end
    18  
    19    def r 
    20      sqrt(@x*@x+@y*@y)
    21    end
    22  
    23    def theta
    24      atan2(@y, @x)
    25    end
    26  end
    27  if __FILE__ == $0 
    28    p = Point.polar(1, PI/4)
    29    puts p.r, p.theta         # 1.0 0.785398
    30    q = Point.cartesian(1, 1) # 1 1
    31    puts q.x, q.y
    32  end
\end{verbatim}
Al hacer \verb|new| privado lo hacemos inaccesible a las clases cliente,
de manera que las clases usuario de \verb|Point| deberán de usar uno de los dos métodos factoría proveídos para construir un objeto \verb|Point|.

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby CartAndPolar.rb 
1.0
0.785398163397448
1
1
\end{verbatim}

\subsection{dup, clone e initialize\_copy}

Otra forma de construir objetos es via los métodos
\verb|dup| y \verb|clone|. 
Estos métodos crean un objeto que es una copia del del objeto que recibe el mensaje:
\begin{verbatim}
>> a = "hello"
=> "hello"
>> b = a.dup
=> "hello"
>> c = a.clone
=> "hello"
>> [a.__id__, b.__id__, c.__id__]
=> [2150357800, 2150329860, 2150304120]
\end{verbatim}

\verb|clone| hace una copia mas parecida que \verb|dup|. Por ejemplo,
conserva el estatus de \verb|freeze| del original, cosa que no hace \verb|dup|:

\begin{verbatim}
>> a = "hello"
=> "hello"
>> a.freeze
=> "hello"
>> a << " world"
TypeError: can't modify frozen string
>> b = a.clone
=> "hello"
>> b << " world"
TypeError: can't modify frozen string
>> c = a.dup
=> "hello"
>> c << " world"
=> "hello world"
\end{verbatim}

\verb|clone| incluso preserva los {\it singleton methods}, esto es, preserva los métodos individuales
del objeto. Sin embargo, \verb|dup| no lo hace.

Un singleton method es un método \verb|x| que se añade a un objeto \verb|obj|
específico. A partir del momento en el que se añade, ese objeto \verb|obj|
responde el mensaje \verb|x|, cosa que no hacen los otros métodos de su clase.
Sigue un ejemplo:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n singletonmethandclone.rb 
     1  obj = "some object"
     2  def obj.printme
     3    puts "***<#{self}>***"
     4  end
     5  
     6  obj.printme
     7  
     8  b = obj.dup
     9  c = obj.clone
    10  
    11  c.printme
    12  b.printme
\end{verbatim}
En la línea 2 añadimos el método \verb|printtime| únicamente al objeto \verb|obj|. El objeto clonado
\verb|c| también puede hacer \verb|printtime|. No así la copia \verb|b| obtenida por duplicación:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby singletonmethandclone.rb 
***<some object>***
***<some object>***
singletonmethandclone.rb:12: undefined method `printme' for "some object":String (NoMethodError)
\end{verbatim}

Cuando \verb|clone| y \verb|dup| copian las variables de instancia / atributos del objeto original al objeto final
\emph{sólo copian las referencias a los valores de esas variables no copian los valores reales: sólo hacen una copia superficial}.
El siguiente ejemplo ilustra este punto:

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n dupclone1.rb 
     1  class Point
     2    attr_accessor :coords
     3    def initialize(* coords)
     4      @coords = coords
     5    end
     6  end
     7  
     8  if __FILE__ == $0
     9    puts "dup"
    10    p = Point.new(1, 2, 3)
    11    q = p.dup
    12    puts p.inspect
    13    puts q.inspect
    14  
    15    q.coords[1] = 4
    16    puts p.inspect
    17    puts q.inspect
    18  
    19    puts "clone"
    20    p = Point.new(1, 2, 3)
    21    q = p.clone
    22    puts p.inspect
    23    puts q.inspect
    24  
    25    q.coords[1] = 4
    26    puts p.inspect
    27    puts q.inspect
    28  end
\end{verbatim}
La ejecución nos muestra que la copia es superficial:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby dupclone1.rb 
dup
#<Point:0x100169008 @coords=[1, 2, 3]>
#<Point:0x100168fe0 @coords=[1, 2, 3]>
#<Point:0x100169008 @coords=[1, 4, 3]>
#<Point:0x100168fe0 @coords=[1, 4, 3]>
clone
#<Point:0x100168c20 @coords=[1, 2, 3]>
#<Point:0x100168bf8 @coords=[1, 2, 3]>
#<Point:0x100168c20 @coords=[1, 4, 3]>
#<Point:0x100168bf8 @coords=[1, 4, 3]>
\end{verbatim}
Lo que se necesita es una copia profunda.

Si una clase define un método \verb|initialize_copy|,
los métodos \verb|clone| y \verb|dup| lo invocarán en el {\it objeto copia}.
Al método \verb|initialize_copy| se le pasa el objeto original como argumento.
El valor retornado por \verb|initialize_copy| es ignorado:

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n dupclone2.rb 
     1  class Point
     2    attr_accessor :coords
     3    def initialize(* coords)
     4      @coords = coords
     5    end
     6  
     7    def initialize_copy(orig)
     8      @coords = orig.coords.dup 
     9      # or better
    10      # @coords = @coords.dup 
    11    end
    12  end
    13  
    14  if __FILE__ == $0
    15    puts "dup"
    16    p = Point.new(1, 2, 3)
    17    q = p.dup
    18    puts p.inspect
    19    puts "q = p.dup = "+q.inspect
    20  
    21    q.coords[1] = 4
    22    puts "Changed q[1] to 4 and p has "+p.inspect
    23    puts "Changed q[1] to 4 and q has "+q.inspect
    24  
    25    puts "clone"
    26    p = Point.new(1, 2, 3)
    27    q = p.clone
    28    puts p.inspect
    29    puts "q = p.clone = "+q.inspect
    30  
    31    q.coords[1] = 4
    32    puts "Changed q[1] to 4 and p has "+p.inspect
    33    puts "Changed q[1] to 4 and q has "+q.inspect
    34  end
\end{verbatim}
La ejecución produce la siguiente salida:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby dupclone2.rb 
dup
#<Point:0x100168900 @coords=[1, 2, 3]>
q = p.dup = #<Point:0x1001688d8 @coords=[1, 2, 3]>
Changed q[1] to 4 and p has #<Point:0x100168900 @coords=[1, 2, 3]>
Changed q[1] to 4 and q has #<Point:0x1001688d8 @coords=[1, 4, 3]>
clone
#<Point:0x1001683d8 @coords=[1, 2, 3]>
q = p.clone = #<Point:0x1001683b0 @coords=[1, 2, 3]>
Changed q[1] to 4 and p has #<Point:0x1001683d8 @coords=[1, 2, 3]>
Changed q[1] to 4 and q has #<Point:0x1001683b0 @coords=[1, 4, 3]>
\end{verbatim}

\subsection{Limitando el Número de Instancias de una Clase}
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n LimitingTheNumberOfInstances.rb 
     1  class Season
     2    NAMES = %w{ Spring Summer Autumn Winter }
     3    INSTANCES = []
     4  
     5    def initialize(n)
     6      @n = n
     7    end
     8  
     9    def to_s
    10      NAMES[@n]
    11    end
    12  
    13    NAMES.each_with_index { |n,i|
    14      season = new(i)
    15      INSTANCES[i] = season
    16      const_set n, season
    17    }
    18  
    19    private_class_method :allocate, :new
    20    private :dup, :clone
    21  end
    22  
    23  if __FILE__ == $0
    24    puts Season::Spring 
    25    puts Season::Summer
    26    puts Season::Autumn
    27    puts Season::Winter
    28  end
\end{verbatim}
El método \htmladdnormallink{const\_set}{http://www.ruby-doc.org/core-1.8.7/Module.html\#method-i-const\_set}
de la clase \htmladdnormallink{Module}{http://www.ruby-doc.org/core-1.8.7/Module.html}
establece el valor asociado con el nombre pasado como primer argumento al objeto dado como segundo argumento:
\begin{verbatim}
>> Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)
=> 3.14285714285714
>> Math::HIGH_SCHOOL_PI
=> 3.14285714285714
\end{verbatim}

Cuando se ejecuta el programa anterior produce esta salida:
\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby LimitingTheNumberOfInstances.rb 
Spring
Summer
Autumn
Winter
\end{verbatim}




\sectionpractica{Conjuntos}

Defina una clase Conjunto
que disponga de métodos para:
  \begin{itemize}
  \item
  Calcular el cardinal de un conjunto
  \item
  Determinar las relaciones pertenencia de un elemento y subconjunto
  \item
  La operaci\'{o}n de uni\'{o}n:
  \item
  La operaci\'{o}n de intersecci\'{o}n
  \item
  Diferencia de conjuntos
  \item
  Convertir un conjunto en una cadena
  \end{itemize}
Debe funcionar  de manera similar a la clase \htmladdnormallink{Set}{http://www.ruby-doc.org/stdlib/libdoc/set/rdoc/classes/Set.html}
proveída con Ruby:

\begin{verbatim}
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ irb
>> require 'set'
=> true
>> s1 = Set.new [1, 2]
=> #<Set: {1, 2}>
>> s2 = Set.new [2, 4]
=> #<Set: {2, 4}>
>> s1+s2
=> #<Set: {1, 2, 4}>
>> s1^s2
=> #<Set: {1, 4}>
>> s2-s1
=> #<Set: {4}>
>> s1.include? 1
=> true
>> s1.include? 6
=> false
\end{verbatim}
Puede usar \verb|Array|s para implementar los conjuntos.
Asuma que los elementos del conjunto universal admiten un orden total.
Esta sesión con \verb|irb| sugiere una posible implementación:
\begin{verbatim}
>> a = [6, 4, 3, 4, 2, 1].uniq.sort
=> [1, 2, 3, 4, 6]
>> b = [2, 3, 2, 4, 5].uniq.sort
=> [2, 3, 4, 5]
>> (a | b).uniq.sort
=> [1, 2, 3, 4, 5, 6]
>> (a & b).uniq.sort
=> [2, 3, 4]
\end{verbatim}
Esto es, puede guardar el conjunto como un \verb|Array| ordenado
en el que se han suprimido los elementos repetidos.

La relación de orden entre conjuntos es parcial: dados dos conjuntos \verb|A| y \verb|B|
no necesariamente ocurre que \verb|A < B| o aque \verb|B < A|. 


\section{Modulos}

\begin{itemize}
\item
Al igual que una clase, un \cei{módulo} es una colección de métodos, constantes y variables de clase.
\item
A diferencia de una clase, un módulo no puede ser instanciado y no puede ser heredado (aunque puede ser incluído)
\item
Los módulos tienen dos usos: como espacios de nombres y como \wikip{mixins}{Mixin}
\item
Los módulos son objetos de la clase \verb|Module|
\item
\verb|Class| es una subclase de \verb|Module|
\end{itemize}

  \subsection{Los Módulos como Espacios de Nombres}
  Al definir un módulo se crea una constante con el mismo nombre del módulo.
  El valor de dicha constante es el objeto \verb|Module| que representa al módulo.

Supongamos que estamos un método para codificar y decodificar datos
binarios utilizando la codificación \verb|Base64|.
Para preveer colisiones de nombres definimos nuestros dos métodos
dentro de un módulo:

\begin{verbatim}
casiano@exthost:~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules$ cat -n base64_mod_self.rb      1    module Base64
     2    
     3   puts self  # Base64
     4  
     5   DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
     6            'abcdefghijklmnopqrstuvwxyz' +
     7            '0123456789+/'
     8    @x = "hello"
     9            
    10    def self.encode
    11       "self.encode #@x"
    12    end 
    13  
    14    def self.decode
    15      "self.decode #@x"
    16    end 
    17  end
    18  if $0 == __FILE__
    19    puts Base64::DIGITS
    20    puts Base64.encode
    21    puts Base64.decode
    22  end
\end{verbatim}

\begin{verbatim}
casiano@exthost:~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules$ cat -n client.rb      1     require 'base64_mod_self'
     2  
     3  class A
     4    include Base64
     5  
     6    def self.tutu
     7      Base64::encode
     8    end
     9  end
    10  
    11  if $0 == __FILE__
    12    puts A.tutu
    13    puts Base64::DIGITS
    14  end
\end{verbatim}

\begin{verbatim}
casiano@exthost:~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules$ ruby client.rb 
Base64
self.encode hello
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
\end{verbatim}

      \subsubsection{Espacios de Nombres Anidados}
\begin{itemize}
\item
Los módulos y las clases pueden anidarse creando espacios de nombres anidados.

\item
Una clase o módulo anidado dentro de otro no tiene acceso especial al módulo o clase en la que se anida.
\end{itemize}

\begin{verbatim}
module Base64
  DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

  class Encoder
    def encode
    end
  end

  class Decoder
    def decode
    end
  end

  # A utility function for use by both classes
  def Base64.helper
  end
end
\end{verbatim}
Tenemos dos clases: \verb|Base64::encoder| y \verb|Base64::Decoder|.
Dentro del módulo las clases pueden referirse la una a la otra y a la constante \verb|DIGITS| por
sus nombres simples, sin cualificar.
Sin embargo, para llamar a \verb|Base64.helper| deben referirse a él por
su nombre completo: \verb|Base64.helper|.

Las clases pueden también anidarse.
Anidar una clase dentro de otra no le da a la clase ningún privilegio especial de acceso a los 
métodos y variables en la clase mas externa.
Su único efecto es en el espacio de nombres de la clase interna.


Cuando escribimos una gema es conveniente anidar las clases y módulos - especialmente aquellas clases
que no forman parte de la API pública -
para no contaminar los espacios de nombres públicos.


\subsection{Los Módulos como Mixins}

Si un módulo define métodos de instancia en vez de métodos de clase,
esos métodos de instancia pueden ser combinados/mezclados en otras clases.

Para mezclar un módulo en una clase llamamos al método \cei{include}:
\begin{verbatim}
class Point
  include Comparable
end
\end{verbatim}
\verb|include| es un método privado de instancia de \verb|Module|:

\begin{verbatim}
ruby-1.9.2-head :004 > Module.private_instance_methods.select {|x| x =~ /inc/ }
 => [:included, :include] 
\end{verbatim}
Es legal incluir un módulo en una clase o en un  módulo.
Al hacerlo los métodos de instancia del módulo incluído
se convierten en métodos de instancia del incluyente.


Aunque \verb|Module.include| es la forma normal de mezclar un módulo también es posible
mezclar con \verb|Object.|\objecti{extend}.
Este método hace que los métodos de instancia del módulo especificado se 
incorporen como métodos singleton del objeto receptor.
Si el objeto receptor es una clase, esto es, es un objeto de la clase \verb|Class|,
entonces los métodos son métodos de clase de dicha clase receptora.

\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/modules]$ cat module_mixin_with_extend.rb 
module Chuchu
  def tutu
    "method tutu. self: #{self.inspect}"
  end
end

class ChanChan
end

p = "hello "
q = "world"
p.extend Chuchu

puts p.tutu

ChanChan.extend Chuchu
puts ChanChan.tutu

puts q.tutu # exception
\end{verbatim}
Ejecución:
\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/modules]$ ruby module_mixin_with_extend.rb 
method tutu. self: "hello "
method tutu. self: ChanChan
module_mixin_with_extend.rb:19:in `<main>': undefined method `tutu' for "world":String (NoMethodError)
\end{verbatim}

\subsubsection{Colisiones}
\label{subsection:colisiones}
¿Que ocurre si se incluyen dos módulos en los que existen métodos con el mismo nombre?
\begin{verbatim}
[~/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules]$ cat module_collision.rb 
module M1
  def foo
    puts "M1"
  end
end

module M2
  def foo
    puts "M2"
  end
end
\end{verbatim}

Cuando ambos módulos son incluídos en la clase \verb|C|, la última definición de \verb|foo| es la que 
domina:
\begin{verbatim}
[~/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules]$ cat class_require_module_collision.rb 
require 'module_collision'
class C
  include M1
  include M2
end

C.new.foo # 'M2'
puts C.ancestors.inspect # => [C, M2, M1, Object, Kernel, BasicObject]
\end{verbatim}

Ahora bien, si en la clase existe un método \verb|foo| ese será encontrado primero:
\begin{verbatim}
[~/TheRubyProgrammingLanguage/Chapter7ClassesAndModules/modules]$ cat -n module_class_collision.rb 
 1  module M
 2    def foo
 3      puts "M"
 4    end
 5  end
 6  
 7  class C
 8    def foo
 9      puts "C"
10    end
11    include M
12  end
13  C.new.foo                # => "C"
14  puts C.ancestors.inspect # => [C, M, Object, Kernel, BasicObject]
\end{verbatim}

\subsection{Módulos Espacio de Nombres Incluíbles}
\label{subsection:modulosespaciodenombresincluibles}
\begin{verbatim}
[~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules]$ irb
ruby-1.9.2-head :001 > Math.sin(Math::PI/2)
 => 1.0 
ruby-1.9.2-head :002 > include Math
 => Object 
ruby-1.9.2-head :003 > sin(PI/2)
 => 1.0 
\end{verbatim}
\begin{itemize}
\item
Para crear un módulo que funcione como \cei{Math} define
tus métodos como métodos de instancia dentro del módulo
\item Usa la función \verb|module_function|, un método de instancia privado
de \verb|Module| para convertir en \cei{module functions} a los métodos
cuyos nombres le pases como argumentos
\item
El resultado de llamar a \cei{module\_function} es que: 
\begin{itemize}
\item
construye métodos
de clase equivalentes para cada uno de los métodos de instancia especificados
\item
Hace privados a los métodos de instancia implicados
\end{itemize}
\end{itemize}

\begin{verbatim}
~/srcLPP/Chapter7ClassesAndModules/modules]$ cat module_function.rb 
module SpaceOdissey

  THE_UNIVERSE = 1

  def tutu
    "inside tutu"
  end

  module_function :tutu
end

puts SpaceOdissey::THE_UNIVERSE
puts SpaceOdissey::tutu

include SpaceOdissey
puts THE_UNIVERSE
puts tutu
\end{verbatim}
Ejecución:
\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/modules]$ ruby module_function.rb 
1
inside tutu
1
inside tutu

\end{verbatim}
Cuando se define una función-módulo se debe evitar hacer uso de \verb|self|
ya que el valor de \verb|self| hará que dependa de como es invocada.


\section{Carga y Solicitud de Módulos}

  \subsection{El Camino de Búsqueda}

  \subsection{Ejecutando Código Cargado}

\begin{itemize}
\item
\cei{load} y\cei{require} ejecutan el código en el fichero especificado inmediatamente.
\item
La ejecución ocurre en un nuevo ámbito al nivel mas alto, que es diferente
del ámbito en el que se invocó el \verb|load| o el \verb|require|
\item El fichero cargado puede 
\begin{itemize}
\item
Ver las variables globales
\item
Ver las constantes
\item
No puede ver  las variables locales
\end{itemize}
Esto conlleva:
\begin{itemize}
\item
Las variables locales creadas por el fichero cargado se descartan una vez que se termina la carga
\item
Al comienzo de la carga \verb|self| es \verb|main| tal como 
ocurre cuando el intérprete Ruby  comienza la ejecución. 
\item
Invocar \verb|load| o \verb|require| no propaga el objeto receptor 
al fichero cargado.
\item
El anidamiento actual de módulos es ignorado.
Esto es: No podemos , por ejemplo, abrir una clase y luego cargar un fichero con definiciones de métodos y esperar
que estén en la clase. El fichero será procesado al nivel mas alto de ámbito, no dentro de 
la clase o módulo.
\end{itemize}

\end{itemize}

     \subsubsection{Envolviendo una Carga}
     Si al método \verb|load| se le pasa un segundo argumento que sea distinto de \verb|nil| y \verb|false|
     entonces carga el fichero especificado en un módulo anónimo. De esta forma el fichero cargado
     no puede afectar al espacio de nombres global. Todas las constantes, clases, módulos que define 
     quedan atrapados dentro del módulo anónimo. Sin embargo puede establecer variables globales que quedan visibles
en el código que lo carga.

\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/modules]$ cat -n wrapped_module.rb 
     1  # Modules do not change the names of instance variables
     2  # or private methods 
     3  module Space
     4    class Chazam
     5      def tutu
     6        "inside tutu"
     7      end
     8    end
     9  end
    10  $Space = Space
\end{verbatim}

\begin{verbatim}
[~/srcLPP/Chapter7ClassesAndModules/modules]$ cat -n wrapped_loads.rb 
     1  load 'wrapped_module.rb', true
     2  puts $Space.inspect
     3  
     4  q = $Space :: Chazam.new # :: is an operator!
     5  puts q.tutu
\end{verbatim}

\begin{verbatim}
#<Module:0x007fd9c284e790>::Space
inside tutu
[~/srcLPP/Chapter7ClassesAndModules/modules]$ 
\end{verbatim}

  \subsection{Autoloading de Módulos}

\section{Los Métodos Singleton y la Singleton Class o Eigenclass}
\label{section:singleton_y_eigenclass}

Vimos en la sección \ref{subsection:metodos_singleton}
que es posible definir \emph{métodos singleton, métodos
que están definidos para un único objeto mas que para toda una clase 
de objetos}.

\begin{verbatim}
def Point.sum
  # Method body goes here
end
\end{verbatim}

\emph{Los métodos de clase de una clase no son mas que métodos singleton de la
instancia de la clase {\tt Class} que representa a la clase}:

\begin{itemize}
\item
Los métodos singleton de un objeto no estan definidos por la clase del objeto
\item
Dichos métodos son métodos de una clase anónima asociada con el objeto.
Dicha clase se conoce como \cei{Eigenclass}, \cei{Singleton Class} o \cei{Metaclass}
\item
Ruby define una sintáxis alternativa para abrir la \cei{singleton class} o\cei{eigenclass} de un objeto y añadirle
métodos. Para abrir la singleton class o eigenclass del objeto \verb|obj| usamos \verb|class << obj|. Por
ejemplo:
\begin{verbatim}
class << Point
  def class_method1      # This is an instance method of the eigenclass.
  end                    # It is also a class method of Point.

  def class_method2
  end
end
\end{verbatim}
\item Si abrimos la singleton class o 
eigenclass de un objeto clase dentro de la definición de la misma clase
podemos usar \verb|self| en vez del nombre de la clase:
\begin{verbatim}
class Point
  # instance methods go here

  class << self
    # class methods go here as instance methods of the eigenclass
  end
end
\end{verbatim}
\item
Obsérvese las diferencias entre estas 3 líneas:
\begin{verbatim}
class Point            # Create or open the class Point
class Point3D < Point  # Create a subclass of Point
class << Point         # Open the eigenclass of the object Point
\end{verbatim}

\item
Una forma de obtener la singleton class o eigenclass es:
\begin{verbatim}
eigenclass = class << o; self; end
\end{verbatim}
\end{itemize}

\section{La Búsqueda por Métodos}
\label{section:la_busqueda_por_metodos}

Cuando Ruby evalúa una expresión de invocación de un método (este proceso
es conocido como \cei{method lookup} o \cei{method resolution}), por ejemplo
\verb|o.m| ocurren los siguientes pasos:

\begin{enumerate}

\item
\label{item:busca_eigenclass}
Primero comprueba en la \cei{singleton class} o \cei{eigenclass} de \verb|o| la existencia de un método \verb|m|
 
\item
\label{item:busca_clase}
Si no, busca en la clase de \verb|o| por un método \verb|m|

\item
\label{item:busca_modulos}
Si no, busca en los módulos incluídos por la clase de \verb|o|.
Si la clase incluye mas de un módulo se buscan en orden inverso al orden en el que fueron incluídos

\item
Si no, se mueve hacia arriba en la clase de herencia a la superclase.
Los pasos
\ref{item:busca_clase}
y
\ref{item:busca_modulos}
se repiten para cada clase en la jerarquía de herencia hasta que todos los 
antecesores y módulos incluídos han sido buscados.

\item
Si no, se invoca a un método con nombre \cei{method\_missing}.
Para encontrar dicho método se empieza en el paso
\ref{item:busca_eigenclass}.

El módulo \verb|Kernel| provee una implementación por defecto de
\verb|method_missing| por lo que queda garantizado 
el éxito de esta segunda pasada.
\end{enumerate}

  \subsection{Búsqueda de Métodos de Clase}
\label{subsection:busqueda_de_metodos_de_clase}

El algoritmo de resolución para los métodos de clase es el mismo 
que para los métodos de instancia, pero con un cambio importante.

Supongamos esta clase \verb|C| sin métodos:
\begin{verbatim}
class C
end
\end{verbatim}

Supongamos la llamada:
\begin{verbatim}
c = C.new
\end{verbatim}

\begin{enumerate}
\item Ruby busca en la eigenclass de \verb|C|, no se encuentra
\item
Se busca a continuación en la clase de \verb|C|, pero esta clases es la clase \verb|Class|.

\item
En \verb|Class| ruby encuentra el método de instancia \verb|new| y lo invoca
\end{enumerate}

En Ruby cualquier invocación a un método implica
un objeto receptor y un nombre de método.
Si nuestro objeto es una instancia de la clase
\verb|Class| entonces nuestro objeto es una clase.

Para explicar en que consite 
el cambio importante en la búsqueda 
de métodos de clase mencionado 
antes, consideremos este otro ejemplo
en el que definimos un método de clase 
\verb|Integer.parse|:
\begin{verbatim}
def Integer.parse(text)
  text.to_i
end
\end{verbatim}
Puesto que \verb|Fixnum| es una subclase de 
\verb|Integer| deberíamos poder invocarlo así:
\begin{verbatim}
n = Fixnum.parse("1")
\end{verbatim}
Si aplicamos el method lookup anterior tendríamos:
\begin{enumerate}
\item
Se busca en la eigenclass de \verb|Fixnum|: no se encuentra
\item 
Se busca en la clase de \verb|Fixnum|: es \verb|Class|.
No se encuentra
\item Se busca en \verb|Module|, \verb|Object| y \verb|Kernel| 
infructuosamente 
\end{enumerate}

Falla. ¿Donde se encuentra el método \verb|parse|?.
Sabemos que \verb|parse| \emph{es un método singleton del objeto} \verb|Integer|.
Por tanto está en la eigenclass de \verb|Integer|.

\begin{enumerate}
\item
Los objetos de la clase \verb|Class|
son especiales: tienen \cei{superclases}.
\item
Las eigenclases de los objeto de la clase \verb|Class|
son también especiales: tienen \cei{superclases}.
\item
La eigenclass de un objeto ordinario no tiene superclase
\item
Si la clase \verb|A| hereda de la clase \verb|B| (esto es \verb|A < B|)
y \verb|A'| denota la eigenclass de \verb|A|
y \verb|B'| denota la eigenclass de \verb|B|,
entonces la superclase de \verb|A'| es \verb|B'|
\item
Ruby para los métodos singleton busca en la eigenclass del objeto y en todas las superclases de la eigenclass 
\end{enumerate}
Si aplicamos el nuevo lookup  a la búsqueda de \verb|Fixnum.parse| en:
\begin{verbatim}
n = Fixnum.parse("1")
\end{verbatim}
tendríamos:

\begin{enumerate}
\item
Se busca en la eigenclass de \verb|Fixnum|: no se encuentra
\item
Busca en la superclase de la eigenclass de  \verb|Fixnum| esta es la eigenclass de \verb|Integer| y allí encuentra el método \verb|parse|
\item
Si no lo hubiera encontrado hubiera probado con las subsiguientes eigenclasses de \verb|Numeric| y \verb|Object|. 
Es decir, sigue buscando por métodos singleton
\item
Después probaría con \verb|Class|,
\verb|Module|,
\verb|Object| y \verb|Kernel|
\end{enumerate}

\section{La Búsqueda de Constantes}
\label{section:busqueda_de_constantes}
Cuando se referencia una constante sin cualificar su espacio de nombres el intérprete 
Ruby busca por la definición apropiada de la constante.

\begin{enumerate}
\item
Intenta resolver la constante en el ámbito local en el que ocurre la referencia
\item
Si no, busca en el siguiente módulo o clase que anida en su ámbito
la referencia a la constante
\item
Esto continúa hasta que no hay mas clases o módulos que encierren a la referencia
\item
Si no se encuentra la constante se pasa a buscar en la jerarquía de herencia
\item
Si no se encuentra se buscan en las constantes globales
\item
Si no se encuentra se llama al método \verb|const_missing|
\end{enumerate}

\begin{enumerate}
\item 
El método de clase \verb|Module.nesting| retorna la lista de clases y módulos que serán buscados
en el orden de búsqueda
\item
El método \verb|ancestors| de una clase o módulo retorna la lista de clases y módulos
que serán buscados después que la búsqueda por ámbito fracase
\end{enumerate}

<%= listing %q{
module Kernel
  # Constants defined in Kernel
  A = B = C = D = E = F = "defined in kernel"
end

# Top-level or "global" constants defined in Object
A = B = C = D = E = "defined at toplevel"

class Super
  # Constants defined in a superclass
  A = B = C = D = "defined in superclass"
end

module Included
  # Constants defined in an included module
  A = B = C = "defined in included module"
end

module Enclosing
  # Constants defined in an enclosing module
  A = B = "defined in enclosing module"

  class Local < Super
    include Included

    # Locally defined constant
    A = "defined locally"

    # The list of modules searched, in the order searched
    # [Enclosing::Local, Enclosing, Included, Super, Object, Kernel]
    search = (Module.nesting + self.ancestors + Object.ancestors).uniq

    puts A  # Prints "defined locally"
    puts B  # Prints "defined in enclosing module"
    puts C  # Prints "defined in included module"
    puts D  # Prints "defined in superclass"
    puts E  # Prints "defined at toplevel"
    puts F  # Prints "defined in kernel"
  end
end
}%>

\begin{itemize}
\item
Las constantes del nivel mas alto, definidas fuera de cualquier clase o módulo
son definidas implícitamente en \verb|Object|. Cuando una constante del 
nivel mas alto es referenciada dentro de una clase, es resuelta durante el paso de
búsqueda en la jerarquía de herencia
\item
El módulo \verb|Kernel| es un ancestor de \verb|Object|.
Las constantes definidas en  \verb|Kernel| pueden ser sobreescritas 
por constantes al nivel mas alto, ya que estan se definen implícitamente en \verb|Object|
\end{itemize}

\section{Jugador de TicTacToe}
\label{section:jugador_de_tic_tac_toe}

\subsection{Ejemplo de Partida}
Comencemos viendo un ejemplo de partida:
\begin{verbatim}
[~/srcLPP/tictactoe(master)]$ ruby lpp_solution.rb 

  +---+---+---+
a |   |   |   |
  +---+---+---+
b |   | X |   |
  +---+---+---+
c |   |   |   |
  +---+---+---+
    1   2   3

Your move?  (format: b3)  c1

  +---+---+---+
a |   |   | X |
  +---+---+---+
b |   | X |   |
  +---+---+---+
c | O |   |   |
  +---+---+---+
    1   2   3

Your move?  (format: b3)  a1

  +---+---+---+
a | O |   | X |
  +---+---+---+
b | X | X |   |
  +---+---+---+
c | O |   |   |
  +---+---+---+
    1   2   3

Your move?  (format: b3)  b3

  +---+---+---+
a | O |   | X |
  +---+---+---+
b | X | X | O |
  +---+---+---+
c | O |   | X |
  +---+---+---+
    1   2   3

Your move?  (format: b3)  a2

  +---+---+---+
a | O | O | X |
  +---+---+---+
b | X | X | O |
  +---+---+---+
c | O | X | X |
  +---+---+---+
    1   2   3

Tie game.

[~/srcLPP/tictactoe(master)]$
\end{verbatim}

\subsection{Programa Principal}
Este es el programa principal. Simplemente se llama al constructor de la clase 
\verb|TicTacToe::Game| el cual crea el objeto partida. Despúes llamamos al método \verb|play|
del objeto para que se juege la partida:
\begin{verbatim}
if __FILE__ == $0
  if ARGV.size > 0 and ARGV[0] == "-d"
    game = TicTacToe::Game.new TicTacToe::HumanPlayer,
                   TicTacToe::DumbPlayer
  else
    game = TicTacToe::Game.new TicTacToe::HumanPlayer,
                   TicTacToe::SmartPlayer
  end 
  game.play
end
\end{verbatim}

\subsection{La Clase Game}

La clase \verb|Game| define los objetos que describen una \emph{partida}.
El constructor recibe como argumentos las clases que describen a los jugadores:
\begin{verbatim}
module TicTacToe
  class Game
    def initialize( player1, player2, random = true )
      if random and rand(2) == 1 # decidimos quien juega con "X" y quien con "O"
        @x_player = player2.new("X")
        @o_player = player1.new("O")
      else
        @x_player = player1.new("X")
        @o_player = player2.new("O")
      end
      
      @board = Board.new([" "] * 9) # Usamos la clase "Board"
    end
    
    attr_reader :x_player, :o_player
    
    def play
      until @board.won?
        @board[@x_player.move(@board)] = @x_player.mark
        break if @board.won?
        
        @board[@o_player.move(@board)] = @o_player.mark
      end
      
      @o_player.finish @board
      @x_player.finish @board
    end
  end
end
\end{verbatim}

\subsection{La Clase Player: Un Ejemplo de \emph{Strategy Pattern}}

El concepto de jugador es definido mediante una clase abstracta:

\begin{verbatim}
module TicTacToe
  class Player
    def initialize( mark )
      @mark = mark # "X" or "O" or " "
    end
····
    attr_reader :mark
····
    def move( board )
      raise NotImplementedError, "Player subclasses must define move()."
    end
····
    def finish( final_board )··
    end
  end
end
\end{verbatim}
de la que heredan los jugadores concretos.

Cada jugador es una clase. Por ejemplo, el jugador humano:
\begin{verbatim}
module TicTacToe
  class HumanPlayer < Player
    def move( board )
      print board
      ....
    end
    
    def finish( final_board )
      ....
    end
  end
end
\end{verbatim}
Un par de jugadores mas, uno tonto y otro listo:
\begin{verbatim}
module TicTacToe
  class DumbPlayer < Player
    def move( board )
      moves = board.moves
      moves[rand(moves.size)]
    end
  end

  class SmartPlayer < Player
    def move( board )
      ....
    end
  end
end
\end{verbatim}
La Banda de los Cuatro (\cei{The Gang of Four} o \cei{GoF}) 
llama a esta idea de \emph{implanta el algoritmo en clases separadas} el 
\cei{strategy pattern} o \cei{patrón estrategia} \cite{DPR}, \cite{GO4}.
Esta estrategia puede aplicarse cuando ocurre que en medio de nuestra aplicación
tenemos una parte que varía (el tipo de jugador). 
A veces en esa parte queremos  hacer una cosa (usar el jugador \verb|SmartPlayer|) y a veces
otra (el jugador \verb|HumanPlayer|). Es mas, es seguro que en el futuro se querrá
otra cosa (¿que tal un jugador \verb|MiniMaxPlayer|?).
\begin{enumerate}
\item 
La idea clave es definir una familia de clases, las \cei{strategy}
o \cei{estrategias} que hacen de distintas formas la misma cosa:
en nuestro ejemplo son los distintos tipos de \verb|Player| que lo
que hacen es decidir la próxima jugada mediante  \verb|move|.
\item 
No sólo realizan la misma tarea sino que comparten la misma interfaz definida por la
clase \verb1Player1.
\item 
Dado que todos los objetos \cei{strategy}
tiene la misma pinta vistos desde fuera, pueden ser usados
por el usuario de la estrategia - Al que la GoF denomina \cei{context}
o \cei{contexto} - como partes intercambiables. En nuestro caso el context
es la clase 
\verb|Game|, que usa los \verb|Player|s como objetos intercambiables
\item 
Al separar la clase cliente \verb|Game| - el contexto -
de las clases estrategia \verb|Player|s es necesario habilitar un mecanismo 
de comunicación entre el contexto y la estrategia. En este ejemplo se ha optado por 
pasar  esa información - el tablero - como argumento:
\begin{verbatim}
  @board[@x_player.move(@board)] = @x_player.mark # dentro del método play de la clase Game
\end{verbatim}
La estrategia - el jugador \verb|@x_player| - recibe el tablero \verb|@board| 
y retorna su decisión - la jugada \verb|@x_player.move(@board)| (algo como \verb|"b2"|)
\item 
Un ejemplo de uso práctico del patrón Strategy puede verse en el código de \verb|rdoc|, 
la herramienta que se usa en Ruby para extraer documentación
de los programas: por un lado hay una variación en los parsers que soporta: C, Ruby y FORTRAN.
Por otro lado la salida puede hacerse en diversos formatos: XML, distintas versiones de HTML, CHM, \verb|ri|, etc.
En \verb|rdoc| cada uno de los formatos de salida es manejado mediante una estrategia.
\end{enumerate}

\subsection{La Clase Board}
La clase \verb|TicTacToe::Game| confía en la clase \verb|Board| que describe las operaciones
que se pueden efectuar sobre el tablero. Por ejemplo, el método \verb|play| hace uso de 
operaciones sobre el tablero:
\begin{verbatim}
    def play
      until @board.won?
        @board[@x_player.move(@board)] = @x_player.mark # @board["b2"] = "X"
        break if @board.won?
        
        @board[@o_player.move(@board)] = @o_player.mark 
      end
      
      @o_player.finish @board  
      @x_player.finish @board
    end
\end{verbatim}
Eso significa que tenemos que definir en la clase \verb|Board| predicados como \verb|won?| y
operaciones como \verb|[]=(indice, value)| además del \verb|initialize|:
\begin{verbatim}
  class Board
    class Row
      ....
    end
    
    MOVES = %w{a1    a2   a3   b1   b2   b3   c1   c2   c3}
    # Define constant INDICES
    INDICES = Hash.new { |h, k| h[k] = MOVES.find_index(k) }

    def self.name_to_index( name )# Receives "b2" and returns 4
      INDICES[name]
    end
    
    def self.index_to_name( index ) # Receives the index, like 4 and returns "b2"
      MOVES[index]
    end
    
    def initialize( squares )
      @squares = squares # An array of Strings: [ " ", " ", " ", " ", "X", " ", " ", " ", "O"]
    end
      
    include SquaresContainer
    
    def []( *indices )
      if indices.size == 2                  # board[1,2] is @squares[7]
        super indices[0] + indices[1] * 3   # calls SquaresContainer [] method
      elsif indices[0].is_a? Fixnum         # board[7]
        super indices[0]
      else                                  # board["b2"]
        super Board.name_to_index(indices[0].to_s)
      end
    end

    def []=(indice, value)                  # board["b2"] = "X"
      m = Board.name_to_index(indice)
      @squares[m] = value
    end
    
    ....
    
    def moves
      moves = [ ]
      @squares.each_with_index do |s, i|
        moves << Board.index_to_name(i) if s == " "
      end
      moves # returns the set of feasible moves [ "b3", "c2", ... ]
    end
    
    ....
    
    BOARD =<<EOS

  +---+---+---+
a | 0 | 1 | 2 |
  +---+---+---+
b | 3 | 4 | 5 |
  +---+---+---+
c | 6 | 7 | 8 |
  +---+---+---+
    1   2   3

EOS
    def to_s
      BOARD.gsub(/(\d)(?= \|)/) { |i| @squares[i.to_i] }
    end

  end
end
\end{verbatim}
El predicado  \verb|won?| recorre todas las posibles filas con \verb|each_row| comprobando 
si hay tres alineadas:

\begin{verbatim}
    HORIZONTALS = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ]
    COLUMNS     = [ [0, 3, 6], [1, 4, 7], [2, 5, 8] ]
    DIAGONALS   = [ [0, 4, 8], [2, 4, 6] ]
    ROWS = HORIZONTALS + COLUMNS + DIAGONALS

    def each_row
      ROWS.each do |e|
        yield Row.new(@squares.values_at(*e), e)
      end
    end

    def won?
      each_row do |row|
        return "X" if row.xs == 3 # "X" wins
        return "O" if row.os == 3 # "O" wins
      end
      return " " if blanks == 0   # tie
      false
    end
\end{verbatim}

\subsection{La Clase Row}
Como se ve, hemos delegado en la clase \verb|Row| la tarea de contar el número de marcas.
La clase \verb|Row| representa a un objeto fila del tablero, incluyendo las diagonales.
Sólo tiene dos métodos porque los dema´s los obtiene del módulo \verb|SquaresContainer|:
\begin{verbatim}
  class Board
    class Row
      def initialize( squares, names )
        @squares  = squares
        @names    = names
      end
      
      include SquaresContainer
      
      def to_board_name( index ) 
        Board.index_to_name(@names[index]) 
      end
    end
    .... 
end
\end{verbatim}
El método auxiliar \verb|to_board_name| recibe un índice de la fila, columna o diagonal que
representa el objeto \verb|Row| (supongamos que por ejemplo \verb|@squares = ["X","O"," "], @names = [2, 4, 6]| y \verb|index = 2|
y devuelve la notación jugada (\verb|"c2"|) que define a esa casilla.

En realidad todos los métodos de conteo \verb|xs|, \verb|os|, \verb|blanks| son proveídos por el módulo 
\verb|SquaresContainer|:
\begin{verbatim}
module TicTacToe
  module SquaresContainer
    def []( index ) @squares[index] end

    def blanks()  @squares.find_all { |s| s == " " }.size end
    def os()      @squares.find_all { |s| s == "O" }.size end
    def xs()      @squares.find_all { |s| s == "X" }.size end
  end
  .... 
end
\end{verbatim}
Este mixin es incluído por \verb|Rows| para proveer los contadores
para las filas, columnas y diagonales. Pero es también incluído/reutilizado por la clase
\verb|Board| para comprobar cuando no hay casillas en blanco y ha habido un empate:
\begin{verbatim}
    def won?
      each_row do |row|
        return "X" if row.xs == 3 # "X" wins
        return "O" if row.os == 3 # "O" wins
      end
      return " " if blanks == 0   # Aqui self es el objeto Board.
      false                       # Reutilizamos blanks
    end
\end{verbatim}

\subsection{Código Completo del TicTacToe}
\begin{verbatim}
#!/usr/bin/env ruby
#---
# Visit http://www.pragmaticprogrammer.com/titles/fr_quiz 
#---


module TicTacToe
  module SquaresContainer
    def []( index ) @squares[index] end

    def blanks()  @squares.find_all { |s| s == " " }.size end
    def os()      @squares.find_all { |s| s == "O" }.size end
    def xs()      @squares.find_all { |s| s == "X" }.size end
  end
  
  class Board
    class Row
      def initialize( squares, names )
        @squares  = squares
        @names    = names
      end
      
      include SquaresContainer
      
      def to_board_name( index ) 
        Board.index_to_name(@names[index]) 
      end
    end
    
    MOVES = %w{a1    a2   a3   b1   b2   b3   c1   c2   c3}
    # Define constant INDICES
    INDICES = Hash.new { |h, k| h[k] = MOVES.find_index(k) }

    def self.name_to_index( name )# Receives "b2" and returns 4
      INDICES[name]
    end
    
    def self.index_to_name( index ) # Receives the index, like 4 and returns "b2"
      MOVES[index]
    end
    
    def initialize( squares )
      @squares = squares # An array of Strings: [ " ", " ", " ", " ", "X", " ", " ", " ", "O"]
    end
      
    include SquaresContainer
    
    def []( *indices )
      if indices.size == 2                  # board[1,2] is @squares[7]
        super indices[0] + indices[1] * 3   # calls SquaresContainer [] method
      elsif indices[0].is_a? Fixnum         # board[7]
        super indices[0]
      else                                  # board["b2"]
        super Board.name_to_index(indices[0].to_s)
      end
    end

    def []=(indice, value)                  # board["b2"] = "X"
      m = Board.name_to_index(indice)
      @squares[m] = value
    end
    
    HORIZONTALS = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ]
    COLUMNS     = [ [0, 3, 6], [1, 4, 7], [2, 5, 8] ]
    DIAGONALS   = [ [0, 4, 8], [2, 4, 6] ]
    ROWS = HORIZONTALS + COLUMNS + DIAGONALS

    def each_row
      ROWS.each do |e|
        yield Row.new(@squares.values_at(*e), e)
      end
    end
    
    def moves
      moves = [ ]
      @squares.each_with_index do |s, i|
        moves << Board.index_to_name(i) if s == " "
      end
      moves # returns the set of feasible moves [ "b3", "c2", ... ]
    end
    
    def won?
      each_row do |row|
        return "X" if row.xs == 3 # "X" wins
        return "O" if row.os == 3 # "O" wins
      end
      return " " if blanks == 0   # tie
      false
    end
    
    BOARD =<<EOS

  +---+---+---+
a | 0 | 1 | 2 |
  +---+---+---+
b | 3 | 4 | 5 |
  +---+---+---+
c | 6 | 7 | 8 |
  +---+---+---+
    1   2   3

EOS
    def to_s
      BOARD.gsub(/(\d)(?= \|)/) { |i| @squares[i.to_i] }
    end

  end
end

module TicTacToe
  class Player
    def initialize( mark )
      @mark = mark # "X" or "O" or " "
    end
    
    attr_reader :mark
    
    def move( board )
      raise NotImplementedError, "Player subclasses must define move()."
    end
    
    def finish( final_board )  
    end
  end
end

module TicTacToe
  class HumanPlayer < Player
    def move( board )
      print board
      
      moves = board.moves
      print "Your move?  (format: b3)  "
      move = $stdin.gets
      until moves.include?(move.chomp.downcase)
        print "Invalid move.  Try again.  "
        move = $stdin.gets
      end
      move.chomp
    end
    
    def finish( final_board )
      print final_board
      
      if final_board.won? == @mark
        print "Congratulations, you win.\n\n"
      elsif final_board.won? == " "
        print "Tie game.\n\n"
      else
        print "You lost tic-tac-toe?!\n\n"
      end
    end
    
  end
end

module TicTacToe
  class DumbPlayer < Player
    def move( board )
      moves = board.moves
      moves[rand(moves.size)]
    end
  end
  
  class SmartPlayer < Player
    def move( board )
      moves = board.moves
      
      # If I have a win, take it.  If he is threatening to win, stop it.
      board.each_row do |row|
        if row.blanks == 1 and (row.xs == 2 or row.os == 2)
          (0..2).each do |e|
            return row.to_board_name(e) if row[e] == " "
          end
        end
      end

      # Take the center if open.
      return "b2" if moves.include? "b2"

      # Defend opposite corners.
      if board[0] != @mark and board[0] != " " and board[8] == " "
        return "c3"
      elsif board[8] != @mark and board[8] != " " and board[0] == " "
        return "a1"
      elsif board[2] != @mark and board[2] != " " and board[6] == " "
        return "c1"
      elsif board[6] != @mark and board[6] != " " and board[2] == " "
        return "a3"
      end
      
      # Defend against the special case XOX on a diagonal.
      if board.xs == 2 and board.os == 1 and board[4] == "O" and
         (board[0] == "X" and board[8] == "X") or
         (board[2] == "X" and board[6] == "X")
        return %w{a2 b1 b3 c2}[rand(4)]
      end
      
      # Or make a random move.
      moves[rand(moves.size)]
    end
  end
end

module TicTacToe
  class Game
    def initialize( player1, player2, random = true )
      if random and rand(2) == 1
        @x_player = player2.new("X")
        @o_player = player1.new("O")
      else
        @x_player = player1.new("X")
        @o_player = player2.new("O")
      end
      
      @board = Board.new([" "] * 9)
    end
    
    attr_reader :x_player, :o_player
    
    def play
      until @board.won?
        @board[@x_player.move(@board)] = @x_player.mark
        break if @board.won?
        
        @board[@o_player.move(@board)] = @o_player.mark
      end
      
      @o_player.finish @board
      @x_player.finish @board
    end
    
  end
end

if __FILE__ == $0
  if ARGV.size > 0 and ARGV[0] == "-d"
    game = TicTacToe::Game.new TicTacToe::HumanPlayer,
                   TicTacToe::DumbPlayer
  else
    game = TicTacToe::Game.new TicTacToe::HumanPlayer,
                   TicTacToe::SmartPlayer
  end
  game.play
end
\end{verbatim}

\section{Juegos con Gosu}


\begin{enumerate}
\item  \htmladdnormallink{gosu}{http://www.libgosu.org/}
\item  \htmladdnormallink{gosu en github}{https://github.com/jlnr/gosu}
\item  \htmladdnormallink{ejemplos usando gosu}{https://github.com/jlnr/gosu/tree/master/examples}
\item 
\htmladdnormallink{RubyforKids}{http://ruby4kids.com/ruby4kids}
\item 
\htmladdnormallink{RubyforKids screencasts}{http://ruby4kids.com/ruby4kids/public/web_page/14}
\item 
\htmladdnormallink{RubyforKids en Español}{http://ruby4kids.com/ruby4kids/public/web_page/17}
\item 
\htmladdnormallink{Programming with kids Español}{http://www.alexrothenberg.com/2011/11/14/programming-with-kids.html}
\item 
\htmladdnormallink{Juego del Tetris usando Gosu}{https://github.com/PhilCK/Falling-Blocks}
\item 
\htmladdnormallink{Variante del Tutorial del star fighter}{https://github.com/masonhale/Starfighter-Gosu-Tutorial} con disparos, estrellas cayendo y música
\end{enumerate}

Para entender este código véase el tutorial 
en 
\htmladdnormallink{Gosu Ruby Tutorial}{https://github.com/jlnr/gosu/wiki/Ruby-Tutorial}.
Las imágenes pueden encontrarse en el directorio \htmladdnormallink{examples/media}{https://github.com/jlnr/gosu/tree/master/examples/media} de Gosu.

<%= listing %q{
require 'rubygems'
require 'gosu'

module ZOrder
  Background, Stars, Player, UI = *0..3
end

class Player
  attr_reader :score

  def initialize(window)
    @image = Gosu::Image.new(window, "media/Starfighter.bmp", false)
    @beep = Gosu::Sample.new(window, "media/Beep.wav")
    @x = @y = @vel_x = @vel_y = @angle = 0.0
    @score = 0
  end

  def warp(x, y)
    @x, @y = x, y
  end
  
  def turn_left
    @angle -= 4.5
  end
  
  def turn_right
    @angle += 4.5
  end
  
  def accelerate
    @vel_x += Gosu::offset_x(@angle, 0.5)
    @vel_y += Gosu::offset_y(@angle, 0.5)
  end
  
  def move
    @x += @vel_x
    @y += @vel_y
    @x %= 640
    @y %= 480
    
    @vel_x *= 0.95
    @vel_y *= 0.95
  end

  def draw
    @image.draw_rot(@x, @y, ZOrder::Player, @angle)
  end
  
  def collect_stars(stars)
    stars.reject! do |star|
      if Gosu::distance(@x, @y, star.x, star.y) < 35 then
        @score += 10
        @beep.play
        true
      else
        false
      end
    end
  end
end

class Star
  attr_reader :x, :y
  
  def initialize(animation)
    @animation = animation
    @color = Gosu::Color.new(0xff000000)
    @color.red = rand(256 - 40) + 40
    @color.green = rand(256 - 40) + 40
    @color.blue = rand(256 - 40) + 40
    @x = rand * 640
    @y = rand * 480
  end

  def draw  
    img = @animation[Gosu::milliseconds / 100 % @animation.size]
    img.draw(@x - img.width / 2.0, @y - img.height / 2.0,
        ZOrder::Stars, 1, 1, @color, :add)
  end
end

class GameWindow < Gosu::Window
  def initialize
    super(640, 480, false)
    self.caption = "Gosu Tutorial Game"
    
    @background_image = Gosu::Image.new(self, "media/Space.png", true)
    
    @player = Player.new(self)
    @player.warp(320, 240)

    @star_anim = Gosu::Image::load_tiles(self, "media/Star.png", 25, 25, false)
    @stars = Array.new
    
    @font = Gosu::Font.new(self, Gosu::default_font_name, 20)
  end

  def update
    if button_down? Gosu::KbLeft or button_down? Gosu::GpLeft then
      @player.turn_left
    end
    if button_down? Gosu::KbRight or button_down? Gosu::GpRight then
      @player.turn_right
    end
    if button_down? Gosu::KbUp or button_down? Gosu::GpButton0 then
      @player.accelerate
    end
    @player.move
    @player.collect_stars(@stars)
    
    if rand(100) < 4 and @stars.size < 25 then
      @stars.push(Star.new(@star_anim))
    end
  end

  def draw
    @background_image.draw(0, 0, ZOrder::Background)
    @player.draw
    @stars.each { |star| star.draw }
    @font.draw("Score: #{@player.score}", 10, 10, ZOrder::UI, 1.0, 1.0, 0xffffff00)
  end

  def button_down(id)
    if id == Gosu::KbEscape then
      close
    end
  end
end

window = GameWindow.new
window.show
}%>
