
\parrafo{Introducción}
A session is used to keep state during requests. If activated, you
have one session hash per user session:

\begin{verbatim}
enable :sessions

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end
\end{verbatim}
\begin{enumerate}
\item 
Note that \verb|enable :sessions| actually stores all data in a cookie
\item   This might not always be what you want (storing lots of data will increase your traffic, for instance)
\item  You can use any Rack session middleware: in order to do so, do not call \verb|enable :sessions|, but instead pull in your middleware of choice as you would any other middleware:

\begin{verbatim}
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end
\end{verbatim}
\item 
To improve security, the session data in the cookie is signed with a session secret
\item  A random secret is generated for you by Sinatra
\item  However, since this secret will change with every start of your application, you might want to set the secret yourself, so all your application instances share it:
\begin{verbatim}
set :session_secret, 'super secret'
\end{verbatim}
If you want to configure it further, you may also store a hash with options in the sessions setting:
\begin{verbatim}
set :sessions, :domain => 'foo.com'
\end{verbatim}
\item 
Just use
\verb|session.clear| to destroy the session.
\begin{verbatim}
get '/login' do
    session[:username] = params[:username]
    "logged in as #{session[:username]}"
  end

  get '/logout' do
    old_user = session[:username]
    session.clear
    "logged out #{old_user}"
  end
\end{verbatim}
\end{enumerate}


\parrafo{Cookies}
\begin{enumerate}
\item 
According to the Computer Science definition, a cookie, which is also known as an HTTP cookie, a tracking cookie, or a browser cookie, is a piece of text, no bigger than 4 kilobytes, which is stored on the user’s computer by a web server via a web browser
\item  It is a key-value pair structure, which is designed to retain specific information such as user preferences, user authentication, shopping carts, demographics, sessions, or any other data used by a website
\item  This mechanism, which was developed by Netscape in the distant 1994, provides a way to receive information from a web server and to send it back from the web browser absolutely unchanged
\item  This system complements the stateless nature of the HTTP protocol as it provides enough memory to store pieces of information during HTTP transactions

\item 
When you try to access a web site, your web browser connects to a web server and it sends a request for the respective page
\item  Then the web server replies by sending the requested content and it simultaneously stores a new cookie on your computer
\item  Every time the web browser requests web pages from the web server, it always sends the respective cookies back to the web server
\item  The process takes place as described, if the web browser supports cookies and the user allows their usage
\item  Only the web server can modify one or more of the cookie values
\item  Then it sends them to the web browser upon replying to a specific request

\item According to the RFC2965 specification, cookies are case insensitive
\item  A set of defined properties is inherent to the cookie structure  Those properties include:
 an expiration date, a path and a domain
\item  The first attribute requires a date defined in \verb|Wdy, DD-Mon-YYYY HH:MM:SS GMT| format
\item  The rest of the cookie characteristics require a \verb|path| and/or a \verb|domain| defined as a string
\item  Let’s take a look at this example:

\begin{verbatim}
Cookie: key0=value0; ...; keyX=valueX; expires=Wed, 23-Sep-2009 23:59:59 GMT; path=/; domain=.yoursite.com
\end{verbatim}

\item 
When the \verb|expiration| date is defined, your cookie will be \cei{persistent} as it will reoccur in different sessions until the set \verb|expiration| date has been reached
\item  If the \verb|expiration| date has not been defined in the cookie, it will occur until the end of your current session or when you close your web browser
\item  If the \verb|path| and/or the \verb|domain| attributes have been defined in your cookie, then the web server limits the scope of the cookie to that specific \verb|domain|, \verb|sub-domain| or \verb|path|
\end{enumerate}

\parrafo{Ejemplo con Sesiones}
\begin{verbatim}
require 'rubygems'
require 'sinatra'
require 'haml'

enable :sessions

get '/' do
  session["user"] ||= nil
  haml :index
end

get '/introduction' do
  haml :introduction
end

post '/introduction' do
  session["user"] = params[:name]
  redirect '/'
end

get '/bye' do
  session["user"] = nil
  haml :bye
end
\end{verbatim}

\parrafo{Ejemplo con Cookies}
\begin{enumerate}
\item 
The last example will demonstrate how to directly manage cookies through the 
\verb|request| and \verb|response| singletons provided by Sinatra
\item  You will see in the following example that the previously described process involving the use cookies is clearly implemented
\item  This technique is recommended when your application requires to use persistent and/or scoped cookies
\item  In this example, the application uses two persistent cookies, which expire at the same time, in order to store and manage different configuration data
\end{enumerate}

\begin{verbatim}
require 'sinatra'
require 'haml'

get '/' do
  @@expiration_date = Time.now + (60 * 2) \
  unless request.cookies.key?('some_options') && request.cookies.key?('other_options')
  haml :index
end

get '/some_options' do
  @some_cookie = request.cookies["some_options"]
  haml :some_options
end

post '/some_options' do  
  response.set_cookie('some_options', :value => cookie_values(params), :expires => @@expiration_date)
  redirect '/'
end

get '/other_options' do
  @other_cookie = request.cookies["other_options"]
  haml :other_options
end

post '/other_options' do
  response.set_cookie('other_options', :value => cookie_values(params),:expires => @@expiration_date)
  redirect '/'
end

helpers do
  def cookie_values(parameters)
    values = {}
    parameters.each do |key, value|
      case key
      when 'options'
        values[value] = true
      else
        values[key] = true
      end
    end
    values
  end
end
\end{verbatim}

\parrafo{Problemas}
\begin{enumerate}
\item 
\htmladdnormallink{I'm not sure why but my session gets wiped out every request?}{http://stackoverflow.com/questions/8957594/sinatra-session-gets-destroyed-automatically}
\item 
To keep sessions consistent you need to set a session secret, e.g.:

\begin{verbatim}
set :session_secret, 'super secret'
\end{verbatim}
When it's not set sinatra generates random one on application start
and shotgun restarts application before every request.
\end{enumerate}

\parrafo{Véanse}

\begin{enumerate}
\item 
\htmladdnormallink{Daily Ruby Tips \#60 – Simple Use of Sessions in Sinatra
May 6, 2013}{http://brettu.com/ruby-daily-ruby-tips-60-simple-use-of-sessions-in-sinatra/}
\item 
La sección {\it Cookies} en Rack \ref{section:cookies}.
\item 
\htmladdnormallink{Cookie-based Sessions in Sinatra
by JULIO JAVIER CICCHELLI on SEPTEMBER 30, 2009}{http://rubylearning.com/blog/2009/09/30/cookie-based-sessions-in-sinatra/}
RubyLearning Blog. El código está en
\htmladdnormallink{un Gist en GitHub}{http://gist.github.com/205962}
\end{enumerate}


